Привет! Давай продолжим работу над проектом под кодовым названием Urbaxio.

Главная Идея:
Мы создаем основу для очень гибкого 3D-редактора, что-то вроде "конструктора САПР-песочницы", вдохновляясь идеями из Blender, SketchUp и Dreams (PS4). Представь себе упрощенный SketchUp, но построенный на принципах максимальной модульности. Каждая новая функция (будь то инструмент рисования, симуляция или сложный CAD-алгоритм) в идеале должна быть отдельным, легко подключаемым и отключаемым "плагином" (динамической библиотекой DLL/SO). Ядро должно быть минимальным и стабильным, предоставляя четкое API для плагинов и оболочки.

Моя Роль и Твоя Помощь:
Я выступаю в роли "навигатора" и конечного пользователя. Я не профессиональный C++ разработчик, поэтому твоя помощь в написании и отладке кода будет ключевой. Вся эта затея с модульностью во многом придумана для того, чтобы нам было удобнее работать вместе, учитывая ограничения контекстного окна ИИ. Мне нужно, чтобы ты мог эффективно работать с отдельными частями кода, не требуя каждый раз загрузки всего проекта.

Как Мы Работаем (ВАЖНО!):
Для продуктивной работы, пожалуйста, строго следуй этим правилам:
-ПОЛНЫЕ ФАЙЛЫ: ВСЕГДА пиши файлы кода полностью. Никаких ..., // ... (остальной код) или других сокращений. Если ты изменяешь несколько файлов, предоставь полный код для каждого измененного файла.
-МАРКЕРЫ ФАЙЛОВ: ВСЕГДА размещай маркер файла (например, --- File: path/to/file.cpp ---) перед блоком кода, к которому он относится, на отдельной строке. НЕ включай его внутрь блока кода.
-КОММЕНТАРИИ НА АНГЛИЙСКОМ: Используй только английские комментарии в коде (// Like this comment). Пожалуйста, не используй русские комментарии.
-ФОРМАТИРОВАНИЕ КОДА: Используй правильное форматирование кода. Избегай чрезмерно длинных строк. Используй разумные отступы и переносы строк для читаемости.
-СТИЛЬ И СТРУКТУРА: Придерживайся существующего стиля кода и структуры проекта.
-ПРИОРИТЕТ ПОЛЬЗОВАТЕЛЯ: Помни, что этот проект создается специально для меня. Мой комфорт, предпочтения и удобство (например, легкость копирования кода) являются главным приоритетом. Адаптируй решения соответствующим образом.
-КОМАНДЫ ДЛЯ МЕНЯ: В конце каждого твоего ответа, содержащего код, всегда приводи стандартную последовательность команд для сборки/запуска (формат см. ниже в секции USER COMMANDS).

Контекст Проекта (Снапшот Кода):
Чтобы ты был в курсе всего кода, я предоставлю тебе содержимое файла project_snapshot.txt. Он содержит все актуальные исходные файлы, CMake-скрипты и конфигурационные файлы проекта. В самом начале этого файла также продублированы инструкции для тебя и команды для меня.

Технологический Стек:
Язык: C++ (стандарт C++17)
Система сборки: CMake (генерирует проекты Visual Studio 2022)
Менеджер пакетов: vcpkg
Зависимости: fmt, sdl2, glad, imgui, glm, opencascade (7.9.1)
Графика: OpenGL 3.3+ Core Profile
ОС: Windows x64

Структура Проекта:
cad_kernel/: Обертка над OpenCascade (статическая библиотека).
engine/: Ядро движка (сцена, объекты, команды) (статическая библиотека).
engine/include/engine/commands/ и engine/src/commands/: Система команд Undo/Redo.
shell/: Основное приложение, оболочка (исполняемый файл).
shell/include/tools/ и shell/src/tools/: Система инструментов (ToolManager, SelectTool, LineTool, PushPullTool).
cmake/: Вспомогательные скрипты CMake.

Текущий Статус Проекта (Что уже работает):
Ключевое достижение: Мы завершили масштабный этап улучшения навигации в 3D-пространстве, сделав ее интуитивной и профессиональной, на уровне лучших отраслевых стандартов.
"Умное" приближение к курсору (Dolly Zoom): Стандартное приближение колесиком мыши теперь работает по принципу "zoom to mouse". Камера выполняет рейкастинг, определяет геометрию под курсором и приближается именно к ней, а не к абстрактному центру.
Динамическая скорость навигации: Скорость приближения и панирования теперь зависит от расстояния до объекта под курсором. Это позволяет делать быстрые перемещения по большой сцене и очень точные, медленные движения при работе с мелкими деталями.
Вращение вокруг выбранной точки: Вращение (орбитирование) теперь происходит не вокруг фиксированного центра, а вокруг точки на объекте, на которую пользователь нажал средней кнопкой мыши. Это позволяет интуитивно осматривать любую часть модели.
Бесшовный переход Панирование-Вращение: Реализован плавный переход от панирования (Shift+ЦКМ) к вращению (ЦКМ) без необходимости отпускать кнопку мыши, что значительно ускоряет рабочий процесс.
Корректное освещение: Исправлена фундаментальная ошибка в обработке нормалей, из-за которой грани объектов могли случайным образом становиться черными после булевых операций. Теперь освещение стабильно и предсказуемо.

Дальнейшие Направления Развития:
После серьезной работы над ядром и навигацией, мы продолжим курс на улучшение пользовательского опыта и расширение функционала.
Приоритет №1: Инкрементальные улучшения UX. Я (пользователь) продолжу активно тестировать приложение и находить мелкие недочеты, "шероховатости" и потенциальные улучшения в работе инструментов, интерфейса и общего взаимодействия. Твоя задача — оперативно реализовывать эти небольшие, но важные изменения.
Приоритет №2 (после UX): Устранение оставшихся проблем со стабильностью, в частности, редкой ошибки, когда при рисовании "из точки в точку" создается новая грань вместо разрезания существующей.

Долгосрочные цели (после улучшения UI):
Реализация удаления геометрии (линий и граней) с поддержкой Undo/Redo.
Расширение системы привязок (перпендикуляр, параллельность, касание).
Вынос инструментов в динамические библиотеки (DLL/SO).

--- AI INSTRUCTIONS ---

IMPORTANT:
1. ALWAYS write complete files. Do NOT use '...' or '// ... (rest of the code)' or similar abbreviations. Check ALL files you were asked to modify.
2. Use ONLY English comments in the code (// English comment). Do NOT use Russian comments.
3. Adhere to the existing coding style and structure.
4. After every successful change that compiles and works, create a Git commit by providing the user with the necessary commands.
5. At the end of your response, ALWAYS include the standard command sequence for the user (see USER COMMANDS section below for format).

--- END AI INSTRUCTIONS ---

--- USER COMMANDS (Standard Workflow) ---

# 1. Clean Build (if CMakeLists.txt or dependencies changed, or if problems occur)
#    Run these in Developer CommandPrompt for VS
# cd /d C:/Users/illia/OneDrive/Документы/programming/Urbaxio
# rmdir /s /q build
# mkdir build
# cd build
# cmake .. -G "Visual Studio 17 2022" -A x64 -DCMAKE_TOOLCHAIN_FILE=C:/vcpkg/scripts/buildsystems/vcpkg.cmake
# cmake --build . --config Debug -- /p:VcpkgEnableManifest=true

# 2. Incremental Build (if only .cpp/.h files changed)
#    Run these in Developer Command Prompt for VS (inside the existing 'build' directory)
# cd /d C:/Users/illia/OneDrive/Документы/programming/Urbaxio/build
# cmake --build . --config Debug -- /p:VcpkgEnableManifest=true

# 3. Run Application (after successful build)
#    Run in Developer Command Prompt for VS
# cd /d C:/Users/illia/OneDrive/Документы/programming/Urbaxio/build/shell/Debug
# .\Urbaxio.exe
#    (Or find Urbaxio.exe in build\bin\Debug or build\shell\Debug and double-click)

# 4. Generate Code Snapshot (run when needed for AI)
#    Run in Developer Command Prompt for VS (inside the 'build' directory)
# cd /d C:/Users/illia/OneDrive/Документы/programming/Urbaxio/build
# cmake --build . --target generate_snapshot

# 5. Git Commit & Push (after successful changes)
#    Run in Developer Command Prompt for VS (from project root)
# cd /d C:/Users/illia/OneDrive/Документы/programming/Urbaxio
# git add .
# git commit -m "A descriptive commit message"
# git push origin main

--- END USER COMMANDS ---

--- Project Code Snapshot ---

ENCODINGUTF8ENCODINGUTF8--- File: .gitignore ---
ENCODINGUTF8# CMake
/build/
/install/
CMakeUserPresets.json

# Visual Studio
.vs/
*.VC.db
*.VC.VC.opendb
*.suo
*.user

# Build artifacts
*.exe
*.dll
*.lib
*.pdb
*.ilk
*.obj
*.log 

project_snapshot.txt
pixdetz.txt
ENCODINGUTF8ENCODINGUTF8--- File: CMakeLists.txt ---
ENCODINGUTF8# Минимальная версия CMake
cmake_minimum_required(VERSION 3.18)

# Название проекта
project(Urbaxio VERSION 0.0.1 LANGUAGES CXX)

# --- Find OpenCASCADE (MANUAL, HARDCODED PATH) ---
# We are completely bypassing vcpkg's manifest for OpenCASCADE.
# We point directly to the files installed on your system.
set(OCCT_INSTALL_DIR "C:/vcpkg/installed/x64-windows")
message(STATUS "Using hardcoded OpenCASCADE path: ${OCCT_INSTALL_DIR}")

set(OpenCASCADE_INCLUDE_DIR "${OCCT_INSTALL_DIR}/include/opencascade")
include_directories(${OpenCASCADE_INCLUDE_DIR})
message(STATUS "Manually set OpenCASCADE include dir: ${OpenCASCADE_INCLUDE_DIR}")

set(OCCT_LIB_DIR_RELEASE "${OCCT_INSTALL_DIR}/lib")
set(OCCT_LIB_DIR_DEBUG "${OCCT_INSTALL_DIR}/debug/lib")

# List of required modules for OCCT 7.9.1. TKBOP is now TKBool.
set(OCCT_MODULES TKernel TKMath TKPrim TKBRep TKTopAlgo TKG2d TKG3d TKMesh TKBO TKService TKShHealing TKBool)
set(OpenCASCADE_LIBRARIES "")
foreach(module ${OCCT_MODULES})
    list(APPEND OpenCASCADE_LIBRARIES "optimized" "${OCCT_LIB_DIR_RELEASE}/${module}.lib" "debug" "${OCCT_LIB_DIR_DEBUG}/${module}.lib")
endforeach()
message(STATUS "Manually located OpenCASCADE libraries from hardcoded path.")
# --- End OpenCASCADE Find ---


# Определяем версию для использования в коде
set(PROJECT_VERSION ${Urbaxio_VERSION})
add_compile_definitions(URBAXIO_VERSION_STRING="${PROJECT_VERSION}")
message(STATUS "Project version: ${PROJECT_VERSION}")

# Устанавливаем стандарт C++
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED True)
set(CMAKE_CXX_EXTENSIONS OFF)

# Add compile option for UTF-8 source files, required by libraries like fmt
if(MSVC)
    add_compile_options(/utf-8)
endif()

# Включаем папку cmake для поиска модулей
list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake)

# Добавляем подпапку с CAD ядром (оберткой)
add_subdirectory(cad_kernel)

# Добавляем подпапку с движком
add_subdirectory(engine)

# Добавляем подпапку с исполняемым файлом приложения
add_subdirectory(shell)

# --- Пользовательская цель для генерации снапшота кода ---
add_custom_target(generate_snapshot
    # Запускаем CMake в режиме скрипта для выполнения GenerateSnapshot.cmake
    COMMAND ${CMAKE_COMMAND} -DPROJECT_SOURCE_DIR=${CMAKE_SOURCE_DIR} -P "${CMAKE_CURRENT_SOURCE_DIR}/cmake/GenerateSnapshot.cmake"
    COMMENT "Generating project_snapshot.txt with all source code..."
    VERBATIM # Важно для правильной передачи команд
)
message(STATUS "Added custom target 'generate_snapshot'. Run 'cmake --build . --target generate_snapshot' to execute.")


# --- Настройки для удобства разработки ---
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)

# --- Выводим информационные сообщения ---
message(STATUS "Project Root: ${CMAKE_SOURCE_DIR}")
message(STATUS "Build Directory: ${CMAKE_BINARY_DIR}")
message(STATUS "Using C++ Standard: ${CMAKE_CXX_STANDARD}") 
ENCODINGUTF8ENCODINGUTF8--- File: CMakePresets.json ---
ENCODINGUTF8{
  "$schema": "https://raw.githubusercontent.com/CMake/CMake/master/Help/manual/presets/schema.json",
  "version": 8,
  "cmakeMinimumRequired": {
    "major": 3,
    "minor": 23,
    "patch": 0
  },
  "configurePresets": [
    {
      "name": "vs2022",
      "displayName": "Visual Studio 2022",
      "generator": "Visual Studio 17 2022",
      "architecture": "x64",
      "binaryDir": "${sourceDir}/build",
      "cacheVariables": {
        "CMAKE_TOOLCHAIN_FILE": {
          "type": "STRING",
          "value": "C:/vcpkg/scripts/buildsystems/vcpkg.cmake"
        }
      }
    }
  ],
  "buildPresets": [
    {
      "name": "vs2022-debug",
      "displayName": "Debug",
      "configurePreset": "vs2022",
      "configuration": "Debug"
    },
    {
      "name": "vs2022-release",
      "displayName": "Release",
      "configurePreset": "vs2022",
      "configuration": "Release"
    }
  ],
  "testPresets": [
    {
      "name": "vs2022-debug-test",
      "displayName": "Debug Tests",
      "configurePreset": "vs2022",
      "configuration": "Debug",
      "output": {
        "verbosity": "verbose"
      }
    }
  ]
} 
ENCODINGUTF8ENCODINGUTF8--- File: vcpkg.json ---
ENCODINGUTF8{
  "$schema": "https://raw.githubusercontent.com/microsoft/vcpkg-tool/main/docs/vcpkg.schema.json",
  "name": "urbaxio",
  "version-string": "0.0.1",
  "dependencies": [
    "fmt",
    "sdl2",
    "glad",
    "imgui",
    "glm"
  ]
}
ENCODINGUTF8ENCODINGUTF8--- File: cad_kernel/include/cad_kernel/MeshBuffers.h ---
ENCODINGUTF8#pragma once //                             

#include <vector>

namespace Urbaxio::CadKernel {

    //                                                      
    struct MeshBuffers
    {
        std::vector<float> vertices;   //                   (x, y, z, x, y, z, ...)
        std::vector<float> normals;    //                (nx, ny, nz, nx, ny, nz, ...)
        std::vector<unsigned int> indices; //                       (i1, i2, i3, i1, i2, i3, ...)

        //                          
        void clear() {
            vertices.clear();
            normals.clear();
            indices.clear();
        }

        //         ,              
        bool isEmpty() const {
            return vertices.empty() || indices.empty();
        }
    };

} // namespace Urbaxio::CadKernel 
ENCODINGUTF8ENCODINGUTF8--- File: cad_kernel/include/cad_kernel/cad_kernel.h ---
ENCODINGUTF8#ifndef URBAXIO_CAD_KERNEL_H
#define URBAXIO_CAD_KERNEL_H

#include <cstdint>
#include <memory>
#include "cad_kernel/MeshBuffers.h"

class TopoDS_Shape;

namespace Urbaxio::CadKernel {

    // ---                             OCCT ---
    //                       ShapeDeleter   operator()
    struct ShapeDeleter {
        void operator()(TopoDS_Shape* s) const; //                    .cpp
    };
    using OCCT_ShapeUniquePtr = std::unique_ptr<TopoDS_Shape, ShapeDeleter>;

    // ---              ---
    void initialize();
    OCCT_ShapeUniquePtr create_box(double dx, double dy, double dz);

    //                     
    MeshBuffers TriangulateShape(const TopoDS_Shape& shape,
        double linDefl = -1.0,
        double angDefl = 0.35);

} // namespace Urbaxio::CadKernel

#endif // URBAXIO_CAD_KERNEL_H
ENCODINGUTF8ENCODINGUTF8--- File: cad_kernel/src/TriangulateShape.cpp ---
ENCODINGUTF8#include "cad_kernel/MeshBuffers.h"
#include "cad_kernel/cad_kernel.h"

// ---                       OpenCascade ---
#include <Standard_Macro.hxx>
#include <Standard_ErrorHandler.hxx>
#include <Standard_Failure.hxx>
#include <BRepMesh_IncrementalMesh.hxx>
#include <BRep_Tool.hxx>
#include <BRepTools.hxx>
#include <BRepBndLib.hxx>
#include <Bnd_Box.hxx>
#include <Poly_Triangulation.hxx>
#include <TopExp_Explorer.hxx>
#include <TopoDS.hxx>
#include <TopoDS_Face.hxx>
#include <TopLoc_Location.hxx>
#include <TopAbs.hxx>
#include <gp_Pnt.hxx>
#include <gp_Dir.hxx>
#include <gp_Trsf.hxx>
#include <gp_Vec.hxx>
#include <gp_XYZ.hxx>
#include <TColgp_Array1OfPnt.hxx>      //                  
#include <TShort_Array1OfShortReal.hxx> //              (           )
#include <TColgp_HArray1OfPnt.hxx>      // Handle                  
#include <TShort_HArray1OfShortReal.hxx>// Handle                     
#include <Poly_Array1OfTriangle.hxx>   //                          
#include <Message.hxx>

#include <cmath>
#include <vector>
#include <iostream>

namespace Urbaxio::CadKernel {

    MeshBuffers TriangulateShape(const TopoDS_Shape& shape,
        double linDefl,
        double angDefl)
    {
        MeshBuffers out;
        if (shape.IsNull()) { /*...*/ return out; }

        // --- 1.                             ---
        if (linDefl <= 0.0) { /* ... (            linDefl        ) ... */ }
        //             linDefl:
        if (linDefl <= 0.0)
        {
            Bnd_Box bb;
            try { BRepBndLib::Add(shape, bb, false); }
            catch (...) {
                try { BRepBndLib::Add(shape, bb, true); }
                catch (...) {}
            }
            if (bb.IsVoid()) { linDefl = 0.1; }
            else {
                double diag = bb.SquareExtent() > 1.e-16 ? std::sqrt(bb.SquareExtent()) : 1.0;
                linDefl = diag * 0.002;
                if (linDefl < 1e-6) linDefl = 1e-6;
            }
            Message::SendInfo() << "TriangulateShape: Using linear deflection: " << linDefl << ", angular deflection: " << angDefl;
        }

        // --- 2.                     ---
        Standard_ErrorHandler aErrHandler;
        try {
            OCC_CATCH_SIGNALS
                BRepTools::Clean(shape);
            BRepMesh_IncrementalMesh mesher(shape, linDefl, Standard_False, angDefl, Standard_True);
            if (!mesher.IsDone()) { /* ... */ }
            else { /* ... */ }
        }
        catch (Standard_Failure& e) { /* ... */ return out; }
        catch (...) { /* ... */ return out; }

        // --- 3.                                       ---
        TopExp_Explorer faceExplorer(shape, TopAbs_FACE);
        for (; faceExplorer.More(); faceExplorer.Next())
        {
            const TopoDS_Face& face = TopoDS::Face(faceExplorer.Current());
            TopLoc_Location location;
            Handle(Poly_Triangulation) triangulation = BRep_Tool::Triangulation(face, location);

            if (triangulation.IsNull() || triangulation->NbNodes() == 0 || triangulation->NbTriangles() == 0) {
                continue; //                               
            }

            // --- 4.          /                 ---
            if (!triangulation->HasNormals()) {
                try {
                    triangulation->ComputeNormals();
                }
                catch (...) { continue; }
            }
            if (!triangulation->HasNormals()) { continue; }

            const gp_Trsf& transformation = location.Transformation();

            // ---                  API                        ---
            const Handle(TColgp_HArray1OfPnt) hNodes = triangulation->MapNodeArray();
            const Handle(TShort_HArray1OfShortReal) hNormals = triangulation->MapNormalArray();
            const Poly_Array1OfTriangle& triangles = triangulation->Triangles(); //                                       

            //          ,                     
            if (hNodes.IsNull() || hNormals.IsNull() || hNormals->Length() != hNodes->Length() * 3) {
                Message::SendFail() << "TriangulateShape: Error getting nodes or normals arrays or size mismatch.";
                continue;
            }
            const TColgp_Array1OfPnt& nodes = hNodes->Array1();
            const TShort_Array1OfShortReal& normals = hNormals->Array1(); //                       ShortReal!

            const unsigned int baseVertexIndex = static_cast<unsigned int>(out.vertices.size() / 3);

            // --- 5.                            ---
            for (Standard_Integer i = nodes.Lower(); i <= nodes.Upper(); ++i) {
                gp_Pnt vertex = nodes(i);
                vertex.Transform(transformation);

                //                       (nx, ny, nz)    TShort_Array1OfShortReal
                Standard_Integer normIndex = (i - nodes.Lower()) * 3 + normals.Lower(); //                  normals
                if (normIndex + 2 > normals.Upper()) { //                
                    Message::SendFail() << "TriangulateShape: Normal index out of bounds.";
                    continue; //                                      
                }
                gp_Dir normal(normals(normIndex), normals(normIndex + 1), normals(normIndex + 2));

                // --- FIX: Correctly transform the normal direction ---
                // This applies only the rotational part of the transformation, ignoring any translation.
                // The old method incorrectly treated the normal as a point, corrupting its direction.
                normal.Transform(transformation);

                // Invert normal for reversed faces for correct lighting
                if (face.Orientation() == TopAbs_REVERSED) {
                    normal.Reverse();
                }
                // --- END FIX ---

                out.vertices.push_back(static_cast<float>(vertex.X()));
                out.vertices.push_back(static_cast<float>(vertex.Y()));
                out.vertices.push_back(static_cast<float>(vertex.Z()));
                out.normals.push_back(static_cast<float>(normal.X()));
                out.normals.push_back(static_cast<float>(normal.Y()));
                out.normals.push_back(static_cast<float>(normal.Z()));
            }

            // --- 6.                  ---
            const bool reversed = (face.Orientation() == TopAbs_REVERSED);
            for (Standard_Integer i = triangles.Lower(); i <= triangles.Upper(); ++i) {
                Standard_Integer n1, n2, n3;
                triangles(i).Get(n1, n2, n3);
                unsigned int idx1 = baseVertexIndex + n1 - 1;
                unsigned int idx2 = baseVertexIndex + n2 - 1;
                unsigned int idx3 = baseVertexIndex + n3 - 1;
                unsigned int max_index = baseVertexIndex + nodes.Length() - 1;
                if (idx1 > max_index || idx2 > max_index || idx3 > max_index) { continue; }
                if (reversed) { std::swap(idx2, idx3); }
                out.indices.push_back(idx1);
                out.indices.push_back(idx2);
                out.indices.push_back(idx3);
            }
        }

        Message::SendInfo() << "TriangulateShape: Finished. Vertices: " << out.vertices.size() / 3
            << ", Indices: " << out.indices.size();

        return out;
    }

} // namespace Urbaxio::CadKernel 
ENCODINGUTF8ENCODINGUTF8--- File: cad_kernel/src/cad_kernel.cpp ---
ENCODINGUTF8#include "cad_kernel/cad_kernel.h"
#include <Standard_Macro.hxx>
#include <Standard_ErrorHandler.hxx>
#include <Standard_Version.hxx>
#include <Standard_Failure.hxx>
#include <Message.hxx>
#include <Message_PrinterOStream.hxx>
#include <Message_Messenger.hxx>
#include <gp_Pnt.hxx>
#include <gp_Ax2.hxx>
#include <TopoDS_Shape.hxx>
#include <BRepPrimAPI_MakeBox.hxx>
#include <exception>
#include <iostream>

namespace Urbaxio::CadKernel {

    // ---                                   ---
    //                                   .h
    void ShapeDeleter::operator()(TopoDS_Shape* shape) const {
        if (shape) {
            std::cout << "CAD Kernel: Deleting shape via ShapeDeleter (raw pointer: " << shape << ")" << std::endl;
            delete shape;
        }
    }

    // ---               (             ) ---
    void initialize() {
        Message::SendInfo() << "CAD Kernel: Initializing OpenCascade Technology (OCCT) v"
            << OCC_VERSION_STRING_EXT << "...";
        try {
            Message::SendInfo() << "CAD Kernel: Standard Allocator initialization skipped (not needed).";
            Handle(Message_Messenger) aMessenger = Message::DefaultMessenger();
            if (aMessenger->Printers().IsEmpty()) {
                Handle(Message_Printer) aPrinter = new Message_PrinterOStream;
                aMessenger->AddPrinter(aPrinter);
                Message::SendInfo() << "CAD Kernel: Default Messenger and OStream Printer Initialized.";
            }
            else {
                Message::SendInfo() << "CAD Kernel: Default Messenger already has printers.";
            }
        }
        catch (Standard_Failure& e) {
            Message::SendFail() << "CAD Kernel: OCCT Standard_Failure during extra initialization: " << e.GetMessageString();
        }
        catch (...) {
            Message::SendFail() << "CAD Kernel: Unknown exception during extra initialization.";
        }
    }

    // --- create_box (             ) ---
    OCCT_ShapeUniquePtr create_box(double dx, double dy, double dz) {
        Message::SendInfo() << "CAD Kernel: Attempting to create box with dimensions: "
            << dx << ", " << dy << ", " << dz;
        Standard_ErrorHandler aErrorHandler;
        try {
            OCC_CATCH_SIGNALS
                if (dx <= 0 || dy <= 0 || dz <= 0) { return nullptr; }
            BRepPrimAPI_MakeBox mkBox(dx, dy, dz);
            mkBox.Build();
            if (!mkBox.IsDone()) {
                Message::SendFail() << "CAD Kernel: Error! BRepPrimAPI_MakeBox failed. IsDone() returned false.";
                return nullptr;
            }
            if (mkBox.Shape().IsNull()) {
                Message::SendFail() << "CAD Kernel: Error! BRepPrimAPI_MakeBox succeeded but produced a Null shape.";
                return nullptr;
            }
            TopoDS_Shape* shape_copy = new TopoDS_Shape(mkBox.Shape());
            Message::SendInfo() << "CAD Kernel: Box created successfully (raw pointer: " << shape_copy << ")";
            return OCCT_ShapeUniquePtr(shape_copy);
        }
        catch (Standard_Failure& e) {
            Message::SendFail() << "CAD Kernel: Caught OCCT Standard_Failure exception during box creation.";
            Message::SendFail() << "CAD Kernel: OCCT Exception Message: " << e.GetMessageString();
            return nullptr;
        }
        catch (...) {
            Message::SendFail() << "CAD Kernel: Caught unknown exception during box creation.";
            return nullptr;
        }
    }

} // namespace Urbaxio::CadKernel 
ENCODINGUTF8ENCODINGUTF8--- File: engine/include/engine/engine.h ---
ENCODINGUTF8#ifndef URBAXIO_ENGINE_H
#define URBAXIO_ENGINE_H

#include <cstdint>

#ifdef _WIN32
#ifdef URBAXIO_ENGINE_BUILD_SHARED
#define URBAXIO_API __declspec(dllexport)
#else
#define URBAXIO_API // __declspec(dllimport)
#endif
#else // Linux, macOS
#define URBAXIO_API __attribute__((visibility("default")))
#endif

//                                 Scene     C API
typedef struct Scene Scene;

#ifdef __cplusplus
extern "C" {
#endif

    URBAXIO_API void initialize_engine();
    URBAXIO_API Scene* get_engine_scene(); //                                  

    // TODO:          API                       (        /                     . .)

#ifdef __cplusplus
} // extern "C"
#endif

#endif // URBAXIO_ENGINE_H
ENCODINGUTF8ENCODINGUTF8--- File: engine/include/engine/line.h ---
ENCODINGUTF8#pragma once

#include <glm/glm.hpp>

namespace Urbaxio::Engine {

    // Represents a single line segment in the scene.
    struct Line {
        glm::vec3 start;
        glm::vec3 end;
        bool usedInFace = false;
        // Other properties like layer, style, etc. can be added later.
    };

} // namespace Urbaxio::Engine 
ENCODINGUTF8ENCODINGUTF8--- File: engine/include/engine/scene.h ---
ENCODINGUTF8#ifndef URBAXIO_SCENE_H
#define URBAXIO_SCENE_H

#include <cstdint>
#include <memory>
#include <string>
#include <unordered_map>
#include <vector>
#include <map>
#include <utility>
#include <set>
#include <glm/glm.hpp>
#include "engine/line.h"
#include "engine/commands/CommandManager.h"

// Forward declare OCCT types
class gp_Pln;
class gp_Pnt;
class TopoDS_Shape;
class TopoDS_Face;
class TopoDS_Edge;

namespace Urbaxio::Engine { class SceneObject; }

namespace Urbaxio {
    const float SCENE_POINT_EQUALITY_TOLERANCE = 1e-4f;

    struct Vec3Comparator {
        bool operator()(const glm::vec3& a, const glm::vec3& b) const {
            if (std::abs(a.x - b.x) > SCENE_POINT_EQUALITY_TOLERANCE) return a.x < b.x;
            if (std::abs(a.y - b.y) > SCENE_POINT_EQUALITY_TOLERANCE) return a.y < b.y;
            if (std::abs(a.z - b.z) > SCENE_POINT_EQUALITY_TOLERANCE) return a.z < b.z;
            return false;
        }
    };
}

namespace Urbaxio::Engine {

    // Memento for capturing the topological state of the scene.
    // Full definition is here.
    struct ObjectState {
        uint64_t id;
        std::string name;
        std::vector<char> serializedShape; // Empty if object has no shape
    };
    
    struct SceneState {
        std::map<uint64_t, Line> lines;
        std::map<glm::vec3, std::vector<uint64_t>, Urbaxio::Vec3Comparator> vertexAdjacency;
        std::map<uint64_t, ObjectState> objects; // Changed to a map of a new struct
        uint64_t nextObjectId;
        uint64_t nextLineId;
    };

    class Scene {
    public:
        Scene();
        ~Scene();

        Scene(const Scene&) = delete;
        Scene& operator=(const Scene&) = delete;
        Scene(Scene&&) = default;
        Scene& operator=(Scene&&) = default;

        SceneObject* create_object(const std::string& name);
        SceneObject* create_box_object(const std::string& name, double dx, double dy, double dz);
        SceneObject* get_object_by_id(uint64_t id);
        const SceneObject* get_object_by_id(uint64_t id) const;
        std::vector<SceneObject*> get_all_objects();
        std::vector<const SceneObject*> get_all_objects() const;
        void DeleteObject(uint64_t id);

        // --- Undo/Redo System ---
        CommandManager* getCommandManager();
        std::unique_ptr<SceneState> CaptureState();
        void RestoreState(const SceneState& state);

        // --- Line Management ---
        void AddUserLine(const glm::vec3& start, const glm::vec3& end);
        void ClearUserLines();
        const std::map<uint64_t, Line>& GetAllLines() const;
        glm::vec3 SplitLineAtPoint(uint64_t lineId, const glm::vec3& splitPoint);

        // --- Geometry Modification ---
        // Old version for direct calls (e.g. from tests or tools not using commands)
        bool ExtrudeFace(uint64_t objectId, const std::vector<size_t>& faceTriangleIndices, const glm::vec3& direction, float distance, bool disableMerge = false);
        // NEW robust version for commands, using geometric data. This will be the main implementation.
        bool ExtrudeFace(uint64_t objectId, const std::vector<glm::vec3>& faceVertices, const glm::vec3& direction, float distance, bool disableMerge = false);

        // --- Geometry Synchronization ---
        void UpdateObjectBoundary(SceneObject* obj);

        // --- Testing Infrastructure ---
        void ClearScene();
        void TestFaceSplitting();

        // --- Finders ---
        // Public helper to find an object containing a specific face
        SceneObject* FindObjectByFace(const std::vector<glm::vec3>& faceVertices);

    private:
        std::unordered_map<uint64_t, std::unique_ptr<SceneObject>> objects_;
        uint64_t next_object_id_ = 1;
        int next_face_id_ = 1;

        std::map<uint64_t, Line> lines_;
        uint64_t next_line_id_ = 1;
        std::map<glm::vec3, std::vector<uint64_t>, Urbaxio::Vec3Comparator> vertexAdjacency_;
        
        std::unique_ptr<CommandManager> commandManager_;

        uint64_t AddSingleLineSegment(const glm::vec3& start, const glm::vec3& end);
        void RemoveLine(uint64_t lineId);
        glm::vec3 MergeOrAddVertex(const glm::vec3& p);
        
        std::vector<std::pair<glm::vec3, glm::vec3>> ExtractEdgesFromShape(const TopoDS_Shape& shape);
        
        static bool LineSegmentIntersection(
            const glm::vec3& p1, const glm::vec3& p2,
            const glm::vec3& p3, const glm::vec3& p4,
            glm::vec3& out_intersection_point
        );
        
        void FindAndCreateFaces(uint64_t newLineId);
        bool PerformDFS(
            const glm::vec3& startNode,
            const glm::vec3& currentNode,
            const glm::vec3& targetNode,
            std::vector<glm::vec3>& currentPathVertices,
            std::vector<uint64_t>& currentPathLineIDs,
            std::set<uint64_t>& visitedLinesDFS,
            uint64_t originatingLineId,
            int& recursionDepth
        );
        bool ArePointsCoplanar(const std::vector<glm::vec3>& points, gp_Pln& outPlane);
        void CreateOCCTFace(const std::vector<glm::vec3>& orderedVertices, const gp_Pln& plane);
        
        TopoDS_Face FindOriginalFace(
            const TopoDS_Shape& shape, 
            const std::vector<glm::vec3>& faceVertices, 
            const glm::vec3& guideNormal
        );
        void AnalyzeShape(const TopoDS_Shape& shape, const std::string& label);

        SceneObject* CreateRectangularFace(const std::string& name, const gp_Pnt& p1, const gp_Pnt& p2, const gp_Pnt& p3, const gp_Pnt& p4);
    };

}

#endif // URBAXIO_SCENE_H
ENCODINGUTF8ENCODINGUTF8--- File: engine/include/engine/scene_object.h ---
ENCODINGUTF8#ifndef URBAXIO_SCENE_OBJECT_H
#define URBAXIO_SCENE_OBJECT_H

#include <cstdint>
#include <string>
#include <memory>
#include <vector>
#include <set> // <-- ADDED for boundaryLineIDs
#include <cad_kernel/cad_kernel.h>
#include <cad_kernel/MeshBuffers.h>
#include <glad/glad.h> //     GLuint

class TopoDS_Shape;

namespace Urbaxio::Engine {

    class SceneObject {
    public:
        SceneObject(uint64_t id, std::string name);
        ~SceneObject();

        SceneObject(const SceneObject&) = delete;
        SceneObject& operator=(const SceneObject&) = delete;
        SceneObject(SceneObject&&) noexcept;
        SceneObject& operator=(SceneObject&&) noexcept;

        uint64_t get_id() const;
        const std::string& get_name() const;
        void set_name(const std::string& name);

        //           BRep
        void set_shape(Urbaxio::CadKernel::OCCT_ShapeUniquePtr shape);
        const TopoDS_Shape* get_shape() const;
        bool has_shape() const;

        //                (CPU)
        void set_mesh_buffers(Urbaxio::CadKernel::MeshBuffers buffers);
        const Urbaxio::CadKernel::MeshBuffers& get_mesh_buffers() const;
        bool has_mesh() const;

        //                       (GPU)
        GLuint vao = 0;
        GLuint vbo_vertices = 0;
        GLuint vbo_normals = 0;
        GLuint ebo = 0;
        GLsizei index_count = 0;
        
        // --- NEW: Link to boundary lines ---
        std::set<uint64_t> boundaryLineIDs;

    private:
        uint64_t id_;
        std::string name_;
        Urbaxio::CadKernel::OCCT_ShapeUniquePtr shape_ = nullptr;
        Urbaxio::CadKernel::MeshBuffers mesh_buffers_;
    };

} // namespace Urbaxio::Engine

#endif // URBAXIO_SCENE_OBJECT_H
ENCODINGUTF8ENCODINGUTF8--- File: engine/src/engine_main.cpp ---
ENCODINGUTF8#include "engine/engine.h"       // Наш API
#include "engine/scene.h"        // Класс сцены
#include "engine/scene_object.h" // Класс объекта
#include <cad_kernel/cad_kernel.h> // Обертка над OCCT

#include <fmt/core.h>            // Форматирование строк
#include <memory>                // Для std::unique_ptr
#include <iostream>              // Для std::cerr
#include <string>                // Для std::string
#include <vector>                // For std::vector
#include <cmath>                 // For sqrt
#include <map>                   // For subdivision map
#include <glm/glm.hpp>           // For glm::normalize
// #include <stdlib.h> // Больше не нужен для _putenv_s

// OpenCascade includes for capsule generation
#include <gp_Ax2.hxx>
#include <gp_Pnt.hxx>
#include <gp_Trsf.hxx>
#include <gp_Vec.hxx>
#include <BRepPrimAPI_MakeCylinder.hxx>
#include <BRepPrimAPI_MakeSphere.hxx>
#include <BRepAlgoAPI_Fuse.hxx>
#include <TopoDS_Shape.hxx>
#include <BRepBuilderAPI_Transform.hxx>

// Глобальный указатель на сцену
std::unique_ptr<Urbaxio::Engine::Scene> g_scene = nullptr;

// --- Определение версии ---
#ifndef URBAXIO_VERSION_STRING
#define URBAXIO_VERSION_STRING "0.0.1-dev"
#endif

namespace { // Anonymous namespace

    // Helper function for icosphere subdivision
    int get_middle_point(int p1, int p2, std::map<long long, int>& middlePointIndexCache, std::vector<glm::vec3>& vertices, float radius) {
        bool firstIsSmaller = p1 < p2;
        long long smallerIndex = firstIsSmaller ? p1 : p2;
        long long greaterIndex = firstIsSmaller ? p2 : p1;
        long long key = (smallerIndex << 32) + greaterIndex;

        auto it = middlePointIndexCache.find(key);
        if (it != middlePointIndexCache.end()) {
            return it->second;
        }

        glm::vec3 point1 = vertices[p1];
        glm::vec3 point2 = vertices[p2];
        glm::vec3 middle = glm::vec3(
            (point1.x + point2.x) / 2.0f,
            (point1.y + point2.y) / 2.0f,
            (point1.z + point2.z) / 2.0f
        );
        
        vertices.push_back(glm::normalize(middle) * radius);
        int i = vertices.size() - 1;
        middlePointIndexCache[key] = i;
        return i;
    }

    // Creates an icosphere mesh with a specified subdivision level
    Urbaxio::CadKernel::MeshBuffers CreateIcoSphereMesh(float radius, int subdivision) {
        Urbaxio::CadKernel::MeshBuffers mesh;
        const float t = (1.0f + std::sqrt(5.0f)) / 2.0f;

        std::vector<glm::vec3> base_vertices = {
            {-1,  t,  0}, { 1,  t,  0}, {-1, -t,  0}, { 1, -t,  0},
            { 0, -1,  t}, { 0,  1,  t}, { 0, -1, -t}, { 0,  1, -t},
            { t,  0, -1}, { t,  0,  1}, {-t,  0, -1}, {-t,  0,  1}
        };

        for (auto& v : base_vertices) {
            v = glm::normalize(v) * radius;
        }

        std::vector<unsigned int> base_indices = {
             0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
             1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
             3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
             4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
        };

        std::map<long long, int> middlePointIndexCache;
        std::vector<glm::vec3> temp_vertices_glm = base_vertices;

        for (int s = 0; s < subdivision; s++) {
            std::vector<unsigned int> new_indices;
            for (size_t i = 0; i < base_indices.size(); i += 3) {
                int i0 = base_indices[i];
                int i1 = base_indices[i+1];
                int i2 = base_indices[i+2];
                int a = get_middle_point(i0, i1, middlePointIndexCache, temp_vertices_glm, radius);
                int b = get_middle_point(i1, i2, middlePointIndexCache, temp_vertices_glm, radius);
                int c = get_middle_point(i2, i0, middlePointIndexCache, temp_vertices_glm, radius);
                new_indices.insert(new_indices.end(), { (unsigned int)i0, (unsigned int)a, (unsigned int)c });
                new_indices.insert(new_indices.end(), { (unsigned int)i1, (unsigned int)b, (unsigned int)a });
                new_indices.insert(new_indices.end(), { (unsigned int)i2, (unsigned int)c, (unsigned int)b });
                new_indices.insert(new_indices.end(), { (unsigned int)a,  (unsigned int)b, (unsigned int)c });
            }
            base_indices = new_indices;
        }

        mesh.indices = base_indices;

        mesh.vertices.clear();
        mesh.normals.clear();
        for(const auto& v : temp_vertices_glm) {
            glm::vec3 norm = glm::normalize(v);
            mesh.vertices.push_back(v.x);
            mesh.vertices.push_back(v.y);
            mesh.vertices.push_back(v.z);
            mesh.normals.push_back(norm.x);
            mesh.normals.push_back(norm.y);
            mesh.normals.push_back(norm.z);
        }
        
        return mesh;
    }

    // Creates a capsule mesh along the Z axis
    Urbaxio::CadKernel::MeshBuffers CreateCapsuleMesh(float radius, float height) {
        try {
            // ============ АВТОМАТИЧЕСКИЕ СМЕЩЕНИЯ (зависят от размеров) ============
            // Базовые коэффициенты для правильного отображения:
            float cylinder_z_factor = -0.25f;  // Цилиндр смещается вниз на 25% от высоты
            float sphere_z_factor = 0.25f;     // Сферы смещаются вверх на 25% от высоты
            
            // Вычисляем автоматические смещения:
            float cylinder_offset_x = 0.0f;
            float cylinder_offset_y = 0.0f;
            float cylinder_offset_z = height * cylinder_z_factor;  // Зависит от высоты
            
            float sphere_offset_x = 0.0f;
            float sphere_offset_y = 0.0f;
            float sphere_offset_z = height * sphere_z_factor;      // Зависит от высоты
            // ===================================================================
            
            gp_Pnt center(cylinder_offset_x, cylinder_offset_y, cylinder_offset_z);  // <-- ЦЕНТР ЦИЛИНДРА
            gp_Dir z_dir(0, 0, 1);
            gp_Ax2 axis(center, z_dir);
            
            TopoDS_Shape cylinder = BRepPrimAPI_MakeCylinder(axis, radius, height);

            // Create a single sphere at the origin
            TopoDS_Shape sphere = BRepPrimAPI_MakeSphere(gp_Pnt(0,0,0), radius);

            // Create two transformations to move the sphere to the ends (независимые смещения)
            gp_Trsf top_trsf, bot_trsf;
            top_trsf.SetTranslation(gp_Vec(
                cylinder_offset_x + sphere_offset_x, 
                cylinder_offset_y + sphere_offset_y, 
                cylinder_offset_z + sphere_offset_z + height / 2.0
            ));
            bot_trsf.SetTranslation(gp_Vec(
                cylinder_offset_x + sphere_offset_x, 
                cylinder_offset_y + sphere_offset_y, 
                cylinder_offset_z + sphere_offset_z - height / 2.0
            ));

            // Apply transformations
            TopoDS_Shape top_hemisphere = BRepBuilderAPI_Transform(sphere, top_trsf);
            TopoDS_Shape bot_hemisphere = BRepBuilderAPI_Transform(sphere, bot_trsf);
            
            // Fuse them
            BRepAlgoAPI_Fuse fuser(cylinder, top_hemisphere);
            fuser.Build();
            TopoDS_Shape result = fuser.Shape();
            
            BRepAlgoAPI_Fuse final_fuser(result, bot_hemisphere);
            final_fuser.Build();
            result = final_fuser.Shape();
            
            return Urbaxio::CadKernel::TriangulateShape(result);

        } catch(...) {
            std::cerr << "OCCT Exception during capsule creation!" << std::endl;
            return Urbaxio::CadKernel::MeshBuffers();
        }
    }
} // end anonymous namespace

// --- Реализация функций API ---
#ifdef __cplusplus
extern "C" {
#endif

    URBAXIO_API void initialize_engine() {
        fmt::print("Engine: Initializing Urbaxio Engine v{}...\n", URBAXIO_VERSION_STRING);

        // Инициализируем CAD ядро (обертку)
        Urbaxio::CadKernel::initialize(); // Вызываем инициализацию OCCT

        if (!g_scene) {
            g_scene = std::make_unique<Urbaxio::Engine::Scene>();
            fmt::print("Engine: Scene created successfully.\n");

            // --- Create Center Marker Sphere ---
            auto* center_sphere = g_scene->create_object("CenterMarker");
            if (center_sphere) {
                // Subdivision level 2 gives a nicely rounded sphere
                Urbaxio::CadKernel::MeshBuffers sphere_mesh = CreateIcoSphereMesh(0.25f, 2);
                center_sphere->set_mesh_buffers(std::move(sphere_mesh));
                fmt::print("Engine: Created 'CenterMarker' object with ID {}.\n", center_sphere->get_id());
            } else {
                fmt::print(stderr, "Engine: Error creating 'CenterMarker' object!\n");
            }

        }
        else {
            fmt::print("Engine: Engine already initialized.\n");
        }
    }

    // Функция для получения доступа к глобальной сцене из C API
    URBAXIO_API Scene* get_engine_scene() {
        return reinterpret_cast<Scene*>(g_scene.get());
    }

#ifdef __cplusplus
} // extern "C"
#endif 
ENCODINGUTF8ENCODINGUTF8--- File: engine/src/scene.cpp ---
ENCODINGUTF8#define GLM_ENABLE_EXPERIMENTAL
#include "engine/scene.h"
#include "engine/scene_object.h"
#include <cad_kernel/cad_kernel.h>
#include <cad_kernel/MeshBuffers.h> // Required for TriangulateShape return type

#include <utility>
#include <vector>
#include <unordered_map>
#include <iostream>
#include <set>
#include <cmath>
#include <algorithm> // for std::reverse, std::remove

#include <glm/gtx/norm.hpp>
#include <glm/common.hpp> // For epsilonEqual
#include <glm/gtx/intersect.hpp> // For glm::intersectRayPlane

// OCCT Includes for face creation & modification
#include <gp_Pnt.hxx>
#include <gp_Vec.hxx>
#include <gp_Dir.hxx>
#include <gp_Pln.hxx>
#include <GeomAbs_SurfaceType.hxx>
#include <TopoDS.hxx>
#include <TopoDS_Vertex.hxx>
#include <TopoDS_Edge.hxx>
#include <TopoDS_Wire.hxx>
#include <TopoDS_Face.hxx>
#include <TopoDS_Solid.hxx>
#include <TopExp_Explorer.hxx>
#include <TopAbs.hxx>
#include <BRep_Tool.hxx>
#include <BRepAdaptor_Surface.hxx>
#include <BRepLProp_SLProps.hxx>
#include <BRepBuilderAPI_MakeVertex.hxx>
#include <BRepBuilderAPI_MakeEdge.hxx>
#include <BRepBuilderAPI_MakeWire.hxx>
#include <BRepBuilderAPI_MakeFace.hxx>
#include <BRepPrimAPI_MakePrism.hxx>
#include <BRepAlgoAPI_Fuse.hxx>
#include <BRepAlgoAPI_Cut.hxx>
#include <BRepAlgoAPI_Splitter.hxx>
#include <BRepClass_FaceClassifier.hxx>
#include <BRepCheck_Analyzer.hxx>
#include <ShapeFix_Shape.hxx>
#include <Standard_Failure.hxx>
#include <Bnd_Box.hxx>
#include <BRepBndLib.hxx>
#include <GProp_GProps.hxx>
#include <BRepGProp.hxx>
#include <TopTools_IndexedDataMapOfShapeListOfShape.hxx>
#include <TopExp.hxx>
#include <ShapeUpgrade_UnifySameDomain.hxx>

// --- INCLUDES FOR NEW PARAMETRIC SPLITTING ---
#include <Geom2d_Line.hxx>
#include <ShapeAnalysis_Surface.hxx>
#include <BOPAlgo_Splitter.hxx>
#include <BOPAlgo_Alerts.hxx>
#include <gp_Pnt2d.hxx>
#include <gp_Dir2d.hxx>
#include <ShapeBuild_ReShape.hxx> // For tracking sub-shapes after healing
#include <TopTools_ListOfShape.hxx>
#include <GeomAPI_ProjectPointOnCurve.hxx> 
#include <ShapeFix_Wire.hxx> // NEW: Include for wire healing
#include <ShapeExtend_Status.hxx> // NEW: Include for status flags

#include <sstream> // For stringstream
#include <BinTools.hxx> // For serialization


namespace { // Anonymous namespace for utility functions
    bool PointOnLineSegment(const glm::vec3& p, const glm::vec3& a, const glm::vec3& b) {
        const float ON_SEGMENT_TOLERANCE = 1e-4f;
        
        // Quick check if it's one of the endpoints
        if (glm::distance2(p, a) < ON_SEGMENT_TOLERANCE * ON_SEGMENT_TOLERANCE ||
            glm::distance2(p, b) < ON_SEGMENT_TOLERANCE * ON_SEGMENT_TOLERANCE) {
            return false; // It's an endpoint, no split needed
        }

        // Check for collinearity using cross product
        glm::vec3 pa = p - a;
        glm::vec3 ba = b - a;
        if (glm::length2(glm::cross(pa, ba)) > ON_SEGMENT_TOLERANCE * ON_SEGMENT_TOLERANCE) {
            return false; // Not collinear
        }

        // Check if the point is within the segment bounds
        float dot_product = glm::dot(pa, ba);
        if (dot_product < 0.0f || dot_product > glm::length2(ba)) {
            return false; // Outside the segment
        }

        return true;
    }
}

namespace Urbaxio::Engine {

    const float COPLANARITY_TOLERANCE_SCENE = 1e-4f;
    const int MAX_DFS_DEPTH = 50; // Max recursion depth for DFS to prevent stack overflow

    bool AreVec3Equal(const glm::vec3& a, const glm::vec3& b) {
        return glm::all(glm::epsilonEqual(a, b, Urbaxio::SCENE_POINT_EQUALITY_TOLERANCE));
    }

    Scene::Scene() {
        commandManager_ = std::make_unique<CommandManager>();
    }
    Scene::~Scene() = default;

    CommandManager* Scene::getCommandManager() {
        return commandManager_.get();
    }

    // --- NEW: Scene Memento Implementation ---
    std::unique_ptr<SceneState> Scene::CaptureState() {
        auto state = std::make_unique<SceneState>();
        
        state->lines = this->lines_;
        state->vertexAdjacency = this->vertexAdjacency_;
        state->nextObjectId = this->next_object_id_;
        state->nextLineId = this->next_line_id_;
        
        for (const auto& [id, obj_ptr] : this->objects_) {
            ObjectState objState;
            objState.id = id;
            objState.name = obj_ptr->get_name();
            if (obj_ptr->has_shape()) {
                const TopoDS_Shape* shape = obj_ptr->get_shape();
                if (shape && !shape->IsNull()) {
                    std::stringstream ss;
                    try {
                        BinTools::Write(*shape, ss);
                        std::string const& s = ss.str();
                        objState.serializedShape = std::vector<char>(s.begin(), s.end());
                    } catch (...) { /* error */ }
                }
            }
            state->objects[id] = objState;
        }
        return state;
    }
    
    void Scene::RestoreState(const SceneState& state) {
        this->lines_ = state.lines;
        this->vertexAdjacency_ = state.vertexAdjacency;
        this->next_object_id_ = state.nextObjectId;
        this->next_line_id_ = state.nextLineId;

        std::set<uint64_t> newStateObjectIds;
        for (const auto& [id, objState] : state.objects) {
            newStateObjectIds.insert(id);
        }

        for (auto it = this->objects_.begin(); it != this->objects_.end(); ) {
            if (newStateObjectIds.find(it->first) == newStateObjectIds.end()) {
                it = this->objects_.erase(it);
            } else { ++it; }
        }
        
        for (const auto& [id, objState] : state.objects) {
            SceneObject* obj = this->get_object_by_id(id);
            if (!obj) {
                obj = this->create_object(objState.name);
                // Note: create_object assigns a new ID, but for undo/redo we want to preserve the original ID.
                // This would require a custom object creation for full fidelity, but for now we ensure the object exists.
            }

            if (!objState.serializedShape.empty()) {
                TopoDS_Shape restoredShape;
                std::stringstream ss(std::string(objState.serializedShape.begin(), objState.serializedShape.end()));
                try {
                    BinTools::Read(restoredShape, ss);
                    obj->set_shape(Urbaxio::CadKernel::OCCT_ShapeUniquePtr(new TopoDS_Shape(restoredShape)));
                    obj->set_mesh_buffers(Urbaxio::CadKernel::TriangulateShape(*obj->get_shape()));
                    obj->vao = 0;
                    this->UpdateObjectBoundary(obj);
                } catch(...) { /* error */ }
            } else if (obj->has_shape()) {
                obj->set_shape(nullptr);
                obj->set_mesh_buffers({});
                obj->vao = 0;
            }
        }
    }

    SceneObject* Scene::create_object(const std::string& name) { uint64_t new_id = next_object_id_++; auto result = objects_.emplace(new_id, std::make_unique<SceneObject>(new_id, name)); if (result.second) { return result.first->second.get(); } else { std::cerr << "Scene: Failed to insert new object with ID " << new_id << " into map." << std::endl; next_object_id_--; return nullptr; } }
    SceneObject* Scene::create_box_object(const std::string& name, double dx, double dy, double dz) { SceneObject* new_obj = create_object(name); if (!new_obj) { return nullptr; } Urbaxio::CadKernel::OCCT_ShapeUniquePtr box_shape_ptr = Urbaxio::CadKernel::create_box(dx, dy, dz); if (!box_shape_ptr) { return nullptr; } const TopoDS_Shape* shape_to_triangulate = box_shape_ptr.get(); if (!shape_to_triangulate || shape_to_triangulate->IsNull()) { return nullptr; } new_obj->set_shape(std::move(box_shape_ptr)); UpdateObjectBoundary(new_obj); Urbaxio::CadKernel::MeshBuffers mesh_data = Urbaxio::CadKernel::TriangulateShape(*new_obj->get_shape()); if (!mesh_data.isEmpty()) { new_obj->set_mesh_buffers(std::move(mesh_data)); } else { std::cerr << "Scene: Warning - Triangulation failed for box '" << name << "'." << std::endl; } return new_obj; }
    SceneObject* Scene::get_object_by_id(uint64_t id) { auto it = objects_.find(id); if (it != objects_.end()) { return it->second.get(); } return nullptr; }
    const SceneObject* Scene::get_object_by_id(uint64_t id) const { auto it = objects_.find(id); if (it != objects_.end()) { return it->second.get(); } return nullptr; }
    std::vector<SceneObject*> Scene::get_all_objects() { std::vector<SceneObject*> result; result.reserve(objects_.size()); for (auto const& [id, obj_ptr] : objects_) { result.push_back(obj_ptr.get()); } return result; }
    std::vector<const SceneObject*> Scene::get_all_objects() const { std::vector<const SceneObject*> result; result.reserve(objects_.size()); for (auto const& [id, obj_ptr] : objects_) { result.push_back(obj_ptr.get()); } return result; }
    
    // --- Delete Object ---
    void Scene::DeleteObject(uint64_t id) {
        auto it = objects_.find(id);
        if (it == objects_.end()) {
            return;
        }

        SceneObject* obj = it->second.get();

        // Remove the object's boundary lines from the scene
        // Create a copy because RemoveLine modifies the set via UpdateObjectBoundary
        std::set<uint64_t> lines_to_remove = obj->boundaryLineIDs;
        for (uint64_t lineId : lines_to_remove) {
            RemoveLine(lineId);
        }

        // Erase the object from the map, which will call its destructor and free memory
        objects_.erase(it);
        std::cout << "Scene: Deleted object " << id << std::endl;
    }


    // Finds an existing vertex within tolerance or returns the input point.
    // This is the core of vertex merging.
    glm::vec3 Scene::MergeOrAddVertex(const glm::vec3& p) {
        auto it = vertexAdjacency_.find(p);
        if (it != vertexAdjacency_.end()) {
            return it->first; // Return the canonical vertex
        }
        // If not found, it implies a new vertex. The map will be updated when a line is added.
        return p;
    }



    // Public method to add a line.
    void Scene::AddUserLine(const glm::vec3& start, const glm::vec3& end) {
        // --- TRANSACTION LOGIC START ---
        // Store current state to allow for rollback on failure
        auto original_lines = lines_;
        auto original_adjacency = vertexAdjacency_;
        auto original_next_line_id = next_line_id_;

        try {
            // 1. Proactively split existing lines at the new line's endpoints.
            std::vector<std::pair<uint64_t, glm::vec3>> splits_to_perform;
            for (const auto& [line_id, line] : lines_) {
                if (PointOnLineSegment(start, line.start, line.end)) {
                    splits_to_perform.push_back({line_id, start});
                }
                if (PointOnLineSegment(end, line.start, line.end)) {
                    splits_to_perform.push_back({line_id, end});
                }
            }
            for(const auto& split : splits_to_perform) {
                SplitLineAtPoint(split.first, split.second);
            }

            // 2. Find T-junction intersections between the new line segment and existing lines.
            std::map<uint64_t, glm::vec3> intersections_on_existing_lines;
            std::vector<glm::vec3> split_points_on_new_line;

            for (const auto& [existing_id, existing_line] : lines_) {
                glm::vec3 intersection_point;
                if (LineSegmentIntersection(start, end, existing_line.start, existing_line.end, intersection_point)) {
                    intersections_on_existing_lines[existing_id] = intersection_point;
                    split_points_on_new_line.push_back(intersection_point);
                }
            }
            for (const auto& [line_id, point] : intersections_on_existing_lines) {
                SplitLineAtPoint(line_id, point);
            }
            
            // 3. Add the new line, now potentially split by the T-junctions.
            std::vector<glm::vec3> all_points = { start };
            all_points.insert(all_points.end(), split_points_on_new_line.begin(), split_points_on_new_line.end());
            all_points.push_back(end);

            glm::vec3 dir = end - start;
            std::sort(all_points.begin(), all_points.end(), 
                [&start, &dir](const glm::vec3& a, const glm::vec3& b) {
                    if (glm::length2(dir) < 1e-9) return false;
                    return glm::dot(a - start, dir) < glm::dot(b - start, dir);
                });
            all_points.erase(std::unique(all_points.begin(), all_points.end(), AreVec3Equal), all_points.end());

            // 4. Add the new segments and check for new faces for each one.
            std::vector<uint64_t> new_line_ids;
            for (size_t i = 0; i < all_points.size() - 1; ++i) {
                uint64_t new_id = AddSingleLineSegment(all_points[i], all_points[i+1]);
                if (new_id != 0) {
                    new_line_ids.push_back(new_id);
                }
            }
            
            for (uint64_t id : new_line_ids) {
                FindAndCreateFaces(id);
            }
        } catch (...) {
            // --- TRANSACTION ROLLBACK ---
            std::cerr << "An exception occurred during AddUserLine. Rolling back changes." << std::endl;
            lines_ = original_lines;
            vertexAdjacency_ = original_adjacency;
            next_line_id_ = original_next_line_id;
        }
    }

    // This is the internal, "dumb" version of AddUserLine. It only adds a segment and updates adjacency.
    // It does NOT trigger face finding.
    uint64_t Scene::AddSingleLineSegment(const glm::vec3& start, const glm::vec3& end) {
        glm::vec3 canonicalStart = MergeOrAddVertex(start);
        glm::vec3 canonicalEnd = MergeOrAddVertex(end);

        if (AreVec3Equal(canonicalStart, canonicalEnd)) {
            return 0; // Invalid line
        }

        // Check for duplicate lines
        for(const auto& [id, line] : lines_) {
            if ((AreVec3Equal(line.start, canonicalStart) && AreVec3Equal(line.end, canonicalEnd)) ||
                (AreVec3Equal(line.start, canonicalEnd) && AreVec3Equal(line.end, canonicalStart))) {
                return id; // Duplicate line, return existing ID
            }
        }
        
        uint64_t newLineId = next_line_id_++;
        lines_[newLineId] = {canonicalStart, canonicalEnd, false};

        vertexAdjacency_[canonicalStart].push_back(newLineId);
        vertexAdjacency_[canonicalEnd].push_back(newLineId);
        
        return newLineId;
    }

    const std::map<uint64_t, Line>& Scene::GetAllLines() const {
        return lines_;
    }

    void Scene::ClearUserLines() {
        lines_.clear();
        vertexAdjacency_.clear();
        next_line_id_ = 1;
        std::cout << "Scene: Cleared user lines and adjacency data." << std::endl;
    }
    
    void Scene::RemoveLine(uint64_t lineId) {
        auto it = lines_.find(lineId);
        if (it == lines_.end()) return;

        const Line& line = it->second;

        // Remove from start vertex adjacency
        auto& startAdj = vertexAdjacency_[line.start];
        startAdj.erase(std::remove(startAdj.begin(), startAdj.end(), lineId), startAdj.end());
        if (startAdj.empty()) {
            vertexAdjacency_.erase(line.start);
        }

        // Remove from end vertex adjacency
        auto& endAdj = vertexAdjacency_[line.end];
        endAdj.erase(std::remove(endAdj.begin(), endAdj.end(), lineId), endAdj.end());
        if (endAdj.empty()) {
            vertexAdjacency_.erase(line.end);
        }

        // Remove from the main map
        lines_.erase(it);
    }
    
    glm::vec3 Scene::SplitLineAtPoint(uint64_t lineId, const glm::vec3& splitPoint) {
        auto it = lines_.find(lineId);
        if (it == lines_.end()) {
            return splitPoint; // Should not happen
        }

        Line originalLine = it->second;
        glm::vec3 canonicalSplitPoint = MergeOrAddVertex(splitPoint);

        // Check if split point is one of the endpoints
        if (AreVec3Equal(originalLine.start, canonicalSplitPoint) || AreVec3Equal(originalLine.end, canonicalSplitPoint)) {
            return canonicalSplitPoint; // No split needed, just return the merged vertex.
        }

        std::cout << "Scene: Splitting line " << lineId << std::endl;

        // 1. Remove the old line from existence
        RemoveLine(lineId);

        // 2. Add two new lines. Use internal function to avoid recursive intersection checks.
        AddSingleLineSegment(originalLine.start, canonicalSplitPoint);
        AddSingleLineSegment(canonicalSplitPoint, originalLine.end);
        
        // Return the canonical merged vertex for the split point
        return canonicalSplitPoint;
    }

    bool Scene::LineSegmentIntersection(
        const glm::vec3& p1, const glm::vec3& p2, // Segment 1
        const glm::vec3& p3, const glm::vec3& p4, // Segment 2
        glm::vec3& out_intersection_point)
    {
        const float EPSILON = 1e-5f;
        glm::vec3 d1 = p2 - p1;
        glm::vec3 d2 = p4 - p3;

        // --- Robust coplanarity check ---
        glm::vec3 p3_p1 = p3 - p1;
        glm::vec3 plane_normal = glm::cross(d1, p3_p1);
        if (glm::length2(plane_normal) < EPSILON * EPSILON) {
            // All 3 points are collinear. Check if p4 is on the same line.
            if (glm::length2(glm::cross(d1, p4 - p1)) > EPSILON * EPSILON) {
                return false; // Not coplanar/collinear
            }
        } else {
            // Check distance of 4th point to the plane
            float dist = glm::dot(p4 - p1, glm::normalize(plane_normal));
            if (std::abs(dist) > EPSILON) {
                return false; // Not coplanar
            }
        }

        glm::vec3 d1_cross_d2 = glm::cross(d1, d2);
        float d1_cross_d2_lenSq = glm::length2(d1_cross_d2);

        if (d1_cross_d2_lenSq < EPSILON * EPSILON) return false;
        
        float t = glm::dot(glm::cross(p3 - p1, d2), d1_cross_d2) / d1_cross_d2_lenSq;
        if (t < EPSILON || t > 1.0f - EPSILON) return false;

        float u = glm::dot(glm::cross(p3 - p1, d1), d1_cross_d2) / d1_cross_d2_lenSq;
        if (u < EPSILON || u > 1.0f - EPSILON) return false;

        out_intersection_point = p1 + t * d1;
        return true;
    }


    bool Scene::ArePointsCoplanar(const std::vector<glm::vec3>& points, gp_Pln& outPlane) {
        if (points.size() < 3) return false;

        glm::vec3 p0_glm = points[0];
        glm::vec3 p1_glm = glm::vec3(0.0f);
        glm::vec3 p2_glm = glm::vec3(0.0f);
        bool foundP1 = false, foundP2 = false;

        for (size_t i = 1; i < points.size(); ++i) {
            if (!AreVec3Equal(points[i], p0_glm)) {
                p1_glm = points[i];
                foundP1 = true;
                break;
            }
        }
        if (!foundP1) { return false; }

        for (size_t i = 1; i < points.size(); ++i) {
            if (!AreVec3Equal(points[i], p0_glm) && !AreVec3Equal(points[i], p1_glm)) {
                glm::vec3 v1_glm = p1_glm - p0_glm;
                glm::vec3 v2_glm = points[i] - p0_glm;
                if (glm::length(glm::cross(v1_glm, v2_glm)) > Urbaxio::SCENE_POINT_EQUALITY_TOLERANCE) { // Check for non-collinearity
                    p2_glm = points[i];
                    foundP2 = true;
                    break;
                }
            }
        }
        if (!foundP2) { return false; }

        try {
            gp_Pnt occt_p0(p0_glm.x, p0_glm.y, p0_glm.z);
            gp_Vec v1_occt(p1_glm.x - p0_glm.x, p1_glm.y - p0_glm.y, p1_glm.z - p0_glm.z);
            gp_Vec v2_occt(p2_glm.x - p0_glm.x, p2_glm.y - p0_glm.y, p2_glm.z - p0_glm.z);
            
            gp_Vec normal_vec = v1_occt.Crossed(v2_occt);
            if (normal_vec.Magnitude() < gp::Resolution()) { return false; }
            gp_Dir occt_normal_dir(normal_vec);
            outPlane = gp_Pln(occt_p0, occt_normal_dir);

            for (const auto& pt_glm : points) {
                gp_Pnt pt_check(pt_glm.x, pt_glm.y, pt_glm.z);
                if (outPlane.Distance(pt_check) > COPLANARITY_TOLERANCE_SCENE) { return false; }
            }
        } catch (const Standard_Failure& e) {
            std::cerr << "OCCT Exception during plane creation/check: " << e.GetMessageString() << std::endl;
            return false;
        }
        return true;
    }


    bool Scene::PerformDFS(const glm::vec3& pathStartNode, const glm::vec3& currentNode, const glm::vec3& ultimateTargetNode, std::vector<glm::vec3>& currentPathVertices, std::vector<uint64_t>& currentPathLineIDs, std::set<uint64_t>& visitedLinesDFS, uint64_t originatingLineId, int& recursionDepth) {
        if (recursionDepth++ > MAX_DFS_DEPTH) { recursionDepth--; return false; }

        if (AreVec3Equal(currentNode, ultimateTargetNode)) {
            if (currentPathVertices.size() >= 2) { recursionDepth--; return true; }
        }

        auto it = vertexAdjacency_.find(currentNode);
        if (it == vertexAdjacency_.end()) { recursionDepth--; return false; }

        const std::vector<uint64_t>& incidentLines = it->second;

        for (uint64_t lineId : incidentLines) {
            auto line_it = lines_.find(lineId);
            if (line_it == lines_.end()) continue; // Should not happen

            if (lineId == originatingLineId || visitedLinesDFS.count(lineId)) {
                continue;
            }

            const auto& line = line_it->second;
            glm::vec3 nextNode = AreVec3Equal(line.start, currentNode) ? line.end : line.start;

            currentPathVertices.push_back(nextNode);
            currentPathLineIDs.push_back(lineId);
            visitedLinesDFS.insert(lineId);

            bool coplanarCheck = true;
            if (currentPathVertices.size() >= 2) {
                std::vector<glm::vec3> planePoints = {pathStartNode};
                planePoints.insert(planePoints.end(), currentPathVertices.begin(), currentPathVertices.end());
                gp_Pln tempPlane;
                if (!ArePointsCoplanar(planePoints, tempPlane)) { coplanarCheck = false; }
            }

            if (coplanarCheck) {
                if (PerformDFS(pathStartNode, nextNode, ultimateTargetNode, currentPathVertices, currentPathLineIDs, visitedLinesDFS, originatingLineId, recursionDepth)) {
                    recursionDepth--;
                    return true;
                }
            }
            
            visitedLinesDFS.erase(lineId);
            currentPathLineIDs.pop_back();
            currentPathVertices.pop_back();
        }
        recursionDepth--;
        return false;
    }


    void Scene::CreateOCCTFace(const std::vector<glm::vec3>& orderedVertices, const gp_Pln& plane) {
        if (orderedVertices.size() < 3) return;
        BRepBuilderAPI_MakeWire wireMaker;
        std::vector<TopoDS_Edge> edges;
        try {
            for (size_t i = 0; i < orderedVertices.size(); ++i) {
                gp_Pnt p1_occt(orderedVertices[i].x, orderedVertices[i].y, orderedVertices[i].z);
                gp_Pnt p2_occt(orderedVertices[(i + 1) % orderedVertices.size()].x, orderedVertices[(i + 1) % orderedVertices.size()].y, orderedVertices[(i + 1) % orderedVertices.size()].z);
                if (p1_occt.IsEqual(p2_occt, SCENE_POINT_EQUALITY_TOLERANCE)) continue;
                TopoDS_Vertex v1 = BRepBuilderAPI_MakeVertex(p1_occt);
                TopoDS_Vertex v2 = BRepBuilderAPI_MakeVertex(p2_occt);
                TopoDS_Edge edge = BRepBuilderAPI_MakeEdge(v1, v2);
                if (edge.IsNull()) { std::cerr << "OCCT Error: Failed to create edge for face." << std::endl; return; }
                edges.push_back(edge);
            }
            for(const auto& edge : edges) wireMaker.Add(edge);
        } catch (const Standard_Failure& e) { std::cerr << "OCCT Exception during edge/vertex creation for face: " << e.GetMessageString() << std::endl; return; }

        if (wireMaker.IsDone() && !wireMaker.Wire().IsNull()) {
            TopoDS_Wire wire = wireMaker.Wire();
            BRepBuilderAPI_MakeFace faceMaker(plane, wire, Standard_True);
            if (faceMaker.IsDone() && !faceMaker.Face().IsNull()) {
                TopoDS_Face face = faceMaker.Face();
                std::string face_name = "AutoFace_" + std::to_string(next_face_id_++);
                SceneObject* new_face_obj = create_object(face_name);
                if (new_face_obj) {
                    TopoDS_Shape* shape_copy = new TopoDS_Shape(face);
                    new_face_obj->set_shape(Urbaxio::CadKernel::OCCT_ShapeUniquePtr(shape_copy));
                    UpdateObjectBoundary(new_face_obj); // <-- Sync lines
                    Urbaxio::CadKernel::MeshBuffers mesh_data = Urbaxio::CadKernel::TriangulateShape(*new_face_obj->get_shape());
                    if (!mesh_data.isEmpty()) {
                        new_face_obj->set_mesh_buffers(std::move(mesh_data));
                        std::cout << "Scene: Auto-created Face object: " << face_name << ". Mesh ready for GPU." << std::endl;
                    } else { std::cerr << "Scene: Triangulation failed for auto-face " << new_face_obj->get_id() << std::endl; }
                }
            } else { std::cerr << "OCCT Error: Failed to create face from wire. Error: " << faceMaker.Error() << std::endl; }
        } else { std::cerr << "OCCT Error: Failed to create wire for face. Error: " << wireMaker.Error() << std::endl; }
    }


    void Scene::FindAndCreateFaces(uint64_t newLineId) {
        auto line_it = lines_.find(newLineId);
        if (line_it == lines_.end() || line_it->second.usedInFace) {
            return;
        }
        
        const Line& newLine = line_it->second;
        const glm::vec3& pA = newLine.start;
        const glm::vec3& pB = newLine.end;
        
        std::vector<glm::vec3> pathVerticesCollector;
        std::vector<uint64_t> pathLineIDsCollector;
        std::set<uint64_t> visitedLinesInCurrentDFS;
        visitedLinesInCurrentDFS.insert(newLineId);
        int recursionDepth = 0;

        if (!PerformDFS(pA, pB, pA, pathVerticesCollector, pathLineIDsCollector, visitedLinesInCurrentDFS, newLineId, recursionDepth)) {
            return;
        }
        
        std::vector<glm::vec3> finalOrderedVertices;
        finalOrderedVertices.push_back(pA);
        finalOrderedVertices.push_back(pB);
        if (!pathVerticesCollector.empty()) {
            for (size_t i = 0; i < pathVerticesCollector.size() - 1; ++i) {
                finalOrderedVertices.push_back(pathVerticesCollector[i]);
            }
        }
        if (finalOrderedVertices.size() < 3) return;

        SceneObject* hostObject = nullptr;
        TopoDS_Face originalHostFace;
        
        gp_Pln cyclePlane;
        if (ArePointsCoplanar(finalOrderedVertices, cyclePlane)) {
            gp_Dir normalDir = cyclePlane.Axis().Direction();
            glm::vec3 loopNormal(normalDir.X(), normalDir.Y(), normalDir.Z());
            
            for (const auto& [id, obj_ptr] : objects_) {
                if (obj_ptr && obj_ptr->has_shape()) {
                    TopoDS_Face foundFace = FindOriginalFace(*obj_ptr->get_shape(), finalOrderedVertices, loopNormal);
                    if (!foundFace.IsNull()) {
                        hostObject = obj_ptr.get();
                        originalHostFace = foundFace;
                        break; 
                    }
                }
            }
        }

        if (hostObject && !originalHostFace.IsNull()) {
            std::cout << "Scene: Detected new loop on existing face of object " << hostObject->get_id() << ". Attempting PARAMETRIC split." << std::endl;
            try {
                // --- Step 1: Heal the host shape to ensure it's valid for boolean operations ---
                ShapeFix_Shape shapeFixer(*hostObject->get_shape());
                shapeFixer.Perform();
                TopoDS_Shape healedShape = shapeFixer.Shape();
                AnalyzeShape(healedShape, "Healed Host Shape BEFORE split");
                // Re-find the face on the healed shape using the context
                Handle(ShapeBuild_ReShape) context = shapeFixer.Context();
                TopoDS_Shape healedFaceShape = context->Apply(originalHostFace);
                if (healedFaceShape.IsNull() || healedFaceShape.ShapeType() != TopAbs_FACE) {
                     throw Standard_Failure("Could not re-find host face after healing.");
                }
                TopoDS_Face healedHostFace = TopoDS::Face(healedFaceShape);
                AnalyzeShape(healedHostFace, "Healed Host Face BEFORE split");
                Handle(Geom_Surface) hostSurface = BRep_Tool::Surface(healedHostFace);
                if (hostSurface.IsNull()) {
                    throw Standard_Failure("Host face has no underlying surface.");
                }
                Handle(ShapeAnalysis_Surface) analysis = new ShapeAnalysis_Surface(hostSurface);
                // --- Step 2: Create a list of topologically sound edges from the loop vertices ---
                TopTools_ListOfShape edgeList;
                Standard_Real umin, umax, vmin, vmax;
                hostSurface->Bounds(umin, umax, vmin, vmax);
                for (size_t i = 0; i < finalOrderedVertices.size(); ++i) {
                    const glm::vec3& v1_glm = finalOrderedVertices[i];
                    const glm::vec3& v2_glm = finalOrderedVertices[(i + 1) % finalOrderedVertices.size()];
                    gp_Pnt p1_3d(v1_glm.x, v1_glm.y, v1_glm.z);
                    gp_Pnt p2_3d(v2_glm.x, v2_glm.y, v2_glm.z);
                    if (p1_3d.IsEqual(p2_3d, Precision::Confusion())) continue;
                    gp_Pnt2d uv1 = analysis->ValueOfUV(p1_3d, Precision::Confusion());
                    gp_Pnt2d uv2 = analysis->ValueOfUV(p2_3d, Precision::Confusion());
                    uv1.SetX(std::max(umin, std::min(umax, uv1.X())));
                    uv1.SetY(std::max(vmin, std::min(vmax, uv1.Y())));
                    uv2.SetX(std::max(umin, std::min(umax, uv2.X())));
                    uv2.SetY(std::max(vmin, std::min(vmax, uv2.Y())));
                    if (uv1.IsEqual(uv2, Precision::Confusion())) continue;
                    Handle(Geom2d_Line) pcurve = new Geom2d_Line(uv1, gp_Dir2d(uv2.X() - uv1.X(), uv2.Y() - uv1.Y()));
                    Standard_Real u_start = 0.0;
                    Standard_Real u_end = uv1.Distance(uv2);
                    BRepBuilderAPI_MakeEdge edgeMaker(pcurve, hostSurface, u_start, u_end);
                    if (!edgeMaker.IsDone()) {
                         std::stringstream ss;
                         ss << "BRepBuilderAPI_MakeEdge failed for segment " << i << ". "
                            << "From UV(" << uv1.X() << ", " << uv1.Y() << ") to UV(" << uv2.X() << ", " << uv2.Y() << ").";
                         throw Standard_Failure(ss.str().c_str());
                    }
                    edgeList.Append(edgeMaker.Edge());
                }
                BRepBuilderAPI_MakeWire tempWireMaker;
                tempWireMaker.Add(edgeList);
                if (tempWireMaker.Wire().IsNull()) {
                    throw Standard_Failure("BRepBuilderAPI_MakeWire failed to create even a disconnected wire.");
                }
                Handle(ShapeFix_Wire) wireFixer = new ShapeFix_Wire();
                wireFixer->Init(tempWireMaker.Wire(), healedHostFace, Precision::Confusion());
                if (!wireFixer->Perform()) {
                    throw Standard_Failure("ShapeFix_Wire::Perform() returned false, indicating a critical failure.");
                }
                if (wireFixer->LastFixStatus(ShapeExtend_FAIL)) {
                    throw Standard_Failure("ShapeFix_Wire could not fix all problems in the wire (e.g., gaps are too large).");
                }
                TopoDS_Wire cuttingWire = wireFixer->Wire();
                AnalyzeShape(cuttingWire, "Cutting Wire BEFORE split");
                if (cuttingWire.IsNull() || !BRep_Tool::IsClosed(cuttingWire)) {
                    throw Standard_Failure("The final wire created by ShapeFix_Wire is not a single, closed loop.");
                }
                // --- Step 4: Perform the Split operation ---
                BOPAlgo_Splitter splitter;
                TopTools_ListOfShape arguments;
                arguments.Append(healedShape);
                splitter.SetArguments(arguments);
                TopTools_ListOfShape tools;
                tools.Append(cuttingWire);
                splitter.SetTools(tools);
                splitter.Perform();
                // Count faces before for validation
                TopExp_Explorer faceExpBefore(healedShape, TopAbs_FACE);
                int faceCountBefore = 0;
                for (; faceExpBefore.More(); faceExpBefore.Next()) faceCountBefore++;

                splitter.Perform();

                // ROBUSTNESS: Check for errors from the boolean operation itself.
                if (splitter.HasErrors()) {
                    splitter.GetReport()->Dump(std::cout);
                    throw Standard_Failure("BOPAlgo_Splitter failed to perform operation.");
                }
                
                TopoDS_Shape splitShape = splitter.Shape();

                // --- NEW: Validate that the split actually happened ---
                TopExp_Explorer faceExpAfter(splitShape, TopAbs_FACE);
                int faceCountAfter = 0;
                for (; faceExpAfter.More(); faceExpAfter.Next()) faceCountAfter++;

                if (faceCountAfter <= faceCountBefore) {
                    throw Standard_Failure("BOPAlgo_Splitter completed without errors but failed to split the face. This can indicate a degenerate cutting wire or tolerance issues.");
                }
                AnalyzeShape(splitShape, "Split Shape AFTER BOPAlgo_Splitter");
                ShapeFix_Shape finalFixer(splitShape);
                finalFixer.Perform();
                TopoDS_Shape finalShape = finalFixer.Shape();
                AnalyzeShape(finalShape, "Final Shape AFTER ShapeFix_Shape");
                hostObject->set_shape(Urbaxio::CadKernel::OCCT_ShapeUniquePtr(new TopoDS_Shape(finalShape)));
                UpdateObjectBoundary(hostObject);
                hostObject->set_mesh_buffers(Urbaxio::CadKernel::TriangulateShape(*hostObject->get_shape()));
                hostObject->vao = 0;
                std::cout << "Scene: Object " << hostObject->get_id() << " was successfully split and updated." << std::endl;
            } catch (const Standard_Failure& e) {
                std::cerr << "OCCT Exception during parametric split: " << e.GetMessageString() << std::endl;
            }
        } else {
            // Fallback: This loop was not on an existing face. Create a new one.
            // This is the logic for creating faces from sketches in empty space.
            std::cout << "FindAndCreateFaces: Loop detected, but no suitable host face found. Creating a new independent face object." << std::endl;
            CreateOCCTFace(finalOrderedVertices, cyclePlane);
            lines_.at(newLineId).usedInFace = true;
            for (uint64_t lineId : pathLineIDsCollector) {
                lines_.at(lineId).usedInFace = true;
            }
        }
    }
    
    // --- HELPER FUNCTIONS ---
    std::vector<std::pair<glm::vec3, glm::vec3>> Scene::ExtractEdgesFromShape(const TopoDS_Shape& shape) {
        std::vector<std::pair<glm::vec3, glm::vec3>> edges;
        TopExp_Explorer explorer(shape, TopAbs_EDGE);
        for (; explorer.More(); explorer.Next()) {
            const TopoDS_Edge& edge = TopoDS::Edge(explorer.Current());
            TopoDS_Vertex v1, v2;
            TopExp::Vertices(edge, v1, v2);
            if (v1.IsNull() || v2.IsNull()) continue;
            gp_Pnt p1 = BRep_Tool::Pnt(v1);
            gp_Pnt p2 = BRep_Tool::Pnt(v2);
            edges.push_back({
                { (float)p1.X(), (float)p1.Y(), (float)p1.Z() },
                { (float)p2.X(), (float)p2.Y(), (float)p2.Z() }
            });
        }
        return edges;
    }

    void Scene::UpdateObjectBoundary(SceneObject* obj) {
        if (!obj || !obj->has_shape()) return;
        
        auto new_edges = ExtractEdgesFromShape(*obj->get_shape());
        std::set<uint64_t> new_boundary_line_ids;
        std::set<uint64_t> old_line_ids_to_check = obj->boundaryLineIDs;

        // Add/update lines from new edges
        for (const auto& edge : new_edges) {
            uint64_t line_id = AddSingleLineSegment(edge.first, edge.second);
            if (line_id != 0) {
                lines_[line_id].usedInFace = true;
                new_boundary_line_ids.insert(line_id);
                if(old_line_ids_to_check.count(line_id)) {
                    old_line_ids_to_check.erase(line_id);
                }
            }
        }

        for (uint64_t dead_line_id : old_line_ids_to_check) {
            RemoveLine(dead_line_id);
        }
        
        obj->boundaryLineIDs = new_boundary_line_ids;
    }
    


    // --- PUSH/PULL (MODIFIED) ---
    TopoDS_Face Scene::FindOriginalFace(const TopoDS_Shape& shape, const std::vector<glm::vec3>& faceVertices, const glm::vec3& guideNormal) {
        if (faceVertices.empty()) return TopoDS_Face();
        // --- NEW: Refactored logic with normal-based tie-breaking ---
        // Step 1: Find all candidate faces where all loop vertices lie on the face.
        std::vector<TopoDS_Face> candidates;
        TopExp_Explorer faceExplorer(shape, TopAbs_FACE);
        for (; faceExplorer.More(); faceExplorer.Next()) {
            TopoDS_Face candidateFace = TopoDS::Face(faceExplorer.Current());
            try {
                BRepAdaptor_Surface surfaceAdaptor(candidateFace, Standard_False);
                if(surfaceAdaptor.GetType() != GeomAbs_Plane) continue;
                bool allPointsOnFace = true;
                for(const auto& v : faceVertices) {
                    BRepClass_FaceClassifier classifier;
                    classifier.Perform(candidateFace, gp_Pnt(v.x, v.y, v.z), 1e-4); 
                    TopAbs_State state = classifier.State();
                    if(state != TopAbs_ON && state != TopAbs_IN) {
                        allPointsOnFace = false;
                        break;
                    }
                }
                if (allPointsOnFace) {
                    candidates.push_back(candidateFace);
                }
            } catch (const Standard_Failure&) {
                continue;
            }
        }
        // Step 2: Handle the results
        if (candidates.empty()) {
            return TopoDS_Face(); // No suitable face found
        }
        if (candidates.size() == 1) {
            return candidates[0]; // Only one candidate, return it
        }
        // Step 3: Multi-pass filtering to find the best match
        // Pass 1: Filter by normal alignment. Keep only the faces that are most parallel to the guide normal.
        std::vector<TopoDS_Face> alignedCandidates;
        double maxDotAbs = -1.0;
        gp_Dir targetDir(guideNormal.x, guideNormal.y, guideNormal.z);
        for (const auto& candidateFace : candidates) {
            try {
                BRepAdaptor_Surface surfaceAdaptor(candidateFace, Standard_True);
                gp_Pln plane = surfaceAdaptor.Plane();
                gp_Dir candidateDir = plane.Axis().Direction();
                if (candidateFace.Orientation() == TopAbs_REVERSED) candidateDir.Reverse();
                double dot = std::abs(targetDir.Dot(candidateDir));
                if (dot > maxDotAbs) {
                    maxDotAbs = dot;
                }
            } catch (const Standard_Failure&) { continue; }
        }
        const double NORMAL_ALIGNMENT_TOLERANCE = 1e-6;
        if (maxDotAbs > (1.0 - NORMAL_ALIGNMENT_TOLERANCE)) {
            for (const auto& candidateFace : candidates) {
                try {
                    BRepAdaptor_Surface surfaceAdaptor(candidateFace, Standard_True);
                    gp_Pln plane = surfaceAdaptor.Plane();
                    gp_Dir candidateDir = plane.Axis().Direction();
                    if (candidateFace.Orientation() == TopAbs_REVERSED) candidateDir.Reverse();
                    if (std::abs(targetDir.Dot(candidateDir)) >= (maxDotAbs - NORMAL_ALIGNMENT_TOLERANCE)) {
                        alignedCandidates.push_back(candidateFace);
                    }
                } catch (const Standard_Failure&) { continue; }
            }
        }
        if (alignedCandidates.size() == 1) {
            return alignedCandidates[0];
        }
        if (alignedCandidates.empty()) { // Should not happen if initial candidates were found, but as a fallback
            alignedCandidates = candidates;
        }
        // Pass 2: Tie-break using distance to center of mass.
        glm::vec3 targetCenter(0.0f);
        for(const auto& v : faceVertices) targetCenter += v;
        targetCenter /= (float)faceVertices.size();
        TopoDS_Face bestMatch;
        float minDistance = std::numeric_limits<float>::max();
        for (const auto& candidateFace : alignedCandidates) {
            try {
                GProp_GProps props;
                BRepGProp::SurfaceProperties(candidateFace, props);
                gp_Pnt center = props.CentreOfMass();
                float dist = (float)center.Distance(gp_Pnt(targetCenter.x, targetCenter.y, targetCenter.z));
                if (dist < minDistance) {
                    minDistance = dist;
                    bestMatch = candidateFace;
                }
            } catch (const Standard_Failure&) { continue; }
        }
        return bestMatch;
    }

    void Scene::AnalyzeShape(const TopoDS_Shape& shape, const std::string& label) {
        if (shape.IsNull()) {
             std::cout << "=== SHAPE ANALYSIS: " << label << " (SHAPE IS NULL) ===" << std::endl;
             return;
        }
        std::cout << "=== SHAPE ANALYSIS: " << label << " ===" << std::endl;
        
        // Basic info
        std::cout << "Shape Type: " << shape.ShapeType() << " (0=Compound, 1=CompSolid, 2=Solid, 3=Shell, 4=Face, 5=Wire, 6=Edge, 7=Vertex)" << std::endl;
        
        // Count components
        TopExp_Explorer solidExp(shape, TopAbs_SOLID);
        int solidCount = 0;
        for (; solidExp.More(); solidExp.Next()) solidCount++;
        
        TopExp_Explorer faceExp(shape, TopAbs_FACE);
        int faceCount = 0;
        for (; faceExp.More(); faceExp.Next()) faceCount++;
        
        std::cout << "Contains: " << solidCount << " solids, " << faceCount << " faces" << std::endl;
        
        // Bounding box
        try {
            Bnd_Box boundingBox;
            BRepBndLib::Add(shape, boundingBox);
            if (!boundingBox.IsVoid()) {
                Standard_Real xmin, ymin, zmin, xmax, ymax, zmax;
                boundingBox.Get(xmin, ymin, zmin, xmax, ymax, zmax);
                std::cout << "Bounding Box: (" << xmin << ", " << ymin << ", " << zmin << ") to (" 
                         << xmax << ", " << ymax << ", " << zmax << ")" << std::endl;
                std::cout << "Dimensions: " << (xmax-xmin) << " x " << (ymax-ymin) << " x " << (zmax-zmin) << std::endl;
            } else {
                std::cout << "Bounding Box: VOID" << std::endl;
            }
        } catch (const Standard_Failure& e) {
            std::cout << "Bounding Box: ERROR - " << e.GetMessageString() << std::endl;
        }
        
        // Volume/properties
        try {
            GProp_GProps props;
            BRepGProp::VolumeProperties(shape, props);
            Standard_Real volume = props.Mass();
            gp_Pnt center = props.CentreOfMass();
            std::cout << "Volume: " << volume << std::endl;
            std::cout << "Center of Mass: (" << center.X() << ", " << center.Y() << ", " << center.Z() << ")" << std::endl;
        } catch (const Standard_Failure& e) {
            std::cout << "Volume Properties: ERROR - " << e.GetMessageString() << std::endl;
        }
        
        // Validity
        try {
            BRepCheck_Analyzer analyzer(shape);
            std::cout << "Shape Valid: " << (analyzer.IsValid() ? "YES" : "NO") << std::endl;
        } catch (const Standard_Failure& e) {
            std::cout << "Validity Check: ERROR - " << e.GetMessageString() << std::endl;
        }
        
        std::cout << "=== END ANALYSIS ===" << std::endl << std::endl;
    }

    
    bool Scene::ExtrudeFace(uint64_t objectId, const std::vector<size_t>& faceTriangleIndices, const glm::vec3& direction, float distance, bool disableMerge) {
        SceneObject* obj = get_object_by_id(objectId);
        if (!obj || !obj->has_shape() || faceTriangleIndices.empty()) {
            return false;
        }

        const auto& mesh = obj->get_mesh_buffers();
        std::set<unsigned int> faceVertexIndicesSet;
        for (size_t baseIdx : faceTriangleIndices) {
            faceVertexIndicesSet.insert(mesh.indices[baseIdx]);
            faceVertexIndicesSet.insert(mesh.indices[baseIdx + 1]);
            faceVertexIndicesSet.insert(mesh.indices[baseIdx + 2]);
        }
        std::vector<glm::vec3> faceVertices;
        for (unsigned int idx : faceVertexIndicesSet) {
            faceVertices.push_back({mesh.vertices[idx * 3], mesh.vertices[idx * 3 + 1], mesh.vertices[idx * 3 + 2]});
        }
        
        return ExtrudeFace(objectId, faceVertices, direction, distance, disableMerge);
    }

    bool Scene::ExtrudeFace(uint64_t objectId, const std::vector<glm::vec3>& faceVertices, const glm::vec3& direction, float distance, bool disableMerge) {
        SceneObject* obj = get_object_by_id(objectId);
        if (!obj || !obj->has_shape() || faceVertices.empty()) {
            return false;
        }
        if (std::abs(distance) < 1e-4) {
            return true;
        }

        const TopoDS_Shape* originalShape = obj->get_shape();
        
        TopoDS_Face faceToExtrude = FindOriginalFace(*originalShape, faceVertices, direction);
        if (faceToExtrude.IsNull()) {
            std::cerr << "ExtrudeFace Error: Could not find corresponding B-Rep face." << std::endl;
            return false;
        }

        try {
            BRepAdaptor_Surface surfaceAdaptor(faceToExtrude, Standard_True);
            gp_Pln plane = surfaceAdaptor.Plane();
            gp_Dir occtFaceNormal = plane.Axis().Direction();
            
            if (faceToExtrude.Orientation() == TopAbs_REVERSED) {
                occtFaceNormal.Reverse();
            }

            gp_Dir userDirection(direction.x, direction.y, direction.z);
            float dotProductWithUserDir = occtFaceNormal.Dot(userDirection);

            gp_Vec extrudeVector(occtFaceNormal.XYZ());
            if (dotProductWithUserDir < 0) {
                extrudeVector.Reverse();
            }
            extrudeVector *= distance;
            
            BRepPrimAPI_MakePrism prismMaker(faceToExtrude, extrudeVector);
            
            if (!prismMaker.IsDone()) {
                std::cerr << "OCCT Error: Failed to create prism from face." << std::endl;
                return false;
            }
            TopoDS_Shape prismShape = prismMaker.Shape();
            
            TopoDS_Shape finalShape;
            
            bool is3DBody = (originalShape->ShapeType() == TopAbs_SOLID || originalShape->ShapeType() == TopAbs_COMPSOLID);
            if (!is3DBody && originalShape->ShapeType() == TopAbs_COMPOUND) {
                TopExp_Explorer ex(*originalShape, TopAbs_SOLID);
                if (ex.More()) is3DBody = true;
            }
            
            if (is3DBody) {
                double dotProduct = extrudeVector.Dot(gp_Vec(occtFaceNormal));
                if (dotProduct >= -1e-6) {
                    BRepAlgoAPI_Fuse fuseAlgo(*originalShape, prismShape);
                    if (!fuseAlgo.IsDone()) { std::cerr << "OCCT Error: BRepAlgoAPI_Fuse failed." << std::endl; return false; }
                    finalShape = fuseAlgo.Shape();
                } else {
                    BRepAlgoAPI_Cut cutAlgo(*originalShape, prismShape);
                    if (!cutAlgo.IsDone()) { std::cerr << "OCCT Error: BRepAlgoAPI_Cut failed." << std::endl; return false; }
                    finalShape = cutAlgo.Shape();
                }
            } else {
                finalShape = prismShape;
            }
            
            obj->set_shape(Urbaxio::CadKernel::OCCT_ShapeUniquePtr(new TopoDS_Shape(finalShape)));

            if (obj->has_shape()) {
                ShapeFix_Shape shapeFixer(*obj->get_shape());
                shapeFixer.Perform();
                TopoDS_Shape healedShape = shapeFixer.Shape();
                if (!disableMerge) {
                    ShapeUpgrade_UnifySameDomain Unifier;
                    Unifier.Initialize(healedShape);
                    Unifier.SetLinearTolerance(1e-4); 
                    Unifier.SetAngularTolerance(1e-4); 
                    Unifier.AllowInternalEdges(Standard_True);
                    Unifier.Build();
                    healedShape = Unifier.Shape();
                }
                obj->set_shape(Urbaxio::CadKernel::OCCT_ShapeUniquePtr(new TopoDS_Shape(healedShape)));
                UpdateObjectBoundary(obj);
                obj->set_mesh_buffers(Urbaxio::CadKernel::TriangulateShape(*obj->get_shape()));
                obj->vao = 0;
            }
        } catch (const Standard_Failure& e) {
            std::cerr << "OCCT Exception during ExtrudeFace: " << e.GetMessageString() << std::endl;
            return false;
        }
        return true;
    }

    // --- NEW: Testing Infrastructure ---
    
    void Scene::ClearScene() {
        // This clears the engine's state. The shell is responsible for cleaning up GPU resources.
        objects_.clear();
        next_object_id_ = 1;
        next_face_id_ = 1;
        
        lines_.clear();
        vertexAdjacency_.clear();
        next_line_id_ = 1;
        
        commandManager_->ClearHistory(); // <-- NEW

        std::cout << "Scene: Cleared all objects, lines and command history from engine state." << std::endl;
    }
    
    // Helper to create a simple rectangular face object for testing.
    SceneObject* Scene::CreateRectangularFace(
        const std::string& name,
        const gp_Pnt& p1, const gp_Pnt& p2, const gp_Pnt& p3, const gp_Pnt& p4)
    {
        try {
            TopoDS_Edge edge1 = BRepBuilderAPI_MakeEdge(p1, p2);
            TopoDS_Edge edge2 = BRepBuilderAPI_MakeEdge(p2, p3);
            TopoDS_Edge edge3 = BRepBuilderAPI_MakeEdge(p3, p4);
            TopoDS_Edge edge4 = BRepBuilderAPI_MakeEdge(p4, p1);

            BRepBuilderAPI_MakeWire wireMaker(edge1, edge2, edge3, edge4);
            if (!wireMaker.IsDone()) {
                std::cerr << "CreateRectangularFace Error: Failed to create wire." << std::endl;
                return nullptr;
            }
            TopoDS_Wire wire = wireMaker.Wire();
            BRepBuilderAPI_MakeFace faceMaker(wire, Standard_True);
            if (!faceMaker.IsDone() || faceMaker.Face().IsNull()) {
                std::cerr << "CreateRectangularFace Error: Failed to create face." << std::endl;
                return nullptr;
            }

            TopoDS_Face face = faceMaker.Face();
            SceneObject* new_face_obj = this->create_object(name);
            if (new_face_obj) {
                new_face_obj->set_shape(Urbaxio::CadKernel::OCCT_ShapeUniquePtr(new TopoDS_Shape(face)));
                UpdateObjectBoundary(new_face_obj);
                auto mesh_data = Urbaxio::CadKernel::TriangulateShape(*new_face_obj->get_shape());
                if (!mesh_data.isEmpty()) {
                    new_face_obj->set_mesh_buffers(std::move(mesh_data));
                    std::cout << "Scene: Created test face object: " << name << std::endl;
                }
                return new_face_obj;
            }
        } catch (const Standard_Failure& e) {
            std::cerr << "OCCT Exception in CreateRectangularFace: " << e.GetMessageString() << std::endl;
        }
        return nullptr;
    }
    
    void Scene::TestFaceSplitting() {
        std::cout << "\n\n--- RUNNING FACE SPLITTING TEST ---\n" << std::endl;
        ClearScene();

        // --- Test Setup: Create a large face to draw on ---
        gp_Pnt p1(0, 0, 0);
        gp_Pnt p2(100, 0, 0);
        gp_Pnt p3(100, 100, 0);
        gp_Pnt p4(0, 100, 0);
        
        SceneObject* testFace = CreateRectangularFace("TestFace_Base", p1, p2, p3, p4);
        if (!testFace) {
            std::cerr << "TEST SETUP FAILED: Could not create initial test face." << std::endl;
            return;
        }
        std::cout << "Initial face created. Object count: " << objects_.size() << ". Initial lines: " << lines_.size() << std::endl;

        std::cout << "\n--- SCENARIO: Drawing a 'П' shape on the face ---\n" << std::endl;
        
        // These are the points of the 'П' shape
        glm::vec3 vA(20.0f, 0.0f, 0.0f);   // Start on bottom edge
        glm::vec3 vB(20.0f, 50.0f, 0.0f);  // Go up
        glm::vec3 vC(80.0f, 50.0f, 0.0f);  // Go right
        glm::vec3 vD(80.0f, 0.0f, 0.0f);   // Go down to bottom edge

        // We simulate a user drawing three separate lines.
        // Each call to AddUserLine is a complete user action (click-drag-release or click-move-click).
        // The engine's internal logic should handle the intermediate splits and the final loop detection.
        
        std::cout << "Step 1: Drawing line from edge to inside (A->B)..." << std::endl;
        AddUserLine(vA, vB);
        std::cout << "  Objects after Step 1: " << objects_.size() << ". Lines: " << lines_.size() << std::endl;


        std::cout << "Step 2: Drawing line from point to point (B->C)..." << std::endl;
        AddUserLine(vB, vC);
        std::cout << "  Objects after Step 2: " << objects_.size() << ". Lines: " << lines_.size() << std::endl;


        std::cout << "Step 3: Drawing line from point to edge (C->D) to close the loop..." << std::endl;
        AddUserLine(vC, vD);
        std::cout << "  Objects after Step 3: " << objects_.size() << ". Lines: " << lines_.size() << std::endl;


        // --- FINAL VERIFICATION ---
        // After the three lines are drawn, a 'П' shape is formed. The bottom of the 'П'
        // is closed by the existing edge of the original face.
        // The expected outcome is that the original single face object is *replaced* by a new object containing two faces.
        // Therefore, the final number of objects in the scene should still be 1, but this object should have 2 faces.
        std::cout << "\n--- FINAL VERIFICATION ---" << std::endl;
        
        size_t finalObjectCount = objects_.size();
        bool testPassed = false;
        if (finalObjectCount == 1) {
            SceneObject* finalObj = get_all_objects()[0];
            TopExp_Explorer faceExp(*finalObj->get_shape(), TopAbs_FACE);
            int faceCount = 0;
            for (; faceExp.More(); faceExp.Next()) faceCount++;
            if (faceCount == 2) {
                testPassed = true;
            } else {
                 std::cout << "TEST FAILED: Final object has " << faceCount << " faces, but expected 2." << std::endl;
            }
        } else {
             std::cout << "TEST FAILED: Expected 1 final object, but found " << finalObjectCount << "." << std::endl;
        }

        if (testPassed) {
            std::cout << "TEST PASSED: Final object count is 1, and it contains 2 faces, as expected." << std::endl;
        } else {
            std::cout << "This likely indicates a failure in the parametric splitting logic or loop detection." << std::endl;
        }

        std::cout << "\n--- Final Object Analysis ---" << std::endl;
        for (const auto& [id, obj_ptr] : objects_) {
            AnalyzeShape(*obj_ptr->get_shape(), "Final Object " + std::to_string(id));
        }
        
        std::cout << "\n--- FACE SPLITTING TEST FINISHED ---\n" << std::endl;
    }

    SceneObject* Scene::FindObjectByFace(const std::vector<glm::vec3>& faceVertices) {
        if (faceVertices.empty()) return nullptr;
        
        for (auto* obj : get_all_objects()) {
            if (!obj || !obj->has_shape()) continue;
            TopoDS_Face foundFace = FindOriginalFace(*obj->get_shape(), faceVertices, glm::vec3(0,0,1));
            if (!foundFace.IsNull()) {
                return obj;
            }
        }
        return nullptr;
    }

} // namespace Urbaxio
ENCODINGUTF8ENCODINGUTF8--- File: engine/src/scene_object.cpp ---
ENCODINGUTF8#include "engine/scene_object.h"
#include <utility>
#include <iostream>
#include <TopoDS_Shape.hxx>

namespace Urbaxio::Engine {

    SceneObject::SceneObject(uint64_t id, std::string name)
        : id_(id), name_(std::move(name)), shape_(nullptr) {
    }

    SceneObject::~SceneObject() {}

    //                                    
    SceneObject::SceneObject(SceneObject&& other) noexcept
        : id_(other.id_),
        name_(std::move(other.name_)),
        shape_(std::move(other.shape_)),
        mesh_buffers_(std::move(other.mesh_buffers_)) // <---               
    {
        other.id_ = 0;
    }

    //                                               
    SceneObject& SceneObject::operator=(SceneObject&& other) noexcept {
        if (this != &other) {
            id_ = other.id_;
            name_ = std::move(other.name_);
            shape_ = std::move(other.shape_);
            mesh_buffers_ = std::move(other.mesh_buffers_); // <---               
            other.id_ = 0;
        }
        return *this;
    }

    uint64_t SceneObject::get_id() const { return id_; }
    const std::string& SceneObject::get_name() const { return name_; }
    void SceneObject::set_name(const std::string& name) { name_ = name; }

    // ---           BRep ---
    void SceneObject::set_shape(Urbaxio::CadKernel::OCCT_ShapeUniquePtr shape) { shape_ = std::move(shape); }
    const TopoDS_Shape* SceneObject::get_shape() const { return shape_.get(); }
    bool SceneObject::has_shape() const { return shape_ != nullptr; }

    // ---                ---
    void SceneObject::set_mesh_buffers(Urbaxio::CadKernel::MeshBuffers buffers) { // <---           
        mesh_buffers_ = std::move(buffers); //                                     
    }
    const Urbaxio::CadKernel::MeshBuffers& SceneObject::get_mesh_buffers() const { // <---           
        return mesh_buffers_;
    }
    bool SceneObject::has_mesh() const { // <---           
        return !mesh_buffers_.isEmpty();
    }

} // namespace Urbaxio::Engine
ENCODINGUTF8ENCODINGUTF8--- File: shell/CMakeLists.txt ---
ENCODINGUTF8# Set the project name
project(UrbaxioShell)

# Enable RC language for Windows resources
if(WIN32)
    enable_language(RC)
    set(RESOURCE_FILES "${CMAKE_SOURCE_DIR}/resources/urbaxio.rc")
else()
    set(RESOURCE_FILES "")
endif()

# Define the executable target FIRST
add_executable(Urbaxio
    main.cpp
    src/camera.cpp
    src/input_handler.cpp
    src/renderer.cpp
    src/snapping.cpp
    # Add tool source files
    src/tools/ToolManager.cpp
    src/tools/SelectTool.cpp
    src/tools/LineTool.cpp
    src/tools/PushPullTool.cpp
    # Add ImGui backend implementation files directly to the compilation
    "C:/vcpkg/buildtrees/imgui/src/v1.91.9-afb09617a6.clean/backends/imgui_impl_sdl2.cpp"
    "C:/vcpkg/buildtrees/imgui/src/v1.91.9-afb09617a6.clean/backends/imgui_impl_opengl3.cpp"
    # Add Windows resources
    ${RESOURCE_FILES}
)

# NOW specify include directories for the defined target "Urbaxio"
target_include_directories(Urbaxio PRIVATE
    include # Add the shell/include directory
    # Also include the backends path for its internal includes
    "C:/vcpkg/buildtrees/imgui/src/v1.91.9-afb09617a6.clean/backends"
)

# --- Find dependencies needed directly by shell ---
find_package(SDL2 CONFIG REQUIRED)
find_package(glad CONFIG REQUIRED)
find_package(OpenGL REQUIRED)
find_package(imgui CONFIG REQUIRED)

# --- Link the application with libraries ---
# The shell links against the engine, which provides OCCT and other core functionality
target_link_libraries(Urbaxio PRIVATE
    engine          # Our engine library
    cad_kernel      # Our CAD kernel wrapper. It brings OCCT libs with it.
    SDL2::SDL2main
    SDL2::SDL2
    glad::glad
    OpenGL::GL
    imgui::imgui
)

# --- Copy OpenCascade DLLs after build ---
# UPDATED to use the hardcoded path.
set(OCCT_HARDCODED_BIN_DIR "C:/vcpkg/installed/x64-windows/bin")
set(OCCT_HARDCODED_DEBUG_BIN_DIR "C:/vcpkg/installed/x64-windows/debug/bin")
add_custom_command(TARGET Urbaxio POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E echo "Copying OCCT DLLs for $<CONFIG>..."
    COMMAND $<$<CONFIG:Debug>:${CMAKE_COMMAND}> -E copy_directory_if_different "${OCCT_HARDCODED_DEBUG_BIN_DIR}/" "$<TARGET_FILE_DIR:Urbaxio>/"
    COMMAND $<$<CONFIG:Release>:${CMAKE_COMMAND}> -E copy_directory_if_different "${OCCT_HARDCODED_BIN_DIR}/" "$<TARGET_FILE_DIR:Urbaxio>/"
    COMMENT "Copying OpenCascade DLLs to executable directory..."
    VERBATIM
)
message(STATUS "Added post-build command to copy OCCT DLLs from hardcoded path.")

# --- Resources configuration ---
if(WIN32 AND RESOURCE_FILES)
    message(STATUS "Windows resources enabled. Logo will be embedded in executable.")
    message(STATUS "Resource file: ${RESOURCE_FILES}")
    # Set working directory for resource compiler to find the ICO file
    set_property(SOURCE ${RESOURCE_FILES} PROPERTY COMPILE_FLAGS "/I\"${CMAKE_SOURCE_DIR}/resources\"")
else()
    message(STATUS "No Windows resources configured.")
endif()

message(STATUS "Configuring Urbaxio executable...")
# --- Check found libraries (Corrected multi-line format) ---
if(TARGET SDL2::SDL2)
    message(STATUS "Found SDL2 library via vcpkg.")
endif()
if(TARGET SDL2::SDL2main)
    message(STATUS "Found SDL2main library via vcpkg.")
endif()
if(TARGET glad::glad)
    message(STATUS "Found glad library via vcpkg.")
endif()
if(TARGET OpenGL::GL)
    message(STATUS "Found OpenGL library.")
endif()
if(TARGET imgui::imgui)
    message(STATUS "Found Dear ImGui library via vcpkg.")
endif()
ENCODINGUTF8ENCODINGUTF8--- File: shell/main.cpp ---
ENCODINGUTF8// --- Includes ---
#include <engine/engine.h>
#include <engine/scene.h>
#include <engine/scene_object.h>
#include <cad_kernel/cad_kernel.h>
#include <tools/ToolManager.h> // <-- NEW

#include "camera.h"
#include "input_handler.h"
#include "renderer.h"

#include <SDL2/SDL.h>
#include <glad/glad.h>

#include <imgui.h>
#include <imgui_impl_sdl2.h>
#include <imgui_impl_opengl3.h>

#include <glm/glm.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtx/norm.hpp>

#include <fmt/core.h> // <-- FIX: Added missing include for fmt library

#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <algorithm>
#include <set>
#include <map>
#include <cstdint>

// --- NEW: OCCT includes for capsule generation (moved from engine) ---
#include <gp_Ax2.hxx>
#include <gp_Pnt.hxx>
#include <gp_Trsf.hxx>
#include <gp_Vec.hxx>
#include <BRepPrimAPI_MakeCylinder.hxx>
#include <BRepPrimAPI_MakeSphere.hxx>
#include <BRepAlgoAPI_Fuse.hxx>
#include <TopoDS_Shape.hxx>
#include <BRepBuilderAPI_Transform.hxx>

namespace { // Anonymous namespace for helpers

    // --- NEW: Capsule generation logic is now in the shell ---
    Urbaxio::CadKernel::MeshBuffers CreateCapsuleMesh(float radius, float height) {
        try {
            // --- FIX: Offset the cylinder's base down by half its height to center it ---
            gp_Pnt center(0.0, 0.0, -height / 2.0);
            gp_Dir z_dir(0, 0, 1);
            gp_Ax2 axis(center, z_dir);
            
            TopoDS_Shape cylinder = BRepPrimAPI_MakeCylinder(axis, radius, height);

            // Create a single sphere at the origin, to be moved
            TopoDS_Shape sphere = BRepPrimAPI_MakeSphere(gp_Pnt(0,0,0), radius);

            // Transformations to move the sphere to the ends of the cylinder body
            gp_Trsf top_trsf, bot_trsf;
            top_trsf.SetTranslation(gp_Vec(0, 0, height / 2.0));
            bot_trsf.SetTranslation(gp_Vec(0, 0, -height / 2.0));

            // Apply transformations
            TopoDS_Shape top_hemisphere = BRepBuilderAPI_Transform(sphere, top_trsf);
            TopoDS_Shape bot_hemisphere = BRepBuilderAPI_Transform(sphere, bot_trsf);
            
            // Fuse them
            BRepAlgoAPI_Fuse fuser(cylinder, top_hemisphere);
            fuser.Build();
            TopoDS_Shape result = fuser.Shape();
            
            BRepAlgoAPI_Fuse final_fuser(result, bot_hemisphere);
            final_fuser.Build();
            result = final_fuser.Shape();
            
            return Urbaxio::CadKernel::TriangulateShape(result);

        } catch(...) {
            std::cerr << "OCCT Exception during capsule creation!" << std::endl;
            return Urbaxio::CadKernel::MeshBuffers();
        }
    }

} // end anonymous namespace

// --- GPU Mesh Upload Helper ---
bool UploadMeshToGPU(Urbaxio::Engine::SceneObject& object) { /* ... */ const Urbaxio::CadKernel::MeshBuffers& mesh = object.get_mesh_buffers(); if (mesh.isEmpty() || mesh.normals.empty()) { if (mesh.normals.empty() && !mesh.vertices.empty()) { std::cerr << "UploadMeshToGPU: Mesh for object " << object.get_id() << " is missing normals!" << std::endl; } return false; } if (object.vao != 0) glDeleteVertexArrays(1, &object.vao); if (object.vbo_vertices != 0) glDeleteBuffers(1, &object.vbo_vertices); if (object.vbo_normals != 0) glDeleteBuffers(1, &object.vbo_normals); if (object.ebo != 0) glDeleteBuffers(1, &object.ebo); object.vao = object.vbo_vertices = object.vbo_normals = object.ebo = 0; object.index_count = 0; glGenVertexArrays(1, &object.vao); if (object.vao == 0) return false; glBindVertexArray(object.vao); glGenBuffers(1, &object.vbo_vertices); if (object.vbo_vertices == 0) { glDeleteVertexArrays(1, &object.vao); object.vao = 0; return false; } glBindBuffer(GL_ARRAY_BUFFER, object.vbo_vertices); glBufferData(GL_ARRAY_BUFFER, mesh.vertices.size() * sizeof(float), mesh.vertices.data(), GL_STATIC_DRAW); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); glGenBuffers(1, &object.vbo_normals); if (object.vbo_normals == 0) { glDeleteBuffers(1, &object.vbo_vertices); glDeleteVertexArrays(1, &object.vao); object.vao = object.vbo_vertices = 0; return false; } glBindBuffer(GL_ARRAY_BUFFER, object.vbo_normals); glBufferData(GL_ARRAY_BUFFER, mesh.normals.size() * sizeof(float), mesh.normals.data(), GL_STATIC_DRAW); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); glEnableVertexAttribArray(1); glGenBuffers(1, &object.ebo); if (object.ebo == 0) { glDeleteBuffers(1, &object.vbo_normals); glDeleteBuffers(1, &object.vbo_vertices); glDeleteVertexArrays(1, &object.vao); object.vao = object.vbo_vertices = object.vbo_normals = 0; return false; } glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, object.ebo); glBufferData(GL_ELEMENT_ARRAY_BUFFER, mesh.indices.size() * sizeof(unsigned int), mesh.indices.data(), GL_STATIC_DRAW); object.index_count = static_cast<GLsizei>(mesh.indices.size()); glBindVertexArray(0); glBindBuffer(GL_ARRAY_BUFFER, 0); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0); std::cout << "UploadMeshToGPU: Successfully uploaded mesh for object " << object.get_id() << std::endl; return true; }

int main(int argc, char* argv[]) {
    std::cout << "Shell: Starting Urbaxio Application..." << std::endl;
    // --- Initialization ---
    initialize_engine(); Urbaxio::Engine::Scene* scene_ptr = reinterpret_cast<Urbaxio::Engine::Scene*>(get_engine_scene()); if (!scene_ptr) return 1; if (SDL_Init(SDL_INIT_VIDEO) != 0) return 1; const char* glsl_version = "#version 330 core"; SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_DEBUG_FLAG); SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3); SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3); SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE); SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1); SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24); SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8); SDL_WindowFlags window_flags = (SDL_WindowFlags)(SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI | SDL_WINDOW_SHOWN); SDL_Window* window = SDL_CreateWindow("Urbaxio", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 1280, 720, window_flags); if (!window) { SDL_Quit(); return 1; } SDL_GLContext gl_context = SDL_GL_CreateContext(window); if (!gl_context) { SDL_DestroyWindow(window); SDL_Quit(); return 1; } SDL_GL_MakeCurrent(window, gl_context); SDL_GL_SetSwapInterval(1); if (!gladLoadGLLoader((GLADloadproc)SDL_GL_GetProcAddress)) { return 1; } std::cout << "Shell: OpenGL Initialized: V:" << glGetString(GL_VERSION) << std::endl; IMGUI_CHECKVERSION(); ImGui::CreateContext(); ImGuiIO& io = ImGui::GetIO(); io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard; ImGui::StyleColorsDark(); if (!ImGui_ImplSDL2_InitForOpenGL(window, gl_context)) return 1; if (!ImGui_ImplOpenGL3_Init(glsl_version)) return 1; std::cout << "Shell: All subsystems initialized." << std::endl;

    Urbaxio::Renderer renderer; if (!renderer.Initialize()) { return 1; }
    Urbaxio::Camera camera; Urbaxio::InputHandler inputHandler;
    Urbaxio::SnappingSystem snappingSystem;
    int object_counter = 0;
    
    // --- Appearance Settings ---
    ImVec4 clear_color = ImVec4(0.13f, 0.13f, 0.18f, 1.00f);
    glm::vec3 objectColor(0.8f, 0.85f, 0.9f);
    glm::vec3 lightColor = glm::vec3(0.618f, 0.858f, 0.844f);
    float ambientStrength = 0.267f;
    bool showGrid = true; bool showAxes = true;
    glm::vec3 gridColor(58.f / 255.f, 82.f / 255.f, 105.f / 255.f);
    glm::vec4 axisColorX(223.f / 255.f, 62.f / 255.f, 86.f / 255.f, 1.0f);
    glm::vec4 axisColorY(58.f / 255.f, 223.f / 255.f, 150.f / 255.f, 1.0f);
    glm::vec4 axisColorZ(63.f / 255.f, 56.f / 255.f, 184.f / 255.f, 1.0f);
    float axisLineWidth = 2.302f;
    glm::vec4 positiveAxisFadeColor(72.f / 255.f, 94.f / 255.f, 96.f / 255.f, 1.0f);
    float negAxisLineWidth = 1.698f;
    glm::vec4 negativeAxisFadeColor(50.f / 255.f, 81.f / 255.f, 86.f / 255.f, 102.f / 255.f);
    float cursorRadius = 15.0f;
    float effectIntensity = 0.8f;
    
    // --- Other Settings ---
    float maxLineWidth = renderer.GetMaxLineWidth();
    bool show_style_editor = false;

    // --- Core State Variables ---
    uint64_t selectedObjId = 0;
    std::vector<size_t> selectedTriangleIndices;
    std::set<uint64_t> selectedLineIDs;
    glm::vec3 selectionHighlightColor = glm::vec3(0.6f, 0.8f, 1.0f);

    uint64_t hoveredObjId = 0;
    std::vector<size_t> hoveredFaceTriangleIndices;
    glm::vec3 hoverHighlightColor = glm::vec3(0.4f, 0.9f, 1.0f); // Light cyan
    
    // --- Tool Manager Setup ---
    int display_w, display_h;
    SDL_GetWindowSize(window, &display_w, &display_h);

    Urbaxio::Tools::ToolContext toolContext;
    toolContext.scene = scene_ptr;
    toolContext.camera = &camera;
    toolContext.window = window;
    toolContext.display_w = &display_w;
    toolContext.display_h = &display_h;
    toolContext.selectedObjId = &selectedObjId;
    toolContext.selectedTriangleIndices = &selectedTriangleIndices;
    toolContext.selectedLineIDs = &selectedLineIDs;
    toolContext.hoveredObjId = &hoveredObjId;
    toolContext.hoveredFaceTriangleIndices = &hoveredFaceTriangleIndices;
    
    Urbaxio::Tools::ToolManager toolManager(toolContext);

    // --- NEW: Marker settings ---
    static float capsuleRadius = 0.5f;
    static float capsuleHeight10m = 3.2f;
    static float capsuleHeight5m = 1.4f;

    // --- NEW: Create shell-specific markers ---
    auto* capsule_marker_10m = scene_ptr->create_object("UnitCapsuleMarker10m");
    if (capsule_marker_10m) {
        Urbaxio::CadKernel::MeshBuffers mesh = CreateCapsuleMesh(capsuleRadius, capsuleHeight10m);
        capsule_marker_10m->set_mesh_buffers(std::move(mesh));
        fmt::print("Shell: Created 'UnitCapsuleMarker10m' template with ID {}.\n", capsule_marker_10m->get_id());
    } else {
        fmt::print(stderr, "Shell: Error creating 'UnitCapsuleMarker10m' template!\n");
    }
    
    auto* capsule_marker_5m = scene_ptr->create_object("UnitCapsuleMarker5m");
    if (capsule_marker_5m) {
        Urbaxio::CadKernel::MeshBuffers mesh = CreateCapsuleMesh(capsuleRadius, capsuleHeight5m);
        capsule_marker_5m->set_mesh_buffers(std::move(mesh));
        fmt::print("Shell: Created 'UnitCapsuleMarker5m' template with ID {}.\n", capsule_marker_5m->get_id());
    } else {
        fmt::print(stderr, "Shell: Error creating 'UnitCapsuleMarker5m' template!\n");
    }

    bool should_quit = false; std::cout << "Shell: >>> Entering main loop..." << std::endl;
    while (!should_quit) {
        SDL_GetWindowSize(window, &display_w, &display_h);
        
        // --- Find Snap Point for current frame ---
        int mouseX, mouseY;
        SDL_GetMouseState(&mouseX, &mouseY);
        Urbaxio::SnapResult currentSnap;
        if (toolManager.ShouldEnableSnapping()) {
            currentSnap = snappingSystem.FindSnapPoint(mouseX, mouseY, display_w, display_h, camera, *scene_ptr);
        } else {
            // Create empty snap result when snapping is disabled
            currentSnap = {};
            currentSnap.snapped = false;
        }
        
        // --- Process Input ---
        inputHandler.ProcessEvents(camera, should_quit, window, toolManager, scene_ptr);

        // --- Update Active Tool ---
        toolManager.OnUpdate(currentSnap);
        
        // --- GPU Upload for new objects ---
        if (scene_ptr) {
            std::vector<Urbaxio::Engine::SceneObject*> all_objects = scene_ptr->get_all_objects();
            for (Urbaxio::Engine::SceneObject* obj : all_objects) {
                if (obj && obj->has_mesh() && obj->vao == 0) { // Has mesh, but not yet on GPU
                    if (!UploadMeshToGPU(*obj)) {
                        std::cerr << "Shell: Main loop failed to upload mesh for object " << obj->get_id() << std::endl;
                    }
                }
            }
        }
        renderer.UpdateUserLinesBuffer(scene_ptr->GetAllLines(), selectedLineIDs);


        // --- Get cursor world position for shaders ---
        glm::vec3 cursorWorldPos = currentSnap.snapped
            ? currentSnap.worldPoint
            : inputHandler.GetCursorPointInWorld(camera, mouseX, mouseY, display_w, display_h, glm::vec3(0.0f));

        ImGui_ImplOpenGL3_NewFrame(); ImGui_ImplSDL2_NewFrame(); ImGui::NewFrame();

        // --- Main Controls Window ---
        { 
            ImGui::Begin("Urbaxio Controls");
            ImGui::Text("App avg %.3f ms/f (%.1f FPS)", 1000.0f / io.Framerate, io.Framerate);
            ImGui::Separator();
            if (ImGui::Button("Create Box Object")) { object_counter++; std::string box_name = "Box_" + std::to_string(object_counter); Urbaxio::Engine::SceneObject* new_box = scene_ptr->create_box_object(box_name, 10.0, 20.0, 5.0); if (new_box && new_box->has_mesh()) { /* GPU upload handled by main loop now */ } else { if (!new_box) { std::cerr << "Shell: Failed to create SceneObject for '" << box_name << "'." << std::endl; } else { std::cerr << "Shell: Failed to triangulate or mesh is empty for '" << box_name << "'." << std::endl; } } }
            ImGui::Separator();
            
            if (ImGui::Button("Appearance Settings")) show_style_editor = true;
            
            ImGui::Separator();
            ImGui::Text("Tools:");
            Urbaxio::Tools::ToolType activeToolType = toolManager.GetActiveToolType();

            bool isSelect = activeToolType == Urbaxio::Tools::ToolType::Select;
            if (ImGui::RadioButton("Select", isSelect)) toolManager.SetTool(Urbaxio::Tools::ToolType::Select);
            ImGui::SameLine();
            bool isLine = activeToolType == Urbaxio::Tools::ToolType::Line;
            if (ImGui::RadioButton("Line", isLine)) toolManager.SetTool(Urbaxio::Tools::ToolType::Line);
            ImGui::SameLine();
            bool isPushPull = activeToolType == Urbaxio::Tools::ToolType::PushPull;
            if (ImGui::RadioButton("Push/Pull", isPushPull)) toolManager.SetTool(Urbaxio::Tools::ToolType::PushPull);

            if (ImGui::Button("Clear Lines") && scene_ptr) { 
                scene_ptr->ClearUserLines(); 
                selectedLineIDs.clear();
                toolManager.SetTool(Urbaxio::Tools::ToolType::Line); // Reactivate to reset state
            }
            ImGui::SameLine();
            if (ImGui::Button("Run Split Test")) {
                // 1. Clean up GPU resources for existing objects
                if (scene_ptr) {
                    std::vector<Urbaxio::Engine::SceneObject*> objects_to_clean = scene_ptr->get_all_objects();
                    for (auto* obj : objects_to_clean) {
                        if (obj) {
                             if (obj->vao != 0) { glDeleteVertexArrays(1, &obj->vao); obj->vao = 0; }
                             if (obj->vbo_vertices != 0) { glDeleteBuffers(1, &obj->vbo_vertices); obj->vbo_vertices = 0; }
                             if (obj->vbo_normals != 0) { glDeleteBuffers(1, &obj->vbo_normals); obj->vbo_normals = 0; }
                             if (obj->ebo != 0) { glDeleteBuffers(1, &obj->ebo); obj->ebo = 0; }
                        }
                    }
                    // 2. Clear the scene logic and run the test
                    scene_ptr->TestFaceSplitting(); 
                }
            }
            
            // --- Tool-specific UI ---
            toolManager.RenderUI();

            ImGui::Text("Scene Info:");
            ImGui::Text("Lines in Scene: %zu", scene_ptr ? scene_ptr->GetAllLines().size() : 0);
            ImGui::Text("Selected Object ID: %llu", selectedObjId);
            if (selectedObjId != 0) ImGui::Text("Selected Triangles: %zu", selectedTriangleIndices.size());
            if (!selectedLineIDs.empty()) ImGui::Text("Selected Line IDs: %zu", selectedLineIDs.size());

            const char* snapTypeName = "None"; if (currentSnap.snapped) { switch (currentSnap.type) { case Urbaxio::SnapType::ENDPOINT: snapTypeName = "Endpoint"; break; case Urbaxio::SnapType::ORIGIN:   snapTypeName = "Origin"; break; case Urbaxio::SnapType::AXIS_X:   snapTypeName = "On Axis X"; break; case Urbaxio::SnapType::AXIS_Y:   snapTypeName = "On Axis Y"; break; case Urbaxio::SnapType::AXIS_Z:   snapTypeName = "On Axis Z"; break; default: snapTypeName = "Unknown"; break; } } ImGui::Text("Current Snap: %s (%.2f, %.2f, %.2f)", snapTypeName, currentSnap.worldPoint.x, currentSnap.worldPoint.y, currentSnap.worldPoint.z);
            ImGui::Text("Scene Objects:"); if (scene_ptr) { std::vector<Urbaxio::Engine::SceneObject*> objects = scene_ptr->get_all_objects(); if (objects.empty()) { ImGui::TextDisabled("(No objects yet)"); } else { ImGui::BeginChild("ObjectList", ImVec2(0, 100), true, ImGuiWindowFlags_HorizontalScrollbar); for (const auto* obj : objects) { if (obj) { ImGui::BulletText("%s (ID:%llu)%s%s%s", obj->get_name().c_str(), obj->get_id(), obj->has_shape() ? " [Geo]" : "", obj->has_mesh() ? " [Mesh]" : "", (obj->vao != 0) ? " [GPU]" : ""); } } ImGui::EndChild(); } } else { ImGui::TextDisabled("(Scene pointer is null)"); }
            ImGui::End();
        }

        // --- Appearance Settings Window ---
        if (show_style_editor) {
            ImGui::Begin("Appearance Settings", &show_style_editor);
            if (ImGui::CollapsingHeader("Scene Colors")) { ImGui::ColorEdit3("Background", (float*)&clear_color); ImGui::ColorEdit3("Default Object", (float*)&objectColor); }
            if (ImGui::CollapsingHeader("Lighting")) { 
                ImGui::TextDisabled("Light follows camera direction (headlamp mode)");
                ImGui::SliderFloat("Ambient Strength", &ambientStrength, 0.0f, 1.0f); 
                ImGui::ColorEdit3("Light Color", glm::value_ptr(lightColor)); 
            }
            if (ImGui::CollapsingHeader("Grid & Axes")) { ImGui::Checkbox("Show Grid", &showGrid); ImGui::SameLine(); ImGui::Checkbox("Show Axes", &showAxes); ImGui::ColorEdit3("Grid Color", glm::value_ptr(gridColor)); ImGui::SeparatorText("Positive Axes"); ImGui::ColorEdit4("Axis X Color", glm::value_ptr(axisColorX)); ImGui::ColorEdit4("Axis Y Color", glm::value_ptr(axisColorY)); ImGui::ColorEdit4("Axis Z Color", glm::value_ptr(axisColorZ)); ImGui::ColorEdit4("Fade To Color##Positive", glm::value_ptr(positiveAxisFadeColor)); ImGui::SameLine(); ImGui::TextDisabled("(also used for axis markers)"); ImGui::SliderFloat("Width##Positive", &axisLineWidth, 1.0f, maxLineWidth); ImGui::SeparatorText("Negative Axes"); ImGui::ColorEdit4("Fade To Color##Negative", glm::value_ptr(negativeAxisFadeColor)); ImGui::SliderFloat("Width##Negative", &negAxisLineWidth, 1.0f, maxLineWidth); }
            if (ImGui::CollapsingHeader("Interactive Effects")) { ImGui::SliderFloat("Cursor Radius", &cursorRadius, 1.0f, 50.0f); ImGui::SliderFloat("Effect Intensity", &effectIntensity, 0.1f, 2.0f); }
            
            if (ImGui::CollapsingHeader("Markers")) {
                bool radius_changed = ImGui::SliderFloat("Capsule Radius", &capsuleRadius, 0.1f, 2.0f);
                bool height10m_changed = ImGui::SliderFloat("10m Capsule Height", &capsuleHeight10m, 0.2f, 5.0f);
                bool height5m_changed = ImGui::SliderFloat("5m Capsule Height", &capsuleHeight5m, 0.2f, 5.0f);

                if (radius_changed || height10m_changed) {
                    Urbaxio::Engine::SceneObject* marker = scene_ptr->get_object_by_id(capsule_marker_10m->get_id());
                    if (marker) {
                        Urbaxio::CadKernel::MeshBuffers new_mesh = CreateCapsuleMesh(capsuleRadius, capsuleHeight10m);
                        marker->set_mesh_buffers(std::move(new_mesh));
                        marker->vao = 0; // Invalidate GPU resource to trigger re-upload
                    }
                }
                if (radius_changed || height5m_changed) {
                    Urbaxio::Engine::SceneObject* marker = scene_ptr->get_object_by_id(capsule_marker_5m->get_id());
                     if (marker) {
                        Urbaxio::CadKernel::MeshBuffers new_mesh = CreateCapsuleMesh(capsuleRadius, capsuleHeight5m);
                        marker->set_mesh_buffers(std::move(new_mesh));
                        marker->vao = 0; // Invalidate GPU resource to trigger re-upload
                    }
                }
            }
            ImGui::End();
        }

        ImGui::Render();
        renderer.SetViewport(0, 0, display_w, display_h);
        glClearColor(clear_color.x * clear_color.w, clear_color.y * clear_color.w, clear_color.z * clear_color.w, clear_color.w);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        // --- Let the tool render its preview geometry ---
        toolManager.RenderPreview(renderer, currentSnap);
        
        // --- Render the main frame ---
        renderer.RenderFrame(window, camera, scene_ptr, objectColor, lightColor, ambientStrength, 
            showGrid, showAxes, axisLineWidth, negAxisLineWidth,
            gridColor, axisColorX, axisColorY, axisColorZ, positiveAxisFadeColor, negativeAxisFadeColor,
            cursorWorldPos, cursorRadius, effectIntensity, 
            selectedObjId, selectedTriangleIndices, selectedLineIDs, selectionHighlightColor, 
            hoveredObjId, hoveredFaceTriangleIndices, hoverHighlightColor,
            currentSnap, 
            ImGui::GetDrawData());
        SDL_GL_SwapWindow(window);
    }

    std::cout << "Shell: <<< Exiting main loop." << std::endl;
    std::cout << "Shell: Cleaning up..." << std::endl; /* ... Cleanup ... */ if (scene_ptr) { std::vector<Urbaxio::Engine::SceneObject*> objects_to_clean = scene_ptr->get_all_objects(); for (auto* obj : objects_to_clean) { if (obj && obj->vao != 0) glDeleteVertexArrays(1, &obj->vao); if (obj && obj->vbo_vertices != 0) glDeleteBuffers(1, &obj->vbo_vertices); if (obj && obj->vbo_normals != 0) glDeleteBuffers(1, &obj->vbo_normals); if (obj && obj->ebo != 0) glDeleteBuffers(1, &obj->ebo); } } ImGui_ImplOpenGL3_Shutdown(); ImGui_ImplSDL2_Shutdown(); ImGui::DestroyContext(); SDL_GL_DeleteContext(gl_context); SDL_DestroyWindow(window); SDL_Quit(); std::cout << "Shell: Urbaxio Application finished gracefully." << std::endl; return 0;
}
ENCODINGUTF8ENCODINGUTF8--- File: shell/include/camera.h ---
ENCODINGUTF8#pragma once

#define GLM_ENABLE_EXPERIMENTAL
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/constants.hpp> // For glm::pi
#include <glm/gtc/quaternion.hpp> // Optional: For more advanced rotations later

namespace Urbaxio {
    // FORWARD DECLARATION: Tell the compiler that the Scene class exists without including the full header.
    namespace Engine { class Scene; }

    // Represents the 3D camera and handles its movement logic.
    class Camera {
    public:
        // Camera Attributes
        glm::vec3 Position;
        glm::vec3 Front;
        glm::vec3 Up;
        glm::vec3 Right;
        glm::vec3 WorldUp;

        // Euler Angles (for orbit calculation)
        float Yaw;   // Angle in the XY plane (around WorldUp)
        float Pitch; // Angle relative to the XY plane

        // Orbit Target
        glm::vec3 Target;
        float Radius; // Distance from Position to Target

        // Camera options
        float MovementSpeed; // Base speed for panning adjusted by radius
        float MouseSensitivity; // Speed for orbit rotation
        float ZoomSensitivity;  // Speed for zooming
        float FovDegrees;       // Field of View in degrees
        float NearPlane;
        float FarPlane;

        // Constructor with vectors
        Camera(glm::vec3 position = glm::vec3(40.0f, 30.0f, 30.0f),
            glm::vec3 target = glm::vec3(0.0f, 0.0f, 0.0f),
            glm::vec3 worldUp = glm::vec3(0.0f, 0.0f, 1.0f), // Z is up
            float fov = 45.0f,
            float orbitSpeed = 0.005f,
            float panSpeed = 0.05f,
            float zoomSpeed = 1.0f);

        // Returns the view matrix calculated using the LookAt method
        glm::mat4 GetViewMatrix() const;

        // Returns the projection matrix
        glm::mat4 GetProjectionMatrix(float aspectRatio) const;

        // Processes input received from mouse movement for orbiting
        void ProcessOrbit(float xoffset, float yoffset);

        // Processes input received from mouse movement for panning
        void ProcessPan(float xoffset, float yoffset, int mouseX, int mouseY, int screenWidth, int screenHeight, const Engine::Scene& scene);

        // Processes input for orbital zoom (zooming towards the target)
        void ProcessOrbitZoom(float yoffset);

        // NEW: Processes input for dolly zoom (zooming towards the mouse cursor)
        void ProcessDollyZoom(float yoffset, int mouseX, int mouseY, int screenWidth, int screenHeight, const Engine::Scene& scene);

        // NEW: Sets a new pivot point for orbiting and re-calculates orbital parameters
        void SetOrbitTarget(const glm::vec3& hitPoint);

        // --- Picking Ray Function ---
        // Calculates a world space ray from screen coordinates
        static void ScreenToWorldRay(
            int mouseX, int mouseY,
            int screenWidth, int screenHeight,
            const glm::mat4& viewMatrix,
            const glm::mat4& projectionMatrix,
            glm::vec3& outRayOrigin,
            glm::vec3& outRayDirection
        );


    private:
        // Calculates the front vector from the Camera's (updated) Euler Angles
        void updateCameraVectors();
        // Updates the camera position based on the current Yaw, Pitch, Radius, and Target
        void updateCameraPositionFromOrbit();
    };

} // namespace Urbaxio
ENCODINGUTF8ENCODINGUTF8--- File: shell/include/input_handler.h ---
ENCODINGUTF8#pragma once

#include <SDL2/SDL_events.h>
#include <SDL2/SDL_video.h>
#include <glm/glm.hpp>
#include <engine/scene.h> // <-- FIX: Include the full definition instead of forward declaring

// Forward declarations
namespace Urbaxio { 
    class Camera;
    // namespace Urbaxio::Engine { class Scene; } // No longer needed
    namespace Tools { class ToolManager; }
}

namespace Urbaxio {

    class InputHandler {
    public:
        InputHandler();

        void ProcessEvents(
            // Core systems
            Urbaxio::Camera& camera,
            bool& should_quit,
            SDL_Window* window,
            // The tool manager to forward events to
            Tools::ToolManager& toolManager,
            // Scene for global actions like Undo/Redo
            Urbaxio::Engine::Scene* scene
        );
        
        // This function is useful for getting a fallback cursor position
        glm::vec3 GetCursorPointInWorld(const Camera& camera, int mouseX, int mouseY, int screenWidth, int screenHeight, const glm::vec3& fallbackPlanePoint);

    private:
        // Input states
        bool middleMouseButtonDown;
        bool shiftDown;
        bool ctrlDown;
        int lastMouseX;
        int lastMouseY;
        bool isMouseFocused;
        bool firstMouse;

        // Helpers
        void HandleMouseMotion(Urbaxio::Camera& camera, SDL_Window* window, int display_w, int display_h, const Urbaxio::Engine::Scene& scene);
    };

} // namespace Urbaxio
ENCODINGUTF8ENCODINGUTF8--- File: shell/include/renderer.h ---
ENCODINGUTF8#pragma once

#include "snapping.h"
#include <engine/line.h> // <--- ADDED: Fix for unknown type 'Line'
#include <glad/glad.h>
#include <glm/glm.hpp>
#include <vector>
#include <string>
#include <SDL2/SDL_video.h>
#include <cstdint>
#include <cstddef>
#include <map>
#include <utility> // For std::pair
#include <set>     // <--- ADDED: Fix for 'std::set' is not a member of 'std'

namespace Urbaxio { class Camera; namespace Engine { class SceneObject; class Scene; } }
struct ImDrawData;

namespace Urbaxio {

    enum class MarkerShape { CIRCLE, DIAMOND };

    class Renderer {
    public:
        Renderer();
        ~Renderer();
        bool Initialize();
            void RenderFrame(
        SDL_Window* window,
        const Urbaxio::Camera& camera,
        Urbaxio::Engine::Scene* scene,
        // Appearance
        const glm::vec3& defaultObjectColor,
        const glm::vec3& lightColor, float ambientStrength,
        bool showGrid, bool showAxes, float axisLineWidth, float negAxisLineWidth,
        const glm::vec3& gridColor, const glm::vec4& axisColorX, const glm::vec4& axisColorY, const glm::vec4& axisColorZ,
        const glm::vec4& positiveAxisFadeColor, const glm::vec4& negativeAxisFadeColor,
        // Interactive Effects
        const glm::vec3& cursorWorldPos, float cursorRadius, float intensity,
        // Selections
        uint64_t selectedObjId,
        const std::vector<size_t>& selectedTriangleIndices,
        const std::set<uint64_t>& selectedLineIDs,
        const glm::vec3& selectionHighlightColor,
        // Hovers
        uint64_t hoveredObjId,
        const std::vector<size_t>& hoveredFaceTriangleIndices,
        const glm::vec3& hoverHighlightColor,
        // Tools
        const SnapResult& currentSnap,
        ImDrawData* imguiDrawData
    );
        void SetViewport(int x, int y, int width, int height);
        float GetMaxLineWidth() const { return maxLineWidth; }

        // Buffer updaters for tools and scene state
        void UpdateUserLinesBuffer(const std::map<uint64_t, Engine::Line>& lines, const std::set<uint64_t>& selectedLineIDs);
        void UpdatePreviewLine(const glm::vec3& start, const glm::vec3& end, bool enabled = true);
        void UpdatePushPullPreview(const Engine::SceneObject& object, const std::vector<size_t>& faceIndices, const glm::vec3& direction, float distance);
        void UpdateAxesVBO(const glm::vec4& colorX, const glm::vec4& colorY, const glm::vec4& colorZ, const glm::vec4& posFadeColor, const glm::vec4& negFadeColor);

    private:
        GLuint objectShaderProgram = 0;
        // --- NEW SHADERS ---
        GLuint gridShaderProgram = 0;
        GLuint axisShaderProgram = 0;
        // --- OLD SHADER (renamed for clarity, used for user lines and rubber band) ---
        GLuint simpleLineShaderProgram = 0; 
        GLuint unlitShaderProgram = 0; // <-- NEW SHADER for unlit objects
        GLuint dashedLineShaderProgram = 0; // <-- NEW SHADER for dashed lines
        
        GLuint splatShaderProgram = 0;
        GLuint markerShaderProgram = 0;

        GLuint gridVAO = 0, gridVBO = 0; int gridVertexCount = 0;
        
        // --- MODIFIED for AXES ---
        GLuint axesVAO = 0, axesVBO = 0;
        int axisVertexCountX = 0;
        int axisVertexCountY = 0;
        int axisVertexCountZ = 0;

        GLuint splatVAO = 0, splatVBO = 0, splatEBO = 0;
        GLuint userLinesVAO = 0, userLinesVBO = 0; int userLinesVertexCount = 0;
        
        // --- Preview Resources ---
        GLuint previewVAO = 0, previewVBO = 0; GLsizei previewVertexCount = 0;
        GLuint previewLineVAO = 0, previewLineVBO = 0; bool previewLineEnabled = false;
        GLuint previewOutlineVAO = 0, previewOutlineVBO = 0; GLsizei previewOutlineVertexCount = 0; // <-- NEW for dashed outline

        std::map<MarkerShape, GLuint> markerVAOs;
        std::map<MarkerShape, GLuint> markerVBOs;
        std::map<MarkerShape, int> markerVertexCounts;

        float markerScreenSize = 12.0f;
        float markerScreenSizeMidpoint = 10.0f;
        float markerScreenSizeOnEdge = 10.0f;
        glm::vec4 snapMarkerColorPoint = glm::vec4(1.0f, 0.6f, 0.0f, 0.9f);
        glm::vec4 snapMarkerColorMidpoint = glm::vec4(0.5f, 0.8f, 1.0f, 0.9f);
        glm::vec4 snapMarkerColorOnEdge = glm::vec4(1.0f, 0.0f, 1.0f, 0.9f);
        glm::vec4 snapMarkerColorOnFace = glm::vec4(0.2f, 1.0f, 0.8f, 0.7f);
        glm::vec4 snapMarkerColorAxisX = glm::vec4(1.0f, 0.3f, 0.3f, 0.9f);
        glm::vec4 snapMarkerColorAxisY = glm::vec4(0.3f, 1.0f, 0.3f, 0.9f);
        glm::vec4 snapMarkerColorAxisZ = glm::vec4(0.4f, 0.4f, 1.0f, 0.9f);

        glm::vec3 gridColor = glm::vec3(0.4f, 0.5f, 0.6f);
        float gridSizeF = 500.0f; int gridSteps = 500; int gridAccentStep = 10;
        float axisLength = 1000.0f;
        glm::vec3 splatPosStatic = glm::vec3(5.0f, 5.0f, 1.0f);
        glm::vec3 splatPosBillboard = glm::vec3(-5.0f, 5.0f, 1.0f);
        glm::vec4 splatColor = glm::vec4(0.8f, 0.4f, 0.8f, 0.5f);
        float splatBlurStrength = 8.0f;
        float maxLineWidth = 1.0f;
        glm::vec4 userLineColor = glm::vec4(1.0f, 1.0f, 1.0f, 1.0f);
        glm::vec4 selectedUserLineColor = glm::vec4(1.0f, 0.65f, 0.0f, 1.0f);

        bool CreateShaderPrograms();
        bool CreateGridResources();
        bool CreateAxesResources();
        bool CreateSplatResources();
        bool CreateUserLinesResources();
        bool CreateMarkerResources();
        bool CreatePreviewResources();
        bool CreatePreviewLineResources();
        bool CreatePreviewOutlineResources(); // <-- NEW
        void Cleanup();
        void DrawSnapMarker(const SnapResult& snap, const Camera& camera, const glm::mat4& view, const glm::mat4& proj, int screenWidth, int screenHeight);

        const char* objectVertexShaderSource; const char* objectFragmentShaderSource;
        const char* simpleLineVertexShaderSource; const char* simpleLineFragmentShaderSource;
        const char* gridVertexShaderSource; const char* gridFragmentShaderSource;
        const char* axisVertexShaderSource; const char* axisFragmentShaderSource;
        const char* unlitVertexShaderSource; const char* unlitFragmentShaderSource; // <-- NEW
        const char* splatVertexShaderSource; const char* splatFragmentShaderSource;
        const char* markerVertexShaderSource; const char* markerFragmentShaderSource;
        const char* dashedLineVertexShaderSource; const char* dashedLineFragmentShaderSource; // <-- NEW
    };
}
ENCODINGUTF8ENCODINGUTF8--- File: shell/include/snapping.h ---
ENCODINGUTF8#pragma once

#include <glm/glm.hpp>
#include <vector>
#include <cstdint>
#include <glm/mat4x4.hpp>

namespace Urbaxio { class Camera; namespace Engine { class Scene; class SceneObject; } } // Added SceneObject

namespace Urbaxio {

    enum class SnapType {
        NONE,
        ENDPOINT,
        MIDPOINT,
        ON_EDGE,
        ON_FACE, // <<< NEW
        INTERSECTION,
        CENTER,
        ORIGIN,
        GRID,
        AXIS_X,
        AXIS_Y,
        AXIS_Z,
        PARALLEL,
        PERPENDICULAR
    };

    struct SnapResult {
        bool snapped = false;
        glm::vec3 worldPoint = glm::vec3(0.0f);
        SnapType type = SnapType::NONE;
        uint64_t snappedEntityId = 0; // The ID of the line or object snapped to
    };

    class SnappingSystem {
    public:
        SnappingSystem();

        SnapResult FindSnapPoint(
            int mouseX, int mouseY, int screenWidth, int screenHeight,
            const Camera& camera, const Engine::Scene& scene,
            float snapThresholdPixels = 10.0f
        );

        // --- Static Helper Functions ---
        static bool WorldToScreen(
            const glm::vec3& worldPos,
            const glm::mat4& viewMatrix,
            const glm::mat4& projectionMatrix,
            int screenWidth, int screenHeight,
            glm::vec2& outScreenPos
        );

        static bool RaycastToZPlane(
            int mouseX, int mouseY,
            int screenWidth, int screenHeight,
            const Camera& camera,
            glm::vec3& outIntersectionPoint
        );

        // <<< NEW: Moved RayTriangleIntersect here >>>
        static bool RayTriangleIntersect(
            const glm::vec3& rayOrigin, const glm::vec3& rayDirection,
            const glm::vec3& v0, const glm::vec3& v1, const glm::vec3& v2,
            float& t_intersection // Output: distance along ray to intersection point
        );
    };

} // namespace Urbaxio
ENCODINGUTF8ENCODINGUTF8--- File: shell/src/camera.cpp ---
ENCODINGUTF8#include "camera.h"
#include "snapping.h"
#include "engine/scene.h"
#include "engine/scene_object.h"
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtx/vector_angle.hpp>
#include <glm/gtc/quaternion.hpp>
#include <glm/gtc/constants.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/common.hpp>
#include <cmath>
#include <iostream>
#include <limits>

namespace Urbaxio {

    Camera::Camera(glm::vec3 position, glm::vec3 target, glm::vec3 worldUp, float fov, float orbitSpeed, float panSpeed, float zoomSpeed)
        : Position(position), Target(target), WorldUp(worldUp), FovDegrees(fov), MouseSensitivity(orbitSpeed), MovementSpeed(panSpeed), ZoomSensitivity(zoomSpeed), NearPlane(0.1f), FarPlane(1000.0f)
    {
        glm::vec3 radiusVec = Position - Target; Radius = glm::length(radiusVec);
        if (Radius < 1e-6f) { Radius = 1.0f; Position = Target + glm::vec3(0, -Radius, 0); radiusVec = Position - Target; }
        float pitch_arg = radiusVec.z / Radius; Pitch = glm::asin(glm::clamp(pitch_arg, -1.0f, 1.0f)); Yaw = glm::atan(radiusVec.y, radiusVec.x);
        updateCameraVectors();
    }

    glm::mat4 Camera::GetViewMatrix() const { return glm::lookAt(Position, Target, Up); }
    glm::mat4 Camera::GetProjectionMatrix(float aspectRatio) const { if (aspectRatio <= 0.0f) return glm::mat4(1.0f); return glm::perspective(glm::radians(FovDegrees), aspectRatio, NearPlane, FarPlane); }
    void Camera::ProcessOrbit(float xoffset, float yoffset) { Yaw -= xoffset * MouseSensitivity; Pitch += yoffset * MouseSensitivity; Yaw = fmod(Yaw, 2.0f * glm::pi<float>()); updateCameraPositionFromOrbit(); }
    void Camera::ProcessPan(float xoffset, float yoffset, int mouseX, int mouseY, int screenWidth, int screenHeight, const Engine::Scene& scene) {
        // 1. Find the point in the world under the cursor to use as a pivot.
        glm::vec3 rayOrigin, rayDir;
        ScreenToWorldRay(mouseX, mouseY, screenWidth, screenHeight, GetViewMatrix(), GetProjectionMatrix((float)screenWidth / screenHeight), rayOrigin, rayDir);
        
        float closest_t = std::numeric_limits<float>::max();
        bool hit = false;
        
        for (const auto* obj : scene.get_all_objects()) {
            if (obj && obj->has_mesh()) {
                const auto& mesh = obj->get_mesh_buffers();
                for (size_t i = 0; i + 2 < mesh.indices.size(); i += 3) {
                    unsigned int i0 = mesh.indices[i], i1 = mesh.indices[i+1], i2 = mesh.indices[i+2];
                    glm::vec3 v0(mesh.vertices[i0*3], mesh.vertices[i0*3+1], mesh.vertices[i0*3+2]);
                    glm::vec3 v1(mesh.vertices[i1*3], mesh.vertices[i1*3+1], mesh.vertices[i1*3+2]);
                    glm::vec3 v2(mesh.vertices[i2*3], mesh.vertices[i2*3+1], mesh.vertices[i2*3+2]);
                    float t;
                    if (SnappingSystem::RayTriangleIntersect(rayOrigin, rayDir, v0, v1, v2, t) && t > 0 && t < closest_t) {
                        closest_t = t;
                        hit = true;
                    }
                }
            }
        }
        
        glm::vec3 panPivotPoint;
        if (hit) {
            panPivotPoint = rayOrigin + rayDir * closest_t;
        } else {
            glm::vec3 planeNormal = -Front;
            float distanceToPlane = glm::dot(Target - rayOrigin, planeNormal);
            if (distanceToPlane < 0) distanceToPlane = Radius;
            panPivotPoint = rayOrigin + rayDir * distanceToPlane;
        }

        // 2. Calculate the pan speed based on the distance to the pivot point.
        float distance = glm::distance(Position, panPivotPoint);
        float panFactor = distance * 0.001f; // Adjust this factor for sensitivity
        
        glm::vec3 rightMovement = Right * xoffset * panFactor;
        glm::vec3 upMovement = Up * -yoffset * panFactor;

        // 3. Apply the pan offset to both position and target.
        Position -= (rightMovement + upMovement);
        Target -= (rightMovement + upMovement);
        
        updateCameraVectors();
    }
    void Camera::ProcessOrbitZoom(float yoffset) { 
        float zoomFactor = 1.0f - yoffset * (ZoomSensitivity / 10.0f); 
        Radius *= zoomFactor; 
        Radius = glm::clamp(Radius, 0.1f, 1000.0f); 
        updateCameraPositionFromOrbit(); 
    }

    void Camera::ProcessDollyZoom(float yoffset, int mouseX, int mouseY, int screenWidth, int screenHeight, const Engine::Scene& scene) {
        if (screenWidth <= 0 || screenHeight <= 0) return;

        // 1. Find the point in the world under the cursor by raycasting against the scene
        glm::vec3 rayOrigin, rayDir;
        ScreenToWorldRay(mouseX, mouseY, screenWidth, screenHeight, GetViewMatrix(), GetProjectionMatrix((float)screenWidth / screenHeight), rayOrigin, rayDir);
        
        float closest_t = std::numeric_limits<float>::max();
        bool hit = false;
        
        for (const auto* obj : scene.get_all_objects()) {
            if (obj && obj->has_mesh()) {
                const auto& mesh = obj->get_mesh_buffers();
                for (size_t i = 0; i + 2 < mesh.indices.size(); i += 3) {
                    unsigned int i0 = mesh.indices[i], i1 = mesh.indices[i+1], i2 = mesh.indices[i+2];
                    glm::vec3 v0(mesh.vertices[i0*3], mesh.vertices[i0*3+1], mesh.vertices[i0*3+2]);
                    glm::vec3 v1(mesh.vertices[i1*3], mesh.vertices[i1*3+1], mesh.vertices[i1*3+2]);
                    glm::vec3 v2(mesh.vertices[i2*3], mesh.vertices[i2*3+1], mesh.vertices[i2*3+2]);
                    float t;
                    if (SnappingSystem::RayTriangleIntersect(rayOrigin, rayDir, v0, v1, v2, t) && t > 0 && t < closest_t) {
                        closest_t = t;
                        hit = true;
                    }
                }
            }
        }
        
        glm::vec3 pointUnderMouse;
        if (hit) {
            pointUnderMouse = rayOrigin + rayDir * closest_t;
        } else {
            // Fallback: intersect with a plane parallel to the view plane, passing through the current target.
            glm::vec3 planeNormal = -Front;
            float distanceToPlane = glm::dot(Target - rayOrigin, planeNormal);
            // If the target is behind the camera, use a default distance.
            if (distanceToPlane < 0) distanceToPlane = 20.0f;
            pointUnderMouse = rayOrigin + rayDir * distanceToPlane;
        }

        // 2. Calculate the distance to the point and apply scaling with clamping
        float distanceToTarget = glm::distance(Position, pointUnderMouse);
        const float minZoomScaleDist = 1.0f; // NEW: Reduced minimum
        const float maxZoomScaleDist = 500.0f; // NEW: Increased maximum
        float clampedDistance = glm::clamp(distanceToTarget, minZoomScaleDist, maxZoomScaleDist);
        float zoomAmount = yoffset * ZoomSensitivity * (clampedDistance * 0.07f); // NEW: Increased factor

        // 3. Calculate the movement vector and prevent zooming past the target
        glm::vec3 moveVec = glm::normalize(pointUnderMouse - Position) * zoomAmount;
        if (zoomAmount > 0 && glm::length(moveVec) > (distanceToTarget - NearPlane)) {
            moveVec = glm::normalize(pointUnderMouse - Position) * (distanceToTarget - NearPlane);
        }
        
        // 4. Move both the camera position and the target to achieve a "dolly" or "fly" effect
        Position += moveVec;
        Target += moveVec;
        
        // 5. Update derived camera properties
        Radius = glm::distance(Position, Target); // Radius is now relative to the new target
        updateCameraVectors();
    }

    void Camera::SetOrbitTarget(const glm::vec3& hitPoint) {
        // --- NEW LOGIC: The user's elegant solution ---
        // 1. Calculate the distance from the camera to the point under the cursor.
        float distance = glm::distance(Position, hitPoint);
        // 2. Set the new target to be a point this distance away, directly in front of the camera.
        Target = Position + Front * distance;
        // 3. Update the orbit radius.
        Radius = distance;

        // No need to update vectors here, as the camera's orientation (Front) hasn't changed.
    }

    void Camera::updateCameraVectors() { Front = glm::normalize(Target - Position); Right = glm::normalize(glm::cross(Front, WorldUp)); Up = glm::normalize(glm::cross(Right, Front)); }
    void Camera::updateCameraPositionFromOrbit() { Position.x = Target.x + Radius * cos(Pitch) * cos(Yaw); Position.y = Target.y + Radius * cos(Pitch) * sin(Yaw); Position.z = Target.z + Radius * sin(Pitch); updateCameraVectors(); }


    // --- Picking Ray Implementation ---
    void Camera::ScreenToWorldRay(
        int mouseX, int mouseY,
        int screenWidth, int screenHeight,
        const glm::mat4& viewMatrix,
        const glm::mat4& projectionMatrix,
        glm::vec3& outRayOrigin,
        glm::vec3& outRayDirection)
    {
        if (screenWidth <= 0 || screenHeight <= 0) return;

        // 1. Normalize Device Coordinates (NDC) [-1, 1]
        //    Invert Y because screen coords usually start top-left, NDC bottom-left
        float x = (2.0f * mouseX) / screenWidth - 1.0f;
        float y = 1.0f - (2.0f * mouseY) / screenHeight;
        float z = -1.0f; // Ray starts at the near plane in NDC
        glm::vec3 ray_nds(x, y, z);

        // 2. Homogeneous Clip Coordinates (Perspective division needed later)
        //    We want a point on the near plane (z=-1) and far plane (z=1)
        //    For perspective projection, w component is -z_eye, so we set w=1 for simplicity here.
        //    But for ray direction, it's simpler to unproject two points.
        glm::vec4 ray_clip_near(ray_nds.x, ray_nds.y, -1.0, 1.0); // Point on near plane
        glm::vec4 ray_clip_far(ray_nds.x, ray_nds.y, 1.0, 1.0);   // Point on far plane

        // 3. Eye (Camera) Coordinates
        //    Inverse projection matrix transforms clip space to eye space
        glm::mat4 InvProjection = glm::inverse(projectionMatrix);
        glm::vec4 ray_eye_near = InvProjection * ray_clip_near;
        glm::vec4 ray_eye_far = InvProjection * ray_clip_far;

        // Perspective division (divide by w)
        if (ray_eye_near.w != 0.0f) ray_eye_near /= ray_eye_near.w; else ray_eye_near.w = 1.0f;
        if (ray_eye_far.w != 0.0f) ray_eye_far /= ray_eye_far.w; else ray_eye_far.w = 1.0f;

        // 4. World Coordinates
        //    Inverse view matrix transforms eye space to world space
        glm::mat4 InvView = glm::inverse(viewMatrix);
        glm::vec4 ray_world_near_h = InvView * ray_eye_near;
        glm::vec4 ray_world_far_h = InvView * ray_eye_far;

        glm::vec3 ray_world_near(ray_world_near_h);
        glm::vec3 ray_world_far(ray_world_far_h);

        // 5. Calculate Ray Origin and Direction
        outRayOrigin = ray_world_near; // Origin is the point on the near plane in world space
        outRayDirection = glm::normalize(ray_world_far - ray_world_near); // Direction is vector from near to far point
    }


} // namespace Urbaxio
ENCODINGUTF8ENCODINGUTF8--- File: shell/src/input_handler.cpp ---
ENCODINGUTF8#define GLM_ENABLE_EXPERIMENTAL
#include "input_handler.h"
#include "camera.h"
#include "snapping.h"
#include <tools/ToolManager.h>
#include "engine/scene.h"       // This is needed for the Scene class
#include "engine/scene_object.h"  // NEW: This is required for SceneObject methods like get_mesh_buffers()

#include <imgui.h>
#include <imgui_impl_sdl2.h>
#include <SDL2/SDL.h>
#include <iostream>
#include <cmath>
#include <limits> // For std::numeric_limits

namespace Urbaxio {

    InputHandler::InputHandler() 
        : middleMouseButtonDown(false), shiftDown(false), ctrlDown(false),
          lastMouseX(0), lastMouseY(0), isMouseFocused(true), firstMouse(true) {}
    
    glm::vec3 InputHandler::GetCursorPointInWorld(const Camera& camera, int mouseX, int mouseY, int screenWidth, int screenHeight, const glm::vec3& fallbackPlanePoint) { 
        glm::vec3 point; 
        if (Urbaxio::SnappingSystem::RaycastToZPlane(mouseX, mouseY, screenWidth, screenHeight, camera, point)) { 
            return point; 
        } else { 
            glm::vec3 rayOrigin, rayDirection; 
            Camera::ScreenToWorldRay(mouseX, mouseY, screenWidth, screenHeight, camera.GetViewMatrix(), camera.GetProjectionMatrix((screenHeight > 0) ? ((float)screenWidth / (float)screenHeight) : 1.0f), rayOrigin, rayDirection); 
            glm::vec3 planeNormal = -camera.Front; 
            glm::vec3 pointOnPlane = fallbackPlanePoint; 
            float denom = glm::dot(rayDirection, planeNormal); 
            if (std::abs(denom) > 1e-6f) { 
                float t = glm::dot(pointOnPlane - rayOrigin, planeNormal) / denom; 
                if (t > 1e-4f && t < 10000.0f) return rayOrigin + rayDirection * t; 
            } 
            return rayOrigin + rayDirection * 10.0f; // Fallback
        } 
    }

    void InputHandler::ProcessEvents(
        Urbaxio::Camera& camera,
        bool& should_quit,
        SDL_Window* window,
        Tools::ToolManager& toolManager,
        Urbaxio::Engine::Scene* scene // <-- FIX: Added missing parameter to match declaration
    ) {
        SDL_Event event; 
        ImGuiIO& io = ImGui::GetIO();

        // Update modifier key states at the start of the frame
        const Uint8* keyboardState = SDL_GetKeyboardState(NULL);
        bool newShiftDown = keyboardState[SDL_SCANCODE_LSHIFT] || keyboardState[SDL_SCANCODE_RSHIFT];
        
        // NEW: Detect if shift was just released while middle mouse is held down
        if (shiftDown && !newShiftDown && middleMouseButtonDown) {
            firstMouse = true; // This will trigger a re-targeting for the orbit on next motion
        }
        shiftDown = newShiftDown;
        
        ctrlDown = keyboardState[SDL_SCANCODE_LCTRL] || keyboardState[SDL_SCANCODE_RCTRL] || keyboardState[SDL_SCANCODE_LGUI] || keyboardState[SDL_SCANCODE_RGUI];

        while (SDL_PollEvent(&event)) { 
            ImGui_ImplSDL2_ProcessEvent(&event); 
            bool wantCaptureMouse = io.WantCaptureMouse; 
            bool wantCaptureKeyboard = io.WantCaptureKeyboard; 
            
            switch (event.type) { 
                case SDL_QUIT: 
                    should_quit = true; 
                    break;
                
                case SDL_WINDOWEVENT: {
                    int w, h;
                    SDL_GetWindowSize(window, &w, &h);
                    switch (event.window.event) {
                        case SDL_WINDOWEVENT_FOCUS_GAINED: isMouseFocused = true; break;
                        case SDL_WINDOWEVENT_FOCUS_LOST:
                            isMouseFocused = false;
                            middleMouseButtonDown = false;
                            SDL_ShowCursor(SDL_ENABLE);
                            toolManager.SetTool(Tools::ToolType::Select); // Revert to select tool on focus loss
                            break;
                        case SDL_WINDOWEVENT_ENTER: isMouseFocused = true; break;
                        case SDL_WINDOWEVENT_LEAVE: isMouseFocused = false; break;
                    }
                    break;
                }
                
                case SDL_KEYDOWN:
                    // DO NOT update modifier states from event.key.keysym.mod here.
                    // The keyboardState check at the top of ProcessEvents is more reliable.
                    if (!wantCaptureKeyboard) {
                        // --- Undo/Redo ---
                        if (ctrlDown && event.key.keysym.sym == SDLK_z) {
                            scene->getCommandManager()->Undo();
                        } else if (ctrlDown && event.key.keysym.sym == SDLK_y) {
                            scene->getCommandManager()->Redo();
                        } else {
                            // Forward other key presses to the active tool
                            toolManager.OnKeyDown(event.key.keysym.sym, shiftDown, ctrlDown);
                        }
                    }
                    break;

                case SDL_KEYUP:
                    // We don't need to do anything here anymore, the state will be re-evaluated
                    // at the start of the next frame.
                    break;
                
                case SDL_MOUSEBUTTONDOWN:
                    if (!wantCaptureMouse) {
                        if (event.button.button == SDL_BUTTON_MIDDLE) {
                             middleMouseButtonDown = true;
                             firstMouse = true; 
                             SDL_ShowCursor(SDL_DISABLE);
                        } else if (event.button.button == SDL_BUTTON_LEFT) {
                            toolManager.OnLeftMouseDown(event.button.x, event.button.y, shiftDown, ctrlDown);
                        } else if (event.button.button == SDL_BUTTON_RIGHT) {
                            toolManager.OnRightMouseDown();
                        }
                    } 
                    break;
                
                case SDL_MOUSEBUTTONUP: 
                    if (event.button.button == SDL_BUTTON_MIDDLE) {
                         middleMouseButtonDown = false;
                         SDL_ShowCursor(SDL_ENABLE); 
                    } else if (event.button.button == SDL_BUTTON_LEFT && !wantCaptureMouse) {
                         toolManager.OnLeftMouseUp(event.button.x, event.button.y, shiftDown, ctrlDown);
                    }
                    break;
                
                case SDL_MOUSEWHEEL: 
                    if (!wantCaptureMouse) { 
                        if (ctrlDown) {
                            // With Ctrl, use the old orbital zoom
                            camera.ProcessOrbitZoom(static_cast<float>(event.wheel.y));
                        } else {
                            // By default, use the new dolly zoom to cursor
                            int mouseX, mouseY;
                            SDL_GetMouseState(&mouseX, &mouseY);
                            int w, h;
                            SDL_GetWindowSize(window, &w, &h);
                            camera.ProcessDollyZoom(static_cast<float>(event.wheel.y), mouseX, mouseY, w, h, *scene);
                        }
                    } 
                    break;

                case SDL_MOUSEMOTION:
                    toolManager.OnMouseMove(event.motion.x, event.motion.y);
                    break;
            }
        }

        // Handle continuous actions like camera panning/orbiting
        int w, h;
        SDL_GetWindowSize(window, &w, &h);
        HandleMouseMotion(camera, window, w, h, *scene);
    }

    void InputHandler::HandleMouseMotion(Urbaxio::Camera& camera, SDL_Window* window, int display_w, int display_h, const Urbaxio::Engine::Scene& scene) {
        int cX, cY;
        SDL_GetMouseState(&cX, &cY);

        if (middleMouseButtonDown && isMouseFocused) {
            if (firstMouse) {
                // Set orbit target when starting orbit (not pan)
                if (!shiftDown) {
                    glm::vec3 rayOrigin, rayDir;
                    Camera::ScreenToWorldRay(cX, cY, display_w, display_h, camera.GetViewMatrix(), camera.GetProjectionMatrix((float)display_w / display_h), rayOrigin, rayDir);
                    
                    float closest_t = std::numeric_limits<float>::max();
                    bool hit = false;
                    
                    for (const auto* obj : scene.get_all_objects()) {
                        if (obj && obj->has_mesh()) {
                            const auto& mesh = obj->get_mesh_buffers();
                            for (size_t i = 0; i + 2 < mesh.indices.size(); i += 3) {
                                unsigned int i0 = mesh.indices[i], i1 = mesh.indices[i+1], i2 = mesh.indices[i+2];
                                glm::vec3 v0(mesh.vertices[i0*3], mesh.vertices[i0*3+1], mesh.vertices[i0*3+2]);
                                glm::vec3 v1(mesh.vertices[i1*3], mesh.vertices[i1*3+1], mesh.vertices[i1*3+2]);
                                glm::vec3 v2(mesh.vertices[i2*3], mesh.vertices[i2*3+1], mesh.vertices[i2*3+2]);
                                float t;
                                if (SnappingSystem::RayTriangleIntersect(rayOrigin, rayDir, v0, v1, v2, t) && t > 0 && t < closest_t) {
                                    closest_t = t;
                                    hit = true;
                                }
                            }
                        }
                    }
                    if (hit) {
                        camera.SetOrbitTarget(rayOrigin + rayDir * closest_t);
                    }
                }
                lastMouseX = cX;
                lastMouseY = cY;
                firstMouse = false;
            } else {
                float dX = static_cast<float>(cX - lastMouseX);
                float dY = static_cast<float>(cY - lastMouseY);
                if (std::abs(dX) > 1e-3f || std::abs(dY) > 1e-3f) {
                    if (shiftDown) {
                        camera.ProcessPan(dX, dY, cX, cY, display_w, display_h, scene);
                    } else {
                        camera.ProcessOrbit(dX, dY);
                    }

                    // Warp mouse to keep it in the window for continuous movement
                    int nX = cX, nY = cY;
                    bool warped = false;
                    const int margin = 1;
                    if (display_w > (margin + 1) * 2 && display_h > (margin + 1) * 2) {
                        if (cX <= margin) { nX = display_w - (margin + 2); warped = true; }
                        else if (cX >= display_w - (margin + 1)) { nX = margin + 1; warped = true; }
                        if (cY <= margin) { nY = display_h - (margin + 2); warped = true; }
                        else if (cY >= display_h - (margin + 1)) { nY = margin + 1; warped = true; }
                    }
                    if (warped) {
                        SDL_WarpMouseInWindow(window, nX, nY);
                        lastMouseX = nX;
                        lastMouseY = nY;
                    } else {
                        lastMouseX = cX;
                        lastMouseY = cY;
                    }
                } else {
                    lastMouseX = cX;
                    lastMouseY = cY;
                }
            }
        } else {
            firstMouse = true;
            lastMouseX = cX;
            lastMouseY = cY;
        }
    }

} // namespace Urbaxio
ENCODINGUTF8ENCODINGUTF8--- File: shell/src/renderer.cpp ---
ENCODINGUTF8#include "renderer.h"
#include "camera.h"
#include <engine/scene.h>
#include <engine/scene_object.h>
#include <engine/line.h>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/constants.hpp>
#include <glm/gtc/quaternion.hpp>
#include <glm/gtx/quaternion.hpp>
#include <imgui_impl_opengl3.h>
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
#include <cstddef>
#include <map>
#include <set>
#include <utility>

namespace { // Anonymous namespace for utility functions
    GLuint CompileShader(GLenum type, const char* source) { GLuint shader = glCreateShader(type); glShaderSource(shader, 1, &source, NULL); glCompileShader(shader); GLint success; GLchar infoLog[512]; glGetShaderiv(shader, GL_COMPILE_STATUS, &success); if (!success) { glGetShaderInfoLog(shader, 512, NULL, infoLog); std::cerr << "ERROR::SHADER::COMPILATION_FAILED\n" << (type == GL_VERTEX_SHADER ? "Vertex" : "Fragment") << "\n" << source << "\n" << infoLog << std::endl; glDeleteShader(shader); return 0; } return shader; }
    GLuint LinkShaderProgram(GLuint vertexShader, GLuint fragmentShader) { GLuint shaderProgram = glCreateProgram(); glAttachShader(shaderProgram, vertexShader); glAttachShader(shaderProgram, fragmentShader); glLinkProgram(shaderProgram); GLint success; GLchar infoLog[512]; glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success); if (!success) { glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); std::cerr << "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" << infoLog << std::endl; glDeleteProgram(shaderProgram); if (glIsShader(vertexShader)) glDeleteShader(vertexShader); if (glIsShader(fragmentShader)) glDeleteShader(fragmentShader); return 0; } glDeleteShader(vertexShader); glDeleteShader(fragmentShader); return shaderProgram; }
    // Modified to only generate geometry, color will be handled by shader
    // Generates grid vertices on the XY plane (for Z-up system)
    std::vector<float> GenerateGridVertices(float size, int steps) {
        std::vector<float> vertices;
        if (steps <= 0 || size <= 0.0f) return vertices;
        float halfSize = size / 2.0f;
        float stepSize = size / static_cast<float>(steps);
        const float epsilon = 1e-6f;

        for (int i = 0; i <= steps; ++i) {
            float pos = -halfSize + static_cast<float>(i) * stepSize;
            
            // Skip center lines, as they are drawn by the axes
            if (std::abs(pos) > epsilon) {
                // Lines parallel to Y axis (X is constant at 'pos')
                vertices.push_back(pos); vertices.push_back(-halfSize); vertices.push_back(0.0f);
                vertices.push_back(pos); vertices.push_back(halfSize);  vertices.push_back(0.0f);

                // Lines parallel to X axis (Y is constant at 'pos')
                vertices.push_back(-halfSize); vertices.push_back(pos); vertices.push_back(0.0f);
                vertices.push_back(halfSize);  vertices.push_back(pos); vertices.push_back(0.0f);
            }
        }
        return vertices;
    }
    // Modified to return vertices for a single axis with specific fade colors
    std::vector<float> GenerateSingleAxisVertices(float length, const glm::vec3& direction, const glm::vec4& baseColor, const glm::vec4& posFadeColor, const glm::vec4& negFadeColor) {
        std::vector<float> vertices;
        if (length <= 0.0f) return vertices;

        glm::vec3 p1 = direction * length;
        glm::vec3 p2 = direction * -length;
        
        // Positive part - use normal alpha 
        vertices.push_back(0.0f); vertices.push_back(0.0f); vertices.push_back(0.0f);
        vertices.push_back(baseColor.r); vertices.push_back(baseColor.g); vertices.push_back(baseColor.b); vertices.push_back(baseColor.a);
        vertices.push_back(p1.x); vertices.push_back(p1.y); vertices.push_back(p1.z);
        vertices.push_back(baseColor.r); vertices.push_back(baseColor.g); vertices.push_back(baseColor.b); vertices.push_back(baseColor.a);

        // Negative part - use negative alpha to mark it for the shader
        vertices.push_back(0.0f); vertices.push_back(0.0f); vertices.push_back(0.0f);
        vertices.push_back(baseColor.r); vertices.push_back(baseColor.g); vertices.push_back(baseColor.b); vertices.push_back(-negFadeColor.a);
        vertices.push_back(p2.x); vertices.push_back(p2.y); vertices.push_back(p2.z);
        vertices.push_back(baseColor.r); vertices.push_back(baseColor.g); vertices.push_back(baseColor.b); vertices.push_back(-negFadeColor.a);

        return vertices;
    }
    std::vector<float> GenerateQuadVertices(float size) { float half = size / 2.0f; std::vector<float> vertices = { -half,-half,0.0f, 0.0f,0.0f, half,-half,0.0f, 1.0f,0.0f, half, half,0.0f, 1.0f,1.0f, -half, half,0.0f, 0.0f,1.0f }; return vertices; }
    std::vector<float> GenerateCircleVertices(int segments) { std::vector<float> vertices; vertices.push_back(0.0f); vertices.push_back(0.0f); float angleStep = 2.0f * glm::pi<float>() / static_cast<float>(segments); for (int i = 0; i <= segments; ++i) { float angle = static_cast<float>(i) * angleStep; vertices.push_back(cos(angle) * 0.5f); vertices.push_back(sin(angle) * 0.5f); } return vertices; }
    std::vector<float> GenerateDiamondVertices() { std::vector<float> vertices = { 0.0f,  0.5f, 0.5f,  0.0f, 0.0f, -0.5f, -0.5f,  0.0f }; vertices.push_back(0.0f); vertices.push_back(0.5f); return vertices; }
}

namespace Urbaxio {

    Renderer::Renderer() {
        objectVertexShaderSource =
            "#version 330 core\n"
            "layout (location = 0) in vec3 aPos;\n"
            "layout (location = 1) in vec3 aNormal;\n"
            "uniform mat4 model;\n"
            "uniform mat4 view;\n"
            "uniform mat4 projection;\n"
            "out vec3 FragPosWorld;\n"
            "out vec3 NormalWorld;\n"
            "void main() {\n"
            "    FragPosWorld = vec3(model * vec4(aPos, 1.0));\n"
            "    NormalWorld = mat3(transpose(inverse(model))) * aNormal;\n"
            "    gl_Position = projection * view * vec4(FragPosWorld, 1.0);\n"
            "}\n";

        objectFragmentShaderSource =
            "#version 330 core\n"
            "out vec4 FragColor;\n"
            "in vec3 FragPosWorld;\n"
            "in vec3 NormalWorld;\n"
            "uniform vec3 objectColor;\n"
            "uniform vec3 lightDir;\n"
            "uniform vec3 lightColor;\n"
            "uniform float ambientStrength;\n"
            "uniform vec3 viewPos;\n"
            "uniform float overrideAlpha = 1.0;\n"
            "void main() {\n"
            "    vec3 norm = normalize(NormalWorld);\n"
            "    vec3 ambient = ambientStrength * lightColor * objectColor;\n"
            "    float diff = max(dot(norm, normalize(lightDir)), 0.0);\n"
            "    vec3 diffuse = diff * lightColor * objectColor;\n"
            "    vec3 result = ambient + diffuse;\n"
            "    FragColor = vec4(result, overrideAlpha);\n"
            "}\n";

        // This will be for simple lines like the rubber band and user lines
        simpleLineVertexShaderSource =
            "#version 330 core\n"
            "layout (location = 0) in vec3 aPos;\n"
            "layout (location = 1) in vec4 aBaseColorAlpha;\n"
            "uniform mat4 model;\n"
            "uniform mat4 view;\n"
            "uniform mat4 projection;\n"
            "out vec4 fragmentColor;\n"
            "void main() {\n"
            "    gl_Position = projection * view * model * vec4(aPos, 1.0);\n"
            "    fragmentColor = aBaseColorAlpha;\n"
            "}\n";

        simpleLineFragmentShaderSource =
            "#version 330 core\n"
            "out vec4 FragColor;\n"
            "in vec4 fragmentColor;\n"
            "void main() {\n"
            "    FragColor = fragmentColor;\n"
            "}\n";

        gridVertexShaderSource =
            "#version 330 core\n"
            "layout (location = 0) in vec3 aPos;\n"
            "uniform mat4 model;\n"
            "uniform mat4 view;\n"
            "uniform mat4 projection;\n"
            "out vec3 vWorldPos;\n"
            "void main() {\n"
            "    vWorldPos = (model * vec4(aPos, 1.0)).xyz;\n"
            "    gl_Position = projection * view * vec4(vWorldPos, 1.0);\n"
            "}\n";

        gridFragmentShaderSource =
            "#version 330 core\n"
            "out vec4 FragColor;\n"
            "in vec3 vWorldPos;\n"
            "uniform vec3 u_gridColor;\n"
            "uniform vec3 u_cursorWorldPos;\n"
            "uniform float u_cursorRadius;\n"
            "uniform float u_intensity;\n"
            "uniform float u_holeStart;\n"
            "uniform float u_holeEnd;\n"
            "const float GRID_FADE_START = 10.0;\n"
            "const float GRID_FADE_END = 40.0;\n"
            "const float BASE_GRID_ALPHA = 0.3;\n"
            "void main() {\n"
            "    float distFromOrigin = length(vWorldPos.xy);\n"
            "    float alphaFromOrigin = (1.0 - smoothstep(GRID_FADE_START, GRID_FADE_END, distFromOrigin)) * BASE_GRID_ALPHA;\n"
            "    float distFromMouse = distance(vWorldPos.xy, u_cursorWorldPos.xy);\n"
            "    float alphaFromMouse = (1.0 - smoothstep(0.0, u_cursorRadius, distFromMouse)) * u_intensity * 0.8;\n"
            "    float finalAlpha = max(alphaFromOrigin, alphaFromMouse);\n"
            "    // Add hole effect - fade in from center\n"
            "    float holeVisibility = smoothstep(u_holeStart, u_holeEnd, distFromOrigin);\n"
            "    FragColor = vec4(u_gridColor, finalAlpha * holeVisibility);\n"
            "}\n";
        
        axisVertexShaderSource =
            "#version 330 core\n"
            "layout (location = 0) in vec3 aPos;\n"
            "layout (location = 1) in vec4 aBaseColorAlpha;\n"
            "uniform mat4 model;\n"
            "uniform mat4 view;\n"
            "uniform mat4 projection;\n"
            "out vec3 vWorldPos;\n"
            "out vec4 vBaseColor;\n"
            "void main() {\n"
            "    vWorldPos = (model * vec4(aPos, 1.0)).xyz;\n"
            "    vBaseColor = aBaseColorAlpha;\n"
            "    gl_Position = projection * view * vec4(vWorldPos, 1.0);\n"
            "}\n";

        axisFragmentShaderSource =
            "#version 330 core\n"
            "out vec4 FragColor;\n"
            "in vec3 vWorldPos;\n"
            "in vec4 vBaseColor;\n"
            "uniform vec3 u_cursorWorldPos;\n"
            "uniform float u_cursorRadius;\n"
            "uniform float u_intensity;\n"
            "uniform float u_fadeStart;\n"
            "uniform float u_fadeEnd;\n"
            "uniform float u_holeStart;\n"
            "uniform float u_holeEnd;\n"
            "uniform vec4 u_positiveFadeColor;\n"
            "uniform vec4 u_negativeFadeColor;\n"
            "void main() {\n"
            "    float distFromOrigin = length(vWorldPos);\n"
            "    float distFromMouse = distance(vWorldPos, u_cursorWorldPos);\n"
            "    float mouseRevealFactor = (1.0 - smoothstep(0.0, u_cursorRadius, distFromMouse)) * u_intensity;\n"
            "    vec3 finalColor;\n"
            "    float finalAlpha;\n"
            "    // Check if it's a negative axis (alpha < 0)\n"
            "    if (vBaseColor.a < 0.0) { \n"
            "        vec3 fadedColor = mix(vBaseColor.rgb, u_negativeFadeColor.rgb, 1.0);\n"
            "        finalColor = mix(fadedColor, vBaseColor.rgb, mouseRevealFactor);\n"
            "        finalAlpha = mix(abs(vBaseColor.a), 1.0, mouseRevealFactor);\n"
            "    } else {\n"
            "        float fadeToWhiteFactor = smoothstep(u_fadeStart, u_fadeEnd, distFromOrigin);\n"
            "        vec3 fadedColor = mix(vBaseColor.rgb, u_positiveFadeColor.rgb, fadeToWhiteFactor);\n"
            "        finalColor = mix(fadedColor, vBaseColor.rgb, mouseRevealFactor);\n"
            "        finalAlpha = mix(vBaseColor.a, 1.0, mouseRevealFactor);\n"
            "    }\n"
            "    // Add hole effect - fade in from center\n"
            "    float holeVisibility = smoothstep(u_holeStart, u_holeEnd, distFromOrigin);\n"
            "    FragColor = vec4(finalColor, finalAlpha * holeVisibility);\n"
            "}\n";

        unlitVertexShaderSource =
            "#version 330 core\n"
            "layout (location = 0) in vec3 aPos;\n"
            "uniform mat4 model;\n"
            "uniform mat4 view;\n"
            "uniform mat4 projection;\n"
            "out vec3 vWorldPos;\n"
            "void main() {\n"
            "    vWorldPos = vec3(model * vec4(aPos, 1.0));\n"
            "    gl_Position = projection * view * vec4(vWorldPos, 1.0);\n"
            "}\n";

        unlitFragmentShaderSource =
            "#version 330 core\n"
            "out vec4 FragColor;\n"
            "uniform vec3 u_baseColor;\n"
            "uniform vec3 u_fadeColor;\n"
            "uniform vec3 u_cursorWorldPos;\n"
            "uniform float u_cursorRadius;\n"
            "uniform float u_intensity;\n"
            "uniform float u_fadeStart;\n"
            "uniform float u_fadeEnd;\n"
            "in vec3 vWorldPos;\n"
            "void main() {\n"
            "    float distFromOrigin = length(vWorldPos);\n"
            "    float fadeToWhiteFactor = smoothstep(u_fadeStart, u_fadeEnd, distFromOrigin);\n"
            "    vec3 fadedColor = mix(u_baseColor, u_fadeColor, fadeToWhiteFactor);\n"
            "    float distFromMouse = distance(vWorldPos, u_cursorWorldPos);\n"
            "    float mouseRevealFactor = (1.0 - smoothstep(0.0, u_cursorRadius, distFromMouse)) * u_intensity;\n"
            "    vec3 finalColor = mix(fadedColor, u_baseColor, mouseRevealFactor);\n"
            "    FragColor = vec4(finalColor, 1.0);\n"
            "}\n";

        splatVertexShaderSource =
            "#version 330 core\n"
            "layout (location = 0) in vec3 aPos;\n"
            "layout (location = 1) in vec2 aTexCoord;\n"
            "uniform mat4 model;\n"
            "uniform mat4 view;\n"
            "uniform mat4 projection;\n"
            "out vec2 TexCoord;\n"
            "void main() {\n"
            "    gl_Position = projection * view * model * vec4(aPos, 1.0);\n"
            "    TexCoord = aTexCoord;\n"
            "}\n";

        splatFragmentShaderSource =
            "#version 330 core\n"
            "out vec4 FragColor;\n"
            "in vec2 TexCoord;\n"
            "uniform vec4 splatColor;\n"
            "uniform float blurStrength;\n"
            "void main() {\n"
            "    float dist = distance(TexCoord, vec2(0.5));\n"
            "    float falloff = exp(-dist * dist * blurStrength);\n"
            "    float finalAlpha = splatColor.a * falloff;\n"
            "    FragColor = vec4(splatColor.rgb, finalAlpha);\n"
            "}\n";

        markerVertexShaderSource =
            "#version 330 core\n"
            "layout (location = 0) in vec2 aPosModel;\n"
            "uniform vec3 u_WorldPos;\n"
            "uniform float u_ScreenSize;\n"
            "uniform mat4 u_ViewMatrix;\n"
            "uniform mat4 u_ProjMatrix;\n"
            "uniform vec2 u_ViewportSize;\n"
            "void main() {\n"
            "    vec4 worldCenter = vec4(u_WorldPos, 1.0);\n"
            "    vec4 clipCenter = u_ProjMatrix * u_ViewMatrix * worldCenter;\n"
            "    if (clipCenter.w <= 0.0) { gl_Position = vec4(2.0, 2.0, 2.0, 1.0); return; }\n" // Cull if behind camera
            "    vec2 scaleFactor = (vec2(u_ScreenSize) / u_ViewportSize) * 2.0 * clipCenter.w;\n"
            "    vec4 clipOffset = vec4(aPosModel * scaleFactor, 0.0, 0.0);\n"
            "    gl_Position = clipCenter + clipOffset;\n"
            "    if (gl_Position.w <= 0.0) { gl_Position.w = 0.001; }\n" // Ensure w is positive for perspective divide
            "}\n";

        markerFragmentShaderSource =
            "#version 330 core\n"
            "out vec4 FragColor;\n"
            "uniform vec4 u_Color;\n"
            "void main() {\n"
            "    FragColor = u_Color;\n"
            "}\n";

        dashedLineVertexShaderSource =
            "#version 330 core\n"
            "layout (location = 0) in vec3 aPos;\n"
            "layout (location = 1) in float aDist;\n" // Distance from start of line
            "uniform mat4 model;\n"
            "uniform mat4 view;\n"
            "uniform mat4 projection;\n"
            "out float vDist;\n"
            "void main() {\n"
            "    gl_Position = projection * view * model * vec4(aPos, 1.0);\n"
            "    vDist = aDist;\n"
            "}\n";
        
        dashedLineFragmentShaderSource =
            "#version 330 core\n"
            "out vec4 FragColor;\n"
            "in float vDist;\n"
            "uniform vec4 u_Color;\n"
            "uniform float u_DashSize;\n"
            "uniform float u_GapSize;\n"
            "void main() {\n"
            "    float patternLength = u_DashSize + u_GapSize;\n"
            "    if (patternLength < 0.001) {\n"
            "        FragColor = u_Color;\n"
            "        return;\n"
            "    }\n"
            "    float modularDist = mod(vDist, patternLength);\n"
            "    if (modularDist > u_DashSize) {\n"
            "        discard;\n"
            "    }\n"
            "    FragColor = u_Color;\n"
            "}\n";
    }
    Renderer::~Renderer() { Cleanup(); }
    bool Renderer::Initialize() { std::cout << "Renderer: Initializing..." << std::endl; GLfloat range[2] = { 1.0f, 1.0f }; glGetFloatv(GL_ALIASED_LINE_WIDTH_RANGE, range); maxLineWidth = std::max(1.0f, range[1]); std::cout << "Renderer: Supported ALIASED Line Width Range: [" << range[0] << ", " << maxLineWidth << "]" << std::endl; if (!CreateShaderPrograms()) return false; if (!CreateGridResources()) return false; if (!CreateAxesResources()) return false; if (!CreateSplatResources()) return false; if (!CreateUserLinesResources()) return false; if (!CreateMarkerResources()) return false; if (!CreatePreviewResources()) return false; if (!CreatePreviewLineResources()) return false; if (!CreatePreviewOutlineResources()) return false; glEnable(GL_DEPTH_TEST); glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); std::cout << "Renderer: Initialization successful." << std::endl; return true; }
    void Renderer::SetViewport(int x, int y, int width, int height) { /* ... same ... */ if (width > 0 && height > 0) { glViewport(x, y, width, height); } }
    
    void Renderer::RenderFrame(
        SDL_Window* window,
        const Urbaxio::Camera& camera,
        Urbaxio::Engine::Scene* scene,
        // Appearance
        const glm::vec3& defaultObjectColor,
        const glm::vec3& lightColor, float ambientStrength,
        bool showGrid, bool showAxes, float axisLineWidth, float negAxisLineWidth,
        const glm::vec3& gridColor, const glm::vec4& axisColorX, const glm::vec4& axisColorY, const glm::vec4& axisColorZ,
        const glm::vec4& positiveAxisFadeColor, const glm::vec4& negativeAxisFadeColor,
        // Interactive Effects
        const glm::vec3& cursorWorldPos, float cursorRadius, float intensity,
        // Selections
        uint64_t selectedObjId,
        const std::vector<size_t>& selectedTriangleIndices,
        const std::set<uint64_t>& selectedLineIDs,
        const glm::vec3& selectionHighlightColor,
        // Hovers
        uint64_t hoveredObjId,
        const std::vector<size_t>& hoveredFaceTriangleIndices,
        const glm::vec3& hoverHighlightColor,
        // Tools
        const SnapResult& currentSnap,
        ImDrawData* imguiDrawData
    ) {
        int display_w, display_h; SDL_GetWindowSize(window, &display_w, &display_h); if (display_w <= 0 || display_h <= 0) return; glm::mat4 view = camera.GetViewMatrix(); glm::mat4 projection = camera.GetProjectionMatrix((float)display_w / (float)display_h); glm::mat4 identityModel = glm::mat4(1.0f);
        
        float distanceToCamera = glm::length(camera.Position);
        const float referenceDistance = 30.0f;
        float distanceScale = distanceToCamera / referenceDistance;
        
        // --- 1. OPAQUE PASS ---
        if (objectShaderProgram != 0 && scene) {
            glUseProgram(objectShaderProgram);
            glUniformMatrix4fv(glGetUniformLocation(objectShaderProgram, "view"), 1, GL_FALSE, glm::value_ptr(view));
            glUniformMatrix4fv(glGetUniformLocation(objectShaderProgram, "projection"), 1, GL_FALSE, glm::value_ptr(projection));
            // Use camera's front direction as light direction (headlamp lighting)
            // The light direction should point FROM the light source TO the surface
            glm::vec3 lightDir = -glm::normalize(camera.Front);
            glUniform3fv(glGetUniformLocation(objectShaderProgram, "lightDir"), 1, glm::value_ptr(lightDir));
            glUniform3fv(glGetUniformLocation(objectShaderProgram, "lightColor"), 1, glm::value_ptr(lightColor));
            glUniform1f(glGetUniformLocation(objectShaderProgram, "ambientStrength"), ambientStrength);
            glUniform3fv(glGetUniformLocation(objectShaderProgram, "viewPos"), 1, glm::value_ptr(camera.Position));
            glUniform1f(glGetUniformLocation(objectShaderProgram, "overrideAlpha"), 1.0f);
            for (const auto* obj : scene->get_all_objects()) {
                if (obj && obj->vao != 0 && obj->index_count > 0) {
                    const auto& name = obj->get_name();
                    if (name != "CenterMarker" && name != "UnitCapsuleMarker10m" && name != "UnitCapsuleMarker5m") {
                        glUniform3fv(glGetUniformLocation(objectShaderProgram, "objectColor"), 1, glm::value_ptr(defaultObjectColor));
                        glUniformMatrix4fv(glGetUniformLocation(objectShaderProgram, "model"), 1, GL_FALSE, glm::value_ptr(identityModel));
                        glBindVertexArray(obj->vao);
                        glDrawElements(GL_TRIANGLES, obj->index_count, GL_UNSIGNED_INT, 0);
                        glBindVertexArray(0);
                    }
                }
            }
        }

        // --- 2. TRANSPARENT / OVERLAY PASS ---
        glDepthMask(GL_FALSE);

        if (objectShaderProgram != 0 && scene) {
            glUseProgram(objectShaderProgram);
            if (hoveredObjId != 0 && !hoveredFaceTriangleIndices.empty()) {
                bool isSameAsSelected = (hoveredObjId == selectedObjId) && (hoveredFaceTriangleIndices == selectedTriangleIndices);
                if (!isSameAsSelected) {
                    Urbaxio::Engine::SceneObject* hoveredObj = scene->get_object_by_id(hoveredObjId);
                     if (hoveredObj && hoveredObj->vao != 0) {
                        glUniform3fv(glGetUniformLocation(objectShaderProgram, "objectColor"), 1, glm::value_ptr(hoverHighlightColor));
                        glEnable(GL_POLYGON_OFFSET_FILL);
                        glPolygonOffset(-2.0f, -2.0f);
                        glBindVertexArray(hoveredObj->vao);
                        for (size_t baseIndex : hoveredFaceTriangleIndices) {
                             if (baseIndex + 2 < hoveredObj->get_mesh_buffers().indices.size()) {
                                 glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_INT, (void*)(baseIndex * sizeof(unsigned int)));
                             }
                        }
                        glBindVertexArray(0);
                        glDisable(GL_POLYGON_OFFSET_FILL);
                     }
                }
            }
            if (selectedObjId != 0 && !selectedTriangleIndices.empty()) {
                Urbaxio::Engine::SceneObject* selectedObj = scene->get_object_by_id(selectedObjId);
                if (selectedObj && selectedObj->vao != 0) {
                    glUniform3fv(glGetUniformLocation(objectShaderProgram, "objectColor"), 1, glm::value_ptr(selectionHighlightColor));
                    glEnable(GL_POLYGON_OFFSET_FILL);
                    glPolygonOffset(-1.0f, -1.0f);
                    glBindVertexArray(selectedObj->vao);
                    for (size_t baseIndex : selectedTriangleIndices) {
                        if (baseIndex + 2 < selectedObj->get_mesh_buffers().indices.size()) {
                             glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_INT, (void*)(baseIndex * sizeof(unsigned int)));
                        }
                    }
                    glBindVertexArray(0);
                    glDisable(GL_POLYGON_OFFSET_FILL);
                }
            }
            if (previewVertexCount > 0) {
                glUniform3fv(glGetUniformLocation(objectShaderProgram, "objectColor"), 1, glm::value_ptr(hoverHighlightColor));
                glUniform1f(glGetUniformLocation(objectShaderProgram, "overrideAlpha"), 0.5f);
                glBindVertexArray(previewVAO);
                glDrawArrays(GL_TRIANGLES, 0, previewVertexCount);
                glBindVertexArray(0);
                glUniform1f(glGetUniformLocation(objectShaderProgram, "overrideAlpha"), 1.0f);
            }
        }

        if (showGrid && gridVAO != 0 && gridShaderProgram != 0) {
            glLineWidth(1.0f);
            glUseProgram(gridShaderProgram);
            glUniformMatrix4fv(glGetUniformLocation(gridShaderProgram, "model"), 1, GL_FALSE, glm::value_ptr(identityModel));
            glUniformMatrix4fv(glGetUniformLocation(gridShaderProgram, "view"), 1, GL_FALSE, glm::value_ptr(view));
            glUniformMatrix4fv(glGetUniformLocation(gridShaderProgram, "projection"), 1, GL_FALSE, glm::value_ptr(projection));
            glUniform3fv(glGetUniformLocation(gridShaderProgram, "u_gridColor"), 1, glm::value_ptr(gridColor));
            glUniform3fv(glGetUniformLocation(gridShaderProgram, "u_cursorWorldPos"), 1, glm::value_ptr(cursorWorldPos));
            glUniform1f(glGetUniformLocation(gridShaderProgram, "u_cursorRadius"), cursorRadius);
            glUniform1f(glGetUniformLocation(gridShaderProgram, "u_intensity"), intensity);
            const float baseHoleStart = 0.25f, baseHoleEnd = 0.75f;
            glUniform1f(glGetUniformLocation(gridShaderProgram, "u_holeStart"), baseHoleStart * distanceScale);
            glUniform1f(glGetUniformLocation(gridShaderProgram, "u_holeEnd"), baseHoleEnd * distanceScale);
            glBindVertexArray(gridVAO);
            glDrawArrays(GL_LINES, 0, gridVertexCount);
            glBindVertexArray(0);
        }

        if (userLinesVAO != 0 && simpleLineShaderProgram != 0 && userLinesVertexCount > 0) {
            glLineWidth(2.0f);
            glUseProgram(simpleLineShaderProgram);
            glUniformMatrix4fv(glGetUniformLocation(simpleLineShaderProgram, "model"), 1, GL_FALSE, glm::value_ptr(identityModel));
            glUniformMatrix4fv(glGetUniformLocation(simpleLineShaderProgram, "view"), 1, GL_FALSE, glm::value_ptr(view));
            glUniformMatrix4fv(glGetUniformLocation(simpleLineShaderProgram, "projection"), 1, GL_FALSE, glm::value_ptr(projection));
            glBindVertexArray(userLinesVAO);
            glDrawArrays(GL_LINES, 0, userLinesVertexCount);
            glBindVertexArray(0);
            glLineWidth(1.0f);
        }
        if (previewLineEnabled && previewLineVAO != 0 && simpleLineShaderProgram != 0) {
            glLineWidth(1.0f);
            glUseProgram(simpleLineShaderProgram);
            glUniformMatrix4fv(glGetUniformLocation(simpleLineShaderProgram, "model"), 1, GL_FALSE, glm::value_ptr(identityModel));
            glUniformMatrix4fv(glGetUniformLocation(simpleLineShaderProgram, "view"), 1, GL_FALSE, glm::value_ptr(view));
            glUniformMatrix4fv(glGetUniformLocation(simpleLineShaderProgram, "projection"), 1, GL_FALSE, glm::value_ptr(projection));
            glBindVertexArray(previewLineVAO);
            glDrawArrays(GL_LINES, 0, 2);
            glBindVertexArray(0);
        }

        if (previewOutlineVertexCount > 0) {
            glLineWidth(1.5f);
            glUseProgram(dashedLineShaderProgram);
            glUniformMatrix4fv(glGetUniformLocation(dashedLineShaderProgram, "model"), 1, GL_FALSE, glm::value_ptr(identityModel));
            glUniformMatrix4fv(glGetUniformLocation(dashedLineShaderProgram, "view"), 1, GL_FALSE, glm::value_ptr(view));
            glUniformMatrix4fv(glGetUniformLocation(dashedLineShaderProgram, "projection"), 1, GL_FALSE, glm::value_ptr(projection));
            glUniform4f(glGetUniformLocation(dashedLineShaderProgram, "u_Color"), 1.0f, 1.0f, 1.0f, 0.8f);
            glUniform1f(glGetUniformLocation(dashedLineShaderProgram, "u_DashSize"), 0.2f);
            glUniform1f(glGetUniformLocation(dashedLineShaderProgram, "u_GapSize"), 0.1f);
            glBindVertexArray(previewOutlineVAO);
            glDrawArrays(GL_LINES, 0, previewOutlineVertexCount);
            glBindVertexArray(0);
            glLineWidth(1.0f);
        }
        
        if (unlitShaderProgram != 0 && scene) {
            glUseProgram(unlitShaderProgram);
            glUniformMatrix4fv(glGetUniformLocation(unlitShaderProgram, "view"), 1, GL_FALSE, glm::value_ptr(view));
            glUniformMatrix4fv(glGetUniformLocation(unlitShaderProgram, "projection"), 1, GL_FALSE, glm::value_ptr(projection));
            glUniform3fv(glGetUniformLocation(unlitShaderProgram, "u_cursorWorldPos"), 1, glm::value_ptr(cursorWorldPos));
            glUniform1f(glGetUniformLocation(unlitShaderProgram, "u_cursorRadius"), cursorRadius);
            glUniform1f(glGetUniformLocation(unlitShaderProgram, "u_intensity"), intensity);
            Urbaxio::Engine::SceneObject* center_marker = nullptr, *capsule_marker_10m_template = nullptr, *capsule_marker_5m_template = nullptr;
            for(auto* obj : scene->get_all_objects()){ if(obj) { const auto& name = obj->get_name(); if(name == "CenterMarker") center_marker = obj; else if (name == "UnitCapsuleMarker10m") capsule_marker_10m_template = obj; else if (name == "UnitCapsuleMarker5m") capsule_marker_5m_template = obj; } }
            if (center_marker && center_marker->vao != 0) {
                 float scale = (distanceToCamera / referenceDistance) * 0.7f;
                 glUniform1f(glGetUniformLocation(unlitShaderProgram, "u_fadeStart"), 0.0); glUniform1f(glGetUniformLocation(unlitShaderProgram, "u_fadeEnd"), 0.0);
                 glm::mat4 modelMatrix = glm::scale(glm::mat4(1.0f), glm::vec3(scale));
                 glUniformMatrix4fv(glGetUniformLocation(unlitShaderProgram, "model"), 1, GL_FALSE, glm::value_ptr(modelMatrix));
                 glUniform3f(glGetUniformLocation(unlitShaderProgram, "u_baseColor"), 1.0f, 1.0f, 1.0f);
                 glUniform3f(glGetUniformLocation(unlitShaderProgram, "u_fadeColor"), 1.0f, 1.0f, 1.0f);
                 glBindVertexArray(center_marker->vao);
                 glDrawElements(GL_TRIANGLES, center_marker->index_count, GL_UNSIGNED_INT, 0);
            }
            if (showAxes && capsule_marker_10m_template && capsule_marker_10m_template->vao != 0 && capsule_marker_5m_template && capsule_marker_5m_template->vao != 0) {
                const float markerBaseScale = 0.15f, maxMarkerDist = 100, maxMarkerWorldSize = 0.5f;
                const float baseFadeStart = 0.5f, baseFadeEnd = 4.0f;
                glUniform1f(glGetUniformLocation(unlitShaderProgram, "u_fadeStart"), baseFadeStart * distanceScale);
                glUniform1f(glGetUniformLocation(unlitShaderProgram, "u_fadeEnd"), baseFadeEnd * distanceScale);
                struct AxisInfo { glm::vec3 dir; glm::vec4 color; }; std::vector<AxisInfo> axes_info = { {glm::vec3(1,0,0), axisColorX}, {glm::vec3(0,1,0), axisColorY}, {glm::vec3(0,0,1), axisColorZ} };
                glUniform3fv(glGetUniformLocation(unlitShaderProgram, "u_fadeColor"), 1, glm::value_ptr(glm::vec3(positiveAxisFadeColor)));
                for(const auto& axis : axes_info) {
                    glUniform3fv(glGetUniformLocation(unlitShaderProgram, "u_baseColor"), 1, glm::value_ptr(glm::vec3(axis.color)));
                    for(int i = 5; i <= maxMarkerDist; i += 5) {
                        glm::vec3 position = axis.dir * (float)i; float distToMarker = glm::length(camera.Position - position); float scale = (distToMarker / referenceDistance) * markerBaseScale;
                        if (scale > maxMarkerWorldSize) scale = maxMarkerWorldSize;
                        glm::mat4 translationMatrix = glm::translate(glm::mat4(1.0f), position);
                        Urbaxio::Engine::SceneObject* current_marker_template = (i % 10 == 0) ? capsule_marker_10m_template : capsule_marker_5m_template;
                        glm::quat rotation; if (glm::abs(axis.dir.z) > 0.99) { rotation = glm::angleAxis(glm::radians(90.0f), glm::vec3(1,0,0)); rotation = glm::angleAxis(glm::radians(45.0f), glm::vec3(0,0,1)) * rotation; } else { rotation = glm::angleAxis(glm::radians(90.0f), glm::vec3(1,0,0)); rotation = glm::angleAxis(glm::atan(axis.dir.y, axis.dir.x), glm::vec3(0,0,1)) * rotation; }
                        glm::mat4 modelMatrix = translationMatrix * glm::mat4_cast(rotation) * glm::scale(glm::mat4(1.0f), glm::vec3(scale));
                        glUniformMatrix4fv(glGetUniformLocation(unlitShaderProgram, "model"), 1, GL_FALSE, glm::value_ptr(modelMatrix));
                        glBindVertexArray(current_marker_template->vao);
                        glDrawElements(GL_TRIANGLES, current_marker_template->index_count, GL_UNSIGNED_INT, 0);
                    }
                }
            }
            glBindVertexArray(0);
        }
        if (showAxes && axesVAO != 0 && axisShaderProgram != 0) {
            UpdateAxesVBO(axisColorX, axisColorY, axisColorZ, positiveAxisFadeColor, negativeAxisFadeColor);
            glUseProgram(axisShaderProgram);
            glUniformMatrix4fv(glGetUniformLocation(axisShaderProgram, "model"), 1, GL_FALSE, glm::value_ptr(identityModel));
            glUniformMatrix4fv(glGetUniformLocation(axisShaderProgram, "view"), 1, GL_FALSE, glm::value_ptr(view));
            glUniformMatrix4fv(glGetUniformLocation(axisShaderProgram, "projection"), 1, GL_FALSE, glm::value_ptr(projection));
            glUniform3fv(glGetUniformLocation(axisShaderProgram, "u_cursorWorldPos"), 1, glm::value_ptr(cursorWorldPos));
            glUniform1f(glGetUniformLocation(axisShaderProgram, "u_cursorRadius"), cursorRadius);
            glUniform1f(glGetUniformLocation(axisShaderProgram, "u_intensity"), intensity);
            const float baseFadeStart = 0.5f, baseFadeEnd = 4.0f, baseHoleStart = 0.25f, baseHoleEnd = 0.75f;
            glUniform1f(glGetUniformLocation(axisShaderProgram, "u_fadeStart"), baseFadeStart * distanceScale);
            glUniform1f(glGetUniformLocation(axisShaderProgram, "u_fadeEnd"), baseFadeEnd * distanceScale);
            glUniform1f(glGetUniformLocation(axisShaderProgram, "u_holeStart"), baseHoleStart * distanceScale);
            glUniform1f(glGetUniformLocation(axisShaderProgram, "u_holeEnd"), baseHoleEnd * distanceScale);
            glUniform4fv(glGetUniformLocation(axisShaderProgram, "u_positiveFadeColor"), 1, glm::value_ptr(positiveAxisFadeColor));
            glUniform4fv(glGetUniformLocation(axisShaderProgram, "u_negativeFadeColor"), 1, glm::value_ptr(negativeAxisFadeColor));
            glBindVertexArray(axesVAO);
            glLineWidth(negAxisLineWidth); glDrawArrays(GL_LINES, 2, 2); glDrawArrays(GL_LINES, 6, 2); glDrawArrays(GL_LINES, 10, 2);
            glLineWidth(axisLineWidth); glDrawArrays(GL_LINES, 0, 2); glDrawArrays(GL_LINES, 4, 2); glDrawArrays(GL_LINES, 8, 2);
            glBindVertexArray(0);
        }

        // --- FIX: Disable depth test for snap markers ---
        glDisable(GL_DEPTH_TEST);
        DrawSnapMarker(currentSnap, camera, view, projection, display_w, display_h);
        glEnable(GL_DEPTH_TEST);

        glDepthMask(GL_TRUE);

        glLineWidth(1.0f);
        glUseProgram(0);
        ImGui_ImplOpenGL3_RenderDrawData(imguiDrawData);
    }
    bool Renderer::CreateShaderPrograms() {
        // Object Shader
        { GLuint vs = CompileShader(GL_VERTEX_SHADER, objectVertexShaderSource); GLuint fs = CompileShader(GL_FRAGMENT_SHADER, objectFragmentShaderSource); if (vs != 0 && fs != 0) objectShaderProgram = LinkShaderProgram(vs, fs); if (objectShaderProgram == 0) return false; std::cout << "Renderer: Object shader program created." << std::endl; }
        // Simple Line Shader
        { GLuint vs = CompileShader(GL_VERTEX_SHADER, simpleLineVertexShaderSource); GLuint fs = CompileShader(GL_FRAGMENT_SHADER, simpleLineFragmentShaderSource); if (vs != 0 && fs != 0) simpleLineShaderProgram = LinkShaderProgram(vs, fs); if (simpleLineShaderProgram == 0) return false; std::cout << "Renderer: Simple Line shader program created." << std::endl; }
        // Grid Shader
        { GLuint vs = CompileShader(GL_VERTEX_SHADER, gridVertexShaderSource); GLuint fs = CompileShader(GL_FRAGMENT_SHADER, gridFragmentShaderSource); if (vs != 0 && fs != 0) gridShaderProgram = LinkShaderProgram(vs, fs); if (gridShaderProgram == 0) return false; std::cout << "Renderer: Grid shader program created." << std::endl; }
        // Axis Shader
        { GLuint vs = CompileShader(GL_VERTEX_SHADER, axisVertexShaderSource); GLuint fs = CompileShader(GL_FRAGMENT_SHADER, axisFragmentShaderSource); if (vs != 0 && fs != 0) axisShaderProgram = LinkShaderProgram(vs, fs); if (axisShaderProgram == 0) return false; std::cout << "Renderer: Axis shader program created." << std::endl; }
        // Unlit Shader
        { GLuint vs = CompileShader(GL_VERTEX_SHADER, unlitVertexShaderSource); GLuint fs = CompileShader(GL_FRAGMENT_SHADER, unlitFragmentShaderSource); if (vs != 0 && fs != 0) unlitShaderProgram = LinkShaderProgram(vs, fs); if (unlitShaderProgram == 0) return false; std::cout << "Renderer: Unlit shader program created." << std::endl; }
        // Splat Shader
        { GLuint vs = CompileShader(GL_VERTEX_SHADER, splatVertexShaderSource); GLuint fs = CompileShader(GL_FRAGMENT_SHADER, splatFragmentShaderSource); if (vs != 0 && fs != 0) splatShaderProgram = LinkShaderProgram(vs, fs); if (splatShaderProgram == 0) return false; std::cout << "Renderer: Splat shader program created." << std::endl; }
        // Marker Shader
        { GLuint vs = CompileShader(GL_VERTEX_SHADER, markerVertexShaderSource); GLuint fs = CompileShader(GL_FRAGMENT_SHADER, markerFragmentShaderSource); if (vs != 0 && fs != 0) markerShaderProgram = LinkShaderProgram(vs, fs); if (markerShaderProgram == 0) { std::cerr << "Renderer Error: Failed to link marker shader program!" << std::endl; return false; } std::cout << "Renderer: Marker shader program created." << std::endl; }
        // Dashed Line Shader
        { GLuint vs = CompileShader(GL_VERTEX_SHADER, dashedLineVertexShaderSource); GLuint fs = CompileShader(GL_FRAGMENT_SHADER, dashedLineFragmentShaderSource); if (vs != 0 && fs != 0) dashedLineShaderProgram = LinkShaderProgram(vs, fs); if (dashedLineShaderProgram == 0) return false; std::cout << "Renderer: Dashed Line shader program created." << std::endl; }
        return true;
    }
    bool Renderer::CreateGridResources() {
        std::vector<float> gridVertices = GenerateGridVertices(gridSizeF, gridSteps);
        if (gridVertices.empty()) {
            std::cerr << "Renderer Error: Failed to generate grid vertices!" << std::endl;
            return false;
        }
        gridVertexCount = static_cast<int>(gridVertices.size() / 3);

        glGenVertexArrays(1, &gridVAO);
        glGenBuffers(1, &gridVBO);
        glBindVertexArray(gridVAO);
        glBindBuffer(GL_ARRAY_BUFFER, gridVBO);
        glBufferData(GL_ARRAY_BUFFER, gridVertices.size() * sizeof(float), gridVertices.data(), GL_STATIC_DRAW);
        // Only position attribute is needed now
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
        glEnableVertexAttribArray(0);
        glBindBuffer(GL_ARRAY_BUFFER, 0);
        glBindVertexArray(0);
        std::cout << "Renderer: Grid VAO/VBO created (" << gridVertexCount << " vertices)." << std::endl;
        return gridVAO != 0 && gridVBO != 0;
    }
    bool Renderer::CreateAxesResources() {
        glm::vec4 colorX(0.7f, 0.2f, 0.2f, 1.0f);
        glm::vec4 colorY(0.2f, 0.7f, 0.2f, 1.0f);
        glm::vec4 colorZ(0.2f, 0.2f, 0.7f, 1.0f);
        glm::vec4 posFadeColor(1.0f, 1.0f, 1.0f, 1.0f);
        glm::vec4 negFadeColor(1.0f, 1.0f, 1.0f, 0.4f);

        std::vector<float> verticesX = GenerateSingleAxisVertices(axisLength, glm::vec3(1, 0, 0), colorX, posFadeColor, negFadeColor);
        std::vector<float> verticesY = GenerateSingleAxisVertices(axisLength, glm::vec3(0, 1, 0), colorY, posFadeColor, negFadeColor);
        std::vector<float> verticesZ = GenerateSingleAxisVertices(axisLength, glm::vec3(0, 0, 1), colorZ, posFadeColor, negFadeColor);

        axisVertexCountX = 4;
        axisVertexCountY = 4;
        axisVertexCountZ = 4;
        
        std::vector<float> allAxesVertices;
        allAxesVertices.insert(allAxesVertices.end(), verticesX.begin(), verticesX.end());
        allAxesVertices.insert(allAxesVertices.end(), verticesY.begin(), verticesY.end());
        allAxesVertices.insert(allAxesVertices.end(), verticesZ.begin(), verticesZ.end());

        if (allAxesVertices.empty()) {
            std::cerr << "Renderer Error: Failed to generate axes vertices!" << std::endl;
            return false;
        }

        glGenVertexArrays(1, &axesVAO);
        glGenBuffers(1, &axesVBO);
        glBindVertexArray(axesVAO);
        glBindBuffer(GL_ARRAY_BUFFER, axesVBO);
        glBufferData(GL_ARRAY_BUFFER, allAxesVertices.size() * sizeof(float), allAxesVertices.data(), GL_DYNAMIC_DRAW);
        
        // Position
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 7 * sizeof(float), (void*)0);
        glEnableVertexAttribArray(0);
        // Color
        glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 7 * sizeof(float), (void*)(3 * sizeof(float)));
        glEnableVertexAttribArray(1);

        glBindBuffer(GL_ARRAY_BUFFER, 0);
        glBindVertexArray(0);
        std::cout << "Renderer: Axes VAO/VBO created." << std::endl;
        return axesVAO != 0 && axesVBO != 0;
    }
    bool Renderer::CreateSplatResources() { /* ... same ... */ std::vector<float> quadVertices = GenerateQuadVertices(2.0f); unsigned int quadIndices[] = { 0, 1, 2, 0, 2, 3 }; glGenVertexArrays(1, &splatVAO); glGenBuffers(1, &splatVBO); glGenBuffers(1, &splatEBO); glBindVertexArray(splatVAO); glBindBuffer(GL_ARRAY_BUFFER, splatVBO); glBufferData(GL_ARRAY_BUFFER, quadVertices.size() * sizeof(float), quadVertices.data(), GL_STATIC_DRAW); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, splatEBO); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(quadIndices), quadIndices, GL_STATIC_DRAW); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float))); glEnableVertexAttribArray(1); glBindVertexArray(0); std::cout << "Renderer: Splat VAO/VBO/EBO created." << std::endl; return splatVAO != 0 && splatVBO != 0 && splatEBO != 0; }
    bool Renderer::CreateUserLinesResources() { /* ... same ... */ glGenVertexArrays(1, &userLinesVAO); glGenBuffers(1, &userLinesVBO); glBindVertexArray(userLinesVAO); glBindBuffer(GL_ARRAY_BUFFER, userLinesVBO); const size_t maxLinePoints = 400; glBufferData(GL_ARRAY_BUFFER, maxLinePoints * 7 * sizeof(float), nullptr, GL_DYNAMIC_DRAW); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 7 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 7 * sizeof(float), (void*)(3 * sizeof(float))); glEnableVertexAttribArray(1); glBindBuffer(GL_ARRAY_BUFFER, 0); glBindVertexArray(0); std::cout << "Renderer: User Lines VAO/VBO created." << std::endl; return userLinesVAO != 0 && userLinesVBO != 0; }
    void Renderer::UpdateUserLinesBuffer(const std::map<uint64_t, Engine::Line>& lines, const std::set<uint64_t>& selectedLineIDs) {
        if (userLinesVBO == 0) {
            userLinesVertexCount = 0;
            return;
        }
        
        if (lines.empty()) {
            userLinesVertexCount = 0;
            return;
        }
        
        std::vector<float> lineData;
        lineData.reserve(lines.size() * 2 * 7);
        
        for (const auto& [lineID, line] : lines) {
            glm::vec4 currentColor = userLineColor;
            if (selectedLineIDs.find(lineID) != selectedLineIDs.end()) {
                currentColor = selectedUserLineColor;
            }
            
            // Start point
            lineData.push_back(line.start.x);
            lineData.push_back(line.start.y);
            lineData.push_back(line.start.z);
            lineData.push_back(currentColor.r);
            lineData.push_back(currentColor.g);
            lineData.push_back(currentColor.b);
            lineData.push_back(currentColor.a);
            
            // End point
            lineData.push_back(line.end.x);
            lineData.push_back(line.end.y);
            lineData.push_back(line.end.z);
            lineData.push_back(currentColor.r);
            lineData.push_back(currentColor.g);
            lineData.push_back(currentColor.b);
            lineData.push_back(currentColor.a);
        }
        
        glBindBuffer(GL_ARRAY_BUFFER, userLinesVBO);
        glBufferData(GL_ARRAY_BUFFER, lineData.size() * sizeof(float), lineData.data(), GL_DYNAMIC_DRAW);
        glBindBuffer(GL_ARRAY_BUFFER, 0);
        userLinesVertexCount = static_cast<int>(lineData.size() / 7);
    }
    bool Renderer::CreateMarkerResources() { /* ... same ... */ std::vector<float> circleVertices = GenerateCircleVertices(24); if (circleVertices.empty()) return false; markerVertexCounts[MarkerShape::CIRCLE] = static_cast<int>(circleVertices.size() / 2); glGenVertexArrays(1, &markerVAOs[MarkerShape::CIRCLE]); glGenBuffers(1, &markerVBOs[MarkerShape::CIRCLE]); glBindVertexArray(markerVAOs[MarkerShape::CIRCLE]); glBindBuffer(GL_ARRAY_BUFFER, markerVBOs[MarkerShape::CIRCLE]); glBufferData(GL_ARRAY_BUFFER, circleVertices.size() * sizeof(float), circleVertices.data(), GL_STATIC_DRAW); glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); glBindVertexArray(0); std::cout << "Renderer: Circle Marker VAO/VBO created (" << markerVertexCounts[MarkerShape::CIRCLE] << " vertices)." << std::endl; std::vector<float> diamondVertices = GenerateDiamondVertices(); if (diamondVertices.empty()) return false; markerVertexCounts[MarkerShape::DIAMOND] = static_cast<int>(diamondVertices.size() / 2); glGenVertexArrays(1, &markerVAOs[MarkerShape::DIAMOND]); glGenBuffers(1, &markerVBOs[MarkerShape::DIAMOND]); glBindVertexArray(markerVAOs[MarkerShape::DIAMOND]); glBindBuffer(GL_ARRAY_BUFFER, markerVBOs[MarkerShape::DIAMOND]); glBufferData(GL_ARRAY_BUFFER, diamondVertices.size() * sizeof(float), diamondVertices.data(), GL_STATIC_DRAW); glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); glBindVertexArray(0); std::cout << "Renderer: Diamond Marker VAO/VBO created (" << markerVertexCounts[MarkerShape::DIAMOND] << " vertices)." << std::endl; return true; }
    void Renderer::DrawSnapMarker(const SnapResult& snap, const Camera& camera, const glm::mat4& view, const glm::mat4& proj, int screenWidth, int screenHeight) { /* ... same ... */ if (!snap.snapped || markerShaderProgram == 0) return; MarkerShape shape = MarkerShape::CIRCLE; glm::vec4 color = snapMarkerColorPoint; float currentMarkerSize = markerScreenSize; switch (snap.type) { case SnapType::ENDPOINT: case SnapType::ORIGIN: shape = MarkerShape::CIRCLE; color = snapMarkerColorPoint; currentMarkerSize = markerScreenSize; break; case SnapType::MIDPOINT: shape = MarkerShape::CIRCLE; color = snapMarkerColorMidpoint; currentMarkerSize = markerScreenSizeMidpoint; break; case SnapType::ON_EDGE: shape = MarkerShape::DIAMOND; color = snapMarkerColorOnEdge; currentMarkerSize = markerScreenSizeOnEdge; break; case SnapType::AXIS_X: shape = MarkerShape::DIAMOND; color = snapMarkerColorAxisX; currentMarkerSize = markerScreenSize; break; case SnapType::AXIS_Y: shape = MarkerShape::DIAMOND; color = snapMarkerColorAxisY; currentMarkerSize = markerScreenSize; break; case SnapType::AXIS_Z: shape = MarkerShape::DIAMOND; color = snapMarkerColorAxisZ; currentMarkerSize = markerScreenSize; break; case SnapType::ON_FACE: shape = MarkerShape::CIRCLE; color = snapMarkerColorOnEdge; /* Using OnEdge magenta for now, define snapMarkerColorOnFace later */ currentMarkerSize = markerScreenSize; break; default: return; } if (markerVAOs.find(shape) == markerVAOs.end()) return; GLuint vao = markerVAOs[shape]; int vertexCount = markerVertexCounts[shape]; if (vao == 0 || vertexCount == 0) return; glUseProgram(markerShaderProgram); glUniform3fv(glGetUniformLocation(markerShaderProgram, "u_WorldPos"), 1, glm::value_ptr(snap.worldPoint)); glUniform1f(glGetUniformLocation(markerShaderProgram, "u_ScreenSize"), currentMarkerSize); glUniformMatrix4fv(glGetUniformLocation(markerShaderProgram, "u_ViewMatrix"), 1, GL_FALSE, glm::value_ptr(view)); glUniformMatrix4fv(glGetUniformLocation(markerShaderProgram, "u_ProjMatrix"), 1, GL_FALSE, glm::value_ptr(proj)); glUniform2f(glGetUniformLocation(markerShaderProgram, "u_ViewportSize"), (float)screenWidth, (float)screenHeight); glUniform4fv(glGetUniformLocation(markerShaderProgram, "u_Color"), 1, glm::value_ptr(color)); glBindVertexArray(vao); if (shape == MarkerShape::CIRCLE) { glDrawArrays(GL_TRIANGLE_FAN, 0, vertexCount); } else if (shape == MarkerShape::DIAMOND) { glLineWidth(2.0f); glDrawArrays(GL_LINE_LOOP, 0, vertexCount -1); } glBindVertexArray(0); glLineWidth(1.0f); }
    void Renderer::Cleanup() {
        std::cout << "Renderer: Cleaning up resources..." << std::endl;
        if (gridVAO != 0) glDeleteVertexArrays(1, &gridVAO); gridVAO = 0; if (gridVBO != 0) glDeleteBuffers(1, &gridVBO); gridVBO = 0;
        if (axesVAO != 0) glDeleteVertexArrays(1, &axesVAO); axesVAO = 0; if (axesVBO != 0) glDeleteBuffers(1, &axesVBO); axesVBO = 0;
        if (splatVAO != 0) glDeleteVertexArrays(1, &splatVAO); splatVAO = 0; if (splatVBO != 0) glDeleteBuffers(1, &splatVBO); splatVBO = 0; if (splatEBO != 0) glDeleteBuffers(1, &splatEBO); splatEBO = 0;
        if (userLinesVAO != 0) glDeleteVertexArrays(1, &userLinesVAO); userLinesVAO = 0; if (userLinesVBO != 0) glDeleteBuffers(1, &userLinesVBO); userLinesVBO = 0;
        if (previewVAO != 0) glDeleteVertexArrays(1, &previewVAO); previewVAO = 0; if (previewVBO != 0) glDeleteBuffers(1, &previewVBO); previewVBO = 0;
        if (previewLineVAO != 0) glDeleteVertexArrays(1, &previewLineVAO); previewLineVAO = 0; if (previewLineVBO != 0) glDeleteBuffers(1, &previewLineVBO); previewLineVBO = 0;
        if (previewOutlineVAO != 0) glDeleteVertexArrays(1, &previewOutlineVAO); previewOutlineVAO = 0; if (previewOutlineVBO != 0) glDeleteBuffers(1, &previewOutlineVBO); previewOutlineVBO = 0;
        for (auto const& [shape, vao] : markerVAOs) { if (vao != 0) glDeleteVertexArrays(1, &vao); } markerVAOs.clear();
        for (auto const& [shape, vbo] : markerVBOs) { if (vbo != 0) glDeleteBuffers(1, &vbo); } markerVBOs.clear();
        markerVertexCounts.clear();
        if (objectShaderProgram != 0) glDeleteProgram(objectShaderProgram); objectShaderProgram = 0;
        if (simpleLineShaderProgram != 0) glDeleteProgram(simpleLineShaderProgram); simpleLineShaderProgram = 0;
        if (gridShaderProgram != 0) glDeleteProgram(gridShaderProgram); gridShaderProgram = 0;
        if (axisShaderProgram != 0) glDeleteProgram(axisShaderProgram); axisShaderProgram = 0;
        if (unlitShaderProgram != 0) glDeleteProgram(unlitShaderProgram); unlitShaderProgram = 0;
        if (splatShaderProgram != 0) glDeleteProgram(splatShaderProgram); splatShaderProgram = 0;
        if (markerShaderProgram != 0) glDeleteProgram(markerShaderProgram); markerShaderProgram = 0;
        if (dashedLineShaderProgram != 0) glDeleteProgram(dashedLineShaderProgram); dashedLineShaderProgram = 0;
        std::cout << "Renderer: Resource cleanup finished." << std::endl;
    }

    bool Renderer::CreatePreviewResources() {
        glGenVertexArrays(1, &previewVAO);
        glGenBuffers(1, &previewVBO);
        glBindVertexArray(previewVAO);
        glBindBuffer(GL_ARRAY_BUFFER, previewVBO);
        // Allocate a large buffer for dynamic drawing
        glBufferData(GL_ARRAY_BUFFER, 10000 * sizeof(float), nullptr, GL_DYNAMIC_DRAW);
        // Position attribute
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
        glEnableVertexAttribArray(0);
        // Normal attribute
        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));
        glEnableVertexAttribArray(1);
        glBindVertexArray(0);
        std::cout << "Renderer: Preview VAO/VBO created." << std::endl;
        return previewVAO != 0 && previewVBO != 0;
    }

    bool Renderer::CreatePreviewLineResources() {
        glGenVertexArrays(1, &previewLineVAO);
        glGenBuffers(1, &previewLineVBO);
        glBindVertexArray(previewLineVAO);
        glBindBuffer(GL_ARRAY_BUFFER, previewLineVBO);
        // Buffer for a single line (2 vertices, 7 floats each: position + color)
        glBufferData(GL_ARRAY_BUFFER, 2 * 7 * sizeof(float), nullptr, GL_DYNAMIC_DRAW);
        // Position attribute
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 7 * sizeof(float), (void*)0);
        glEnableVertexAttribArray(0);
        // Color attribute
        glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 7 * sizeof(float), (void*)(3 * sizeof(float)));
        glEnableVertexAttribArray(1);
        glBindVertexArray(0);
        previewLineEnabled = false;
        std::cout << "Renderer: Preview Line VAO/VBO created." << std::endl;
        return previewLineVAO != 0 && previewLineVBO != 0;
    }

    bool Renderer::CreatePreviewOutlineResources() {
        glGenVertexArrays(1, &previewOutlineVAO);
        glGenBuffers(1, &previewOutlineVBO);
        glBindVertexArray(previewOutlineVAO);
        glBindBuffer(GL_ARRAY_BUFFER, previewOutlineVBO);
        // Allocate a large buffer for dynamic drawing. 4 floats per vertex (pos.xyz, dist.w)
        glBufferData(GL_ARRAY_BUFFER, 10000 * sizeof(float), nullptr, GL_DYNAMIC_DRAW);
        // Position attribute (vec3)
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)0);
        glEnableVertexAttribArray(0);
        // Distance attribute (float)
        glVertexAttribPointer(1, 1, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)(3 * sizeof(float)));
        glEnableVertexAttribArray(1);
        glBindVertexArray(0);
        std::cout << "Renderer: Preview Outline VAO/VBO created." << std::endl;
        return previewOutlineVAO != 0 && previewOutlineVBO != 0;
    }

    void Renderer::UpdatePushPullPreview(const Engine::SceneObject& object, const std::vector<size_t>& faceIndices, const glm::vec3& direction, float distance) {
        // 1. Initial checks
        if (faceIndices.empty() || std::abs(distance) < 1e-4) {
            previewVertexCount = 0;
            previewOutlineVertexCount = 0;
            return;
        }
        const auto& mesh = object.get_mesh_buffers();
        if (!object.has_mesh()) {
            previewVertexCount = 0;
            previewOutlineVertexCount = 0;
            return;
        }

        // 2. Find boundary edges and vertices of the selected face patch
        std::map<std::pair<unsigned int, unsigned int>, int> edgeCounts;
        std::set<unsigned int> boundaryVertexIndices;
        for (size_t baseIndex : faceIndices) {
            if (baseIndex + 2 >= mesh.indices.size()) continue;

            unsigned int v_indices[3] = { mesh.indices[baseIndex], mesh.indices[baseIndex + 1], mesh.indices[baseIndex + 2] };
            for (int j = 0; j < 3; ++j) {
                unsigned int v1_idx = v_indices[j];
                unsigned int v2_idx = v_indices[(j + 1) % 3];
                if (v1_idx > v2_idx) std::swap(v1_idx, v2_idx);
                edgeCounts[{v1_idx, v2_idx}]++;
            }
        }

        std::vector<std::pair<unsigned int, unsigned int>> boundaryEdges;
        for (const auto& [edge, count] : edgeCounts) {
            if (count == 1) {
                boundaryEdges.push_back(edge);
                boundaryVertexIndices.insert(edge.first);
                boundaryVertexIndices.insert(edge.second);
            }
        }

        // 3. Generate preview vertices for both solid fill and dashed outline
        std::vector<float> solidVertices;
        std::vector<float> outlineVertices;
        glm::vec3 offset = direction * distance;
        
        // 3a. Generate top cap (for solid fill)
        for (size_t baseIndex : faceIndices) {
            if (baseIndex + 2 >= mesh.indices.size()) continue;
            unsigned int i0 = mesh.indices[baseIndex], i1 = mesh.indices[baseIndex+1], i2 = mesh.indices[baseIndex+2];
            glm::vec3 v0d = glm::vec3(mesh.vertices[i0*3], mesh.vertices[i0*3+1], mesh.vertices[i0*3+2]) + offset;
            glm::vec3 v1d = glm::vec3(mesh.vertices[i1*3], mesh.vertices[i1*3+1], mesh.vertices[i1*3+2]) + offset;
            glm::vec3 v2d = glm::vec3(mesh.vertices[i2*3], mesh.vertices[i2*3+1], mesh.vertices[i2*3+2]) + offset;
            solidVertices.insert(solidVertices.end(), {v0d.x, v0d.y, v0d.z, direction.x, direction.y, direction.z});
            solidVertices.insert(solidVertices.end(), {v1d.x, v1d.y, v1d.z, direction.x, direction.y, direction.z});
            solidVertices.insert(solidVertices.end(), {v2d.x, v2d.y, v2d.z, direction.x, direction.y, direction.z});
        }

        // 3b. Generate side walls (solid fill) from boundary edges
        for (const auto& edge : boundaryEdges) {
            glm::vec3 p1(mesh.vertices[edge.first*3], mesh.vertices[edge.first*3+1], mesh.vertices[edge.first*3+2]);
            glm::vec3 p2(mesh.vertices[edge.second*3], mesh.vertices[edge.second*3+1], mesh.vertices[edge.second*3+2]);
            glm::vec3 p1d = p1 + offset; glm::vec3 p2d = p2 + offset;
            glm::vec3 sideNormal = glm::normalize(glm::cross(p2 - p1, direction));
            solidVertices.insert(solidVertices.end(), {p1.x, p1.y, p1.z, sideNormal.x, sideNormal.y, sideNormal.z});
            solidVertices.insert(solidVertices.end(), {p2.x, p2.y, p2.z, sideNormal.x, sideNormal.y, sideNormal.z});
            solidVertices.insert(solidVertices.end(), {p1d.x, p1d.y, p1d.z, sideNormal.x, sideNormal.y, sideNormal.z});
            solidVertices.insert(solidVertices.end(), {p1d.x, p1d.y, p1d.z, sideNormal.x, sideNormal.y, sideNormal.z});
            solidVertices.insert(solidVertices.end(), {p2.x, p2.y, p2.z, sideNormal.x, sideNormal.y, sideNormal.z});
            solidVertices.insert(solidVertices.end(), {p2d.x, p2d.y, p2d.z, sideNormal.x, sideNormal.y, sideNormal.z});
        }
        
        // 3c. Generate outline edges (dashed)
        // Top and bottom outlines
        for (const auto& edge : boundaryEdges) {
            glm::vec3 p1(mesh.vertices[edge.first*3], mesh.vertices[edge.first*3+1], mesh.vertices[edge.first*3+2]);
            glm::vec3 p2(mesh.vertices[edge.second*3], mesh.vertices[edge.second*3+1], mesh.vertices[edge.second*3+2]);
            float len = glm::distance(p1, p2);
            // Bottom edge
            outlineVertices.insert(outlineVertices.end(), {p1.x, p1.y, p1.z, 0.0f});
            outlineVertices.insert(outlineVertices.end(), {p2.x, p2.y, p2.z, len});
            // Top edge
            glm::vec3 p1d = p1 + offset; glm::vec3 p2d = p2 + offset;
            outlineVertices.insert(outlineVertices.end(), {p1d.x, p1d.y, p1d.z, 0.0f});
            outlineVertices.insert(outlineVertices.end(), {p2d.x, p2d.y, p2d.z, len});
        }
        // Vertical corner outlines
        float verticalLen = std::abs(distance);
        for (unsigned int v_idx : boundaryVertexIndices) {
            glm::vec3 p(mesh.vertices[v_idx*3], mesh.vertices[v_idx*3+1], mesh.vertices[v_idx*3+2]);
            glm::vec3 pd = p + offset;
            outlineVertices.insert(outlineVertices.end(), {p.x, p.y, p.z, 0.0f});
            outlineVertices.insert(outlineVertices.end(), {pd.x, pd.y, pd.z, verticalLen});
        }

        // 4. Update GPU buffers
        previewVertexCount = solidVertices.size() / 6;
        if (previewVertexCount > 0) {
            glBindBuffer(GL_ARRAY_BUFFER, previewVBO);
            glBufferData(GL_ARRAY_BUFFER, solidVertices.size() * sizeof(float), solidVertices.data(), GL_DYNAMIC_DRAW);
            glBindBuffer(GL_ARRAY_BUFFER, 0);
        }
        previewOutlineVertexCount = outlineVertices.size() / 4;
        if (previewOutlineVertexCount > 0) {
            glBindBuffer(GL_ARRAY_BUFFER, previewOutlineVBO);
            glBufferData(GL_ARRAY_BUFFER, outlineVertices.size() * sizeof(float), outlineVertices.data(), GL_DYNAMIC_DRAW);
            glBindBuffer(GL_ARRAY_BUFFER, 0);
        }
    }

    void Renderer::UpdatePreviewLine(const glm::vec3& start, const glm::vec3& end, bool enabled) {
        previewLineEnabled = enabled;
        if (!enabled || previewLineVBO == 0) {
            return;
        }

        float lineData[] = {
            start.x, start.y, start.z, userLineColor.r, userLineColor.g, userLineColor.b, userLineColor.a,
            end.x,   end.y,   end.z,   userLineColor.r, userLineColor.g, userLineColor.b, userLineColor.a
        };

        glBindBuffer(GL_ARRAY_BUFFER, previewLineVBO);
        glBufferData(GL_ARRAY_BUFFER, sizeof(lineData), lineData, GL_DYNAMIC_DRAW);
        glBindBuffer(GL_ARRAY_BUFFER, 0);
    }

    void Renderer::UpdateAxesVBO(const glm::vec4& colorX, const glm::vec4& colorY, const glm::vec4& colorZ, const glm::vec4& posFadeColor, const glm::vec4& negFadeColor) {
        std::vector<float> verticesX = GenerateSingleAxisVertices(axisLength, glm::vec3(1, 0, 0), colorX, posFadeColor, negFadeColor);
        std::vector<float> verticesY = GenerateSingleAxisVertices(axisLength, glm::vec3(0, 1, 0), colorY, posFadeColor, negFadeColor);
        std::vector<float> verticesZ = GenerateSingleAxisVertices(axisLength, glm::vec3(0, 0, 1), colorZ, posFadeColor, negFadeColor);
        
        // Each axis now has 4 vertices (2 for positive, 2 for negative)
        axisVertexCountX = 4; 
        axisVertexCountY = 4;
        axisVertexCountZ = 4;

        std::vector<float> allAxesVertices;
        allAxesVertices.insert(allAxesVertices.end(), verticesX.begin(), verticesX.end());
        allAxesVertices.insert(allAxesVertices.end(), verticesY.begin(), verticesY.end());
        allAxesVertices.insert(allAxesVertices.end(), verticesZ.begin(), verticesZ.end());

        glBindBuffer(GL_ARRAY_BUFFER, axesVBO);
        glBufferData(GL_ARRAY_BUFFER, allAxesVertices.size() * sizeof(float), allAxesVertices.data(), GL_DYNAMIC_DRAW);
        glBindBuffer(GL_ARRAY_BUFFER, 0);
    }

} // namespace Urbaxio
ENCODINGUTF8ENCODINGUTF8--- File: shell/src/snapping.cpp ---
ENCODINGUTF8#include "snapping.h"
#include "camera.h"
#include <engine/scene.h>
#include <engine/scene_object.h>
#include <cad_kernel/MeshBuffers.h>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/geometric.hpp>
#include <glm/gtx/norm.hpp>
#include <glm/gtx/vector_query.hpp>
#include <limits>
#include <cmath>
#include <iostream>
#include <vector>
#include <algorithm>
#include <utility>

namespace { // Anonymous namespace for utility functions
    const float LINE_RAY_EPSILON = 1e-6f;
    const float SCREEN_EPSILON = 1e-4f;
    const float DEPTH_TOLERANCE = 1e-4f; // Epsilon for depth comparison
    
    // Calculates the closest points between a ray and a line segment in 3D space.
    bool ClosestPointsRaySegment(
        const glm::vec3& rayOrigin, const glm::vec3& rayDir,
        const glm::vec3& segStart, const glm::vec3& segEnd,
        glm::vec3& outPointOnRay,
        glm::vec3& outPointOnSegment
    ) {
        glm::vec3 segDir = segEnd - segStart;
        
        glm::vec3 w = rayOrigin - segStart;
        float a = glm::dot(rayDir, rayDir);      // Should be 1.0 if rayDir is normalized
        float b = glm::dot(rayDir, segDir);
        float c = glm::dot(segDir, segDir);      // Same as segLenSq
        float d = glm::dot(rayDir, w);
        float e = glm::dot(segDir, w);

        float denom = a * c - b * b;
        float t_ray, t_seg;

        // If the lines are parallel or nearly parallel
        if (std::abs(denom) < LINE_RAY_EPSILON) {
            t_ray = 0.0f; // Any point on the ray is fine, let's use the origin
            t_seg = -e / c; // Project ray origin onto the segment's line
        } else {
            t_ray = (b * e - c * d) / denom;
            t_seg = (a * e - b * d) / denom;
        }

        // Clamp the segment parameter to the range [0, 1] to stay on the segment
        t_seg = std::max(0.0f, std::min(1.0f, t_seg));

        outPointOnRay = rayOrigin + t_ray * rayDir;
        outPointOnSegment = segStart + t_seg * segDir;

        return true;
    }

    glm::vec3 ClosestPointOnLine(const glm::vec3& lineOrigin, const glm::vec3& lineDir, const glm::vec3& point) { float t = glm::dot(point - lineOrigin, lineDir); return lineOrigin + lineDir * t; }
    // --- FIX: Restore the missing helper function ---
    bool ClosestPointLineLine( const glm::vec3& o1, const glm::vec3& d1, const glm::vec3& o2, const glm::vec3& d2, glm::vec3& outPointOnL1) { glm::vec3 w = o1 - o2; float b = glm::dot(d1, d2); float d_dot = glm::dot(d1, w); float e_dot = glm::dot(d2, w); float denom = 1.0f - b * b; if (std::abs(denom) < LINE_RAY_EPSILON) { outPointOnL1 = ClosestPointOnLine(o1, d1, o2); return true; } float s = (b * e_dot - d_dot) / denom; outPointOnL1 = o1 + s * d1; return true; }
    bool WorldToScreen(const glm::vec3& worldPos, const glm::mat4& viewMatrix, const glm::mat4& projectionMatrix, int screenWidth, int screenHeight, glm::vec2& outScreenPos) { if (screenWidth <= 0 || screenHeight <= 0) return false; glm::vec4 clipPos = projectionMatrix * viewMatrix * glm::vec4(worldPos, 1.0f); if (clipPos.w <= SCREEN_EPSILON) { return false; } glm::vec3 ndcPos = glm::vec3(clipPos) / clipPos.w; outScreenPos.x = (ndcPos.x + 1.0f) * 0.5f * static_cast<float>(screenWidth); outScreenPos.y = (1.0f - ndcPos.y) * 0.5f * static_cast<float>(screenHeight); return true; }
    bool RaycastToZPlane(int mouseX, int mouseY, int screenWidth, int screenHeight, const Urbaxio::Camera& camera, glm::vec3& outIntersectionPoint) { glm::vec3 rayOrigin, rayDirection; glm::mat4 view = camera.GetViewMatrix(); glm::mat4 projection = camera.GetProjectionMatrix((screenHeight > 0) ? ((float)screenWidth / (float)screenHeight) : 1.0f); Urbaxio::Camera::ScreenToWorldRay(mouseX, mouseY, screenWidth, screenHeight, view, projection, rayOrigin, rayDirection); glm::vec3 planeNormal(0.0f, 0.0f, 1.0f); glm::vec3 pointOnPlane(0.0f, 0.0f, 0.0f); float dirDotNormal = glm::dot(rayDirection, planeNormal); if (std::abs(dirDotNormal) < LINE_RAY_EPSILON) { return false; } float t = glm::dot(pointOnPlane - rayOrigin, planeNormal) / dirDotNormal; if (t < 0.0f) { return false; } outIntersectionPoint = rayOrigin + rayDirection * t; return true; }
    struct SnapCandidate : public Urbaxio::SnapResult { float screenDistSq = std::numeric_limits<float>::max(); };
    
    int GetSnapPriority(Urbaxio::SnapType type) {
        switch (type) {
            case Urbaxio::SnapType::ENDPOINT:       return 10;
            case Urbaxio::SnapType::ORIGIN:         return 9;
            case Urbaxio::SnapType::MIDPOINT:       return 8;
            case Urbaxio::SnapType::INTERSECTION:   return 7;
            case Urbaxio::SnapType::CENTER:         return 7;
            case Urbaxio::SnapType::AXIS_X:         return 6; // FIX: Higher priority
            case Urbaxio::SnapType::AXIS_Y:         return 6; // FIX: Higher priority
            case Urbaxio::SnapType::AXIS_Z:         return 6; // FIX: Higher priority
            case Urbaxio::SnapType::ON_EDGE:        return 5; // FIX: Lower priority
            case Urbaxio::SnapType::ON_FACE:        return 3;
            case Urbaxio::SnapType::GRID:           return 1;
            case Urbaxio::SnapType::NONE:
            default:                                return 0;
        }
    }
} // end anonymous namespace


namespace Urbaxio {

    SnappingSystem::SnappingSystem() {}
    bool SnappingSystem::WorldToScreen(const glm::vec3& worldPos, const glm::mat4& viewMatrix, const glm::mat4& projectionMatrix, int screenWidth, int screenHeight, glm::vec2& outScreenPos) { return ::WorldToScreen(worldPos, viewMatrix, projectionMatrix, screenWidth, screenHeight, outScreenPos); }
    bool SnappingSystem::RaycastToZPlane(int mouseX, int mouseY, int screenWidth, int screenHeight, const Urbaxio::Camera& camera, glm::vec3& outIntersectionPoint) { return ::RaycastToZPlane(mouseX, mouseY, screenWidth, screenHeight, camera, outIntersectionPoint); }

    bool SnappingSystem::RayTriangleIntersect(
        const glm::vec3& rayOrigin, const glm::vec3& rayDirection,
        const glm::vec3& v0, const glm::vec3& v1, const glm::vec3& v2,
        float& t_intersection
    ) {
        const float EPSILON_INTERSECT = 1e-6f;
        glm::vec3 edge1 = v1 - v0;
        glm::vec3 edge2 = v2 - v0;
        glm::vec3 h = glm::cross(rayDirection, edge2);
        float a = glm::dot(edge1, h);
        if (a > -EPSILON_INTERSECT && a < EPSILON_INTERSECT) return false;
        float f = 1.0f / a;
        glm::vec3 s = rayOrigin - v0;
        float u = f * glm::dot(s, h);
        if (u < 0.0f || u > 1.0f) return false;
        glm::vec3 q = glm::cross(s, edge1);
        float v = f * glm::dot(rayDirection, q);
        if (v < 0.0f || u + v > 1.0f) return false;
        t_intersection = f * glm::dot(edge2, q);
        if (t_intersection > EPSILON_INTERSECT) return true;
        else return false;
    }


SnapResult SnappingSystem::FindSnapPoint(
    int mouseX, int mouseY,
    int screenWidth, int screenHeight,
    const Camera& camera,
    const Engine::Scene& scene,
    float snapThresholdPixels)
{
    SnapResult finalSnap;
    finalSnap.snapped = false;
    finalSnap.type = SnapType::NONE;
    float pointThresholdSq = snapThresholdPixels * snapThresholdPixels;
    float lineSnapThresholdSq = (snapThresholdPixels * 0.8f) * (snapThresholdPixels * 0.8f);
    if (lineSnapThresholdSq < 1.0f) lineSnapThresholdSq = 1.0f;

    glm::mat4 view = camera.GetViewMatrix();
    glm::mat4 proj = camera.GetProjectionMatrix((screenHeight > 0) ? ((float)screenWidth / (float)screenHeight) : 1.0f);
    glm::vec2 mousePosScreen(static_cast<float>(mouseX), static_cast<float>(mouseY));
    
    glm::vec3 rayOrigin, rayDirection; 
    Camera::ScreenToWorldRay(mouseX, mouseY, screenWidth, screenHeight, view, proj, rayOrigin, rayDirection);
    
    glm::vec3 pointOnPlane; 
    bool planeHit = RaycastToZPlane(mouseX, mouseY, screenWidth, screenHeight, camera, pointOnPlane);
    finalSnap.worldPoint = planeHit ? pointOnPlane : camera.Position + rayDirection * 10.0f;

    std::vector<SnapCandidate> candidates;

    // --- STEP 1: OCCLUSION PRE-PASS ---
    // Find the closest thing the user is pointing at.
    float min_hit_distance = std::numeric_limits<float>::max();
    SnapCandidate faceSnapCandidate;
    bool faceWasHit = false;

    std::vector<const Engine::SceneObject*> objects = scene.get_all_objects();
    for (const auto* obj : objects) {
        if (obj && obj->has_mesh()) {
            const auto& name = obj->get_name();
            if (name == "CenterMarker" || name == "UnitCapsuleMarker10m" || name == "UnitCapsuleMarker5m") continue;

            const auto& mesh = obj->get_mesh_buffers();
            for (size_t i = 0; i + 2 < mesh.indices.size(); i += 3) {
                unsigned int i0 = mesh.indices[i], i1 = mesh.indices[i+1], i2 = mesh.indices[i+2];
                glm::vec3 v0(mesh.vertices[i0*3], mesh.vertices[i0*3+1], mesh.vertices[i0*3+2]);
                glm::vec3 v1(mesh.vertices[i1*3], mesh.vertices[i1*3+1], mesh.vertices[i1*3+2]);
                glm::vec3 v2(mesh.vertices[i2*3], mesh.vertices[i2*3+1], mesh.vertices[i2*3+2]);
                float t;
                if (RayTriangleIntersect(rayOrigin, rayDirection, v0, v1, v2, t) && t > 0 && t < min_hit_distance) {
                    min_hit_distance = t;
                    faceSnapCandidate.snapped = true;
                    faceSnapCandidate.type = SnapType::ON_FACE;
                    faceSnapCandidate.worldPoint = rayOrigin + rayDirection * t;
                    faceSnapCandidate.snappedEntityId = obj->get_id();
                    faceWasHit = true;
                }
            }
        }
    }
    if (faceWasHit) {
        glm::vec2 screenPos;
        if(WorldToScreen(faceSnapCandidate.worldPoint, view, proj, screenWidth, screenHeight, screenPos)) {
            faceSnapCandidate.screenDistSq = glm::length2(mousePosScreen - screenPos);
            candidates.push_back(faceSnapCandidate);
        }
    }

    // --- STEP 2: GATHER CANDIDATES WITH DEPTH CHECKING ---

    // Origin
    glm::vec2 originScreenPos;
    if (WorldToScreen(glm::vec3(0.0f), view, proj, screenWidth, screenHeight, originScreenPos)) {
        float dist_along_ray = glm::dot(glm::vec3(0.0f) - rayOrigin, rayDirection);
        if (dist_along_ray < min_hit_distance + DEPTH_TOLERANCE) {
            float distSq = glm::length2(mousePosScreen - originScreenPos);
            if (distSq < pointThresholdSq) {
                candidates.push_back({ {true, glm::vec3(0.0f), SnapType::ORIGIN, 0}, distSq });
            }
        }
    }

    // User Lines
    const auto& lines = scene.GetAllLines();
    for (const auto& [lineId, line] : lines) {
        // Endpoints
        for (const auto& endpoint : {line.start, line.end}) {
            float dist_along_ray = glm::dot(endpoint - rayOrigin, rayDirection);
            if (dist_along_ray < min_hit_distance + DEPTH_TOLERANCE) {
                glm::vec2 scrPos;
                if (WorldToScreen(endpoint, view, proj, screenWidth, screenHeight, scrPos)) {
                    float dSq = glm::length2(mousePosScreen - scrPos);
                    if (dSq < pointThresholdSq) { candidates.push_back({{true, endpoint, SnapType::ENDPOINT, lineId}, dSq}); }
                }
            }
        }
        // Midpoint
        glm::vec3 midpoint = (line.start + line.end) * 0.5f;
        float dist_along_ray_mid = glm::dot(midpoint - rayOrigin, rayDirection);
        if (dist_along_ray_mid < min_hit_distance + DEPTH_TOLERANCE) {
            glm::vec2 scrPosMid;
            if (WorldToScreen(midpoint, view, proj, screenWidth, screenHeight, scrPosMid)) {
                float dSq = glm::length2(mousePosScreen - scrPosMid);
                if (dSq < pointThresholdSq) { candidates.push_back({{true, midpoint, SnapType::MIDPOINT, lineId}, dSq}); }
            }
        }
        // On Edge
        glm::vec3 closestPointOnRay, closestPointOnSegment;
        if (ClosestPointsRaySegment(rayOrigin, rayDirection, line.start, line.end, closestPointOnRay, closestPointOnSegment)) {
             float dist_along_ray_edge = glm::dot(closestPointOnSegment - rayOrigin, rayDirection);
             if (dist_along_ray_edge < min_hit_distance + DEPTH_TOLERANCE) {
                glm::vec2 screenSnapPos;
                if (WorldToScreen(closestPointOnSegment, view, proj, screenWidth, screenHeight, screenSnapPos)) {
                    float distSqToScreen = glm::length2(mousePosScreen - screenSnapPos);
                    if (distSqToScreen < lineSnapThresholdSq) {
                        candidates.push_back({ {true, closestPointOnSegment, SnapType::ON_EDGE, lineId}, distSqToScreen });
                    }
                }
            }
        }
    }

    // Object Vertices
    for (const auto* obj : objects) {
        if (obj && obj->has_mesh()) {
            const auto& name = obj->get_name();
            if (name == "CenterMarker" || name == "UnitCapsuleMarker10m" || name == "UnitCapsuleMarker5m") continue;
            
            const auto& vertices_obj = obj->get_mesh_buffers().vertices;
            for (size_t i = 0; i < vertices_obj.size(); i += 3) {
                glm::vec3 vertexPos(vertices_obj[i], vertices_obj[i+1], vertices_obj[i+2]);
                float dist_along_ray = glm::dot(vertexPos - rayOrigin, rayDirection);
                if (dist_along_ray < min_hit_distance + DEPTH_TOLERANCE) {
                    glm::vec2 scrPos;
                    if (WorldToScreen(vertexPos, view, proj, screenWidth, screenHeight, scrPos)) {
                        float dSq = glm::length2(mousePosScreen - scrPos);
                        if (dSq < pointThresholdSq) { candidates.push_back({{true, vertexPos, SnapType::ENDPOINT, obj->get_id()}, dSq}); }
                    }
                }
            }
        }
    }

    // Axes
    struct AxisInfo { glm::vec3 origin; glm::vec3 dir; SnapType type; };
    std::vector<AxisInfo> axes = {
        {glm::vec3(0.0f), glm::normalize(glm::vec3(1.0f, 0.0f, 0.0f)), SnapType::AXIS_X},
        {glm::vec3(0.0f), glm::normalize(glm::vec3(0.0f, 1.0f, 0.0f)), SnapType::AXIS_Y},
        {glm::vec3(0.0f), glm::normalize(glm::vec3(0.0f, 0.0f, 1.0f)), SnapType::AXIS_Z}
    };
    for (const auto& axis : axes) {
        glm::vec3 pointOnAxis3D;
        // --- FIX: Use ClosestPointLineLine for infinite axes ---
        if (ClosestPointLineLine(axis.origin, axis.dir, rayOrigin, rayDirection, pointOnAxis3D)) {
            // Check if axis point is in front of geometry
            float dist_along_ray = glm::dot(pointOnAxis3D - rayOrigin, rayDirection);
            if (dist_along_ray > 0 && dist_along_ray < min_hit_distance + DEPTH_TOLERANCE) {
                glm::vec2 axisPointScreenPos;
                if (WorldToScreen(pointOnAxis3D, view, proj, screenWidth, screenHeight, axisPointScreenPos)) {
                    float distSqScreen = glm::length2(mousePosScreen - axisPointScreenPos);
                    if (distSqScreen < lineSnapThresholdSq) {
                        candidates.push_back({ {true, pointOnAxis3D, axis.type, 0}, distSqScreen });
                    }
                }
            }
        }
    }
    
    // --- STEP 3: SELECT BEST CANDIDATE ---
    if (!candidates.empty()) {
        std::sort(candidates.begin(), candidates.end(), [](const SnapCandidate& a, const SnapCandidate& b) {
            int priorityA = GetSnapPriority(a.type);
            int priorityB = GetSnapPriority(b.type);
            if (priorityA != priorityB) return priorityA > priorityB;
            return a.screenDistSq < b.screenDistSq;
        });
        finalSnap = candidates[0];
    }
    return finalSnap;
}

} // namespace Urbaxio
ENCODINGUTF8ENCODINGUTF8--- File: shell/include/tools/ITool.h ---
ENCODINGUTF8#pragma once

#include <glm/glm.hpp>
#include <SDL2/SDL_keycode.h>
#include <cstdint>
#include <vector>
#include <set>
#include <string>

// Forward declarations to avoid including heavy headers
namespace Urbaxio {
    class Camera;
    struct SnapResult;
    class Renderer;
    namespace Engine {
        class Scene;
    }
}
struct SDL_Window;

namespace Urbaxio::Tools {

// Enum to identify tools
enum class ToolType {
    Select,
    Line,
    PushPull
};

// Bundles common objects and state that tools need to access.
// Pointers are used to allow tools to modify the main application state (like selection).
struct ToolContext {
    Engine::Scene* scene = nullptr;
    Camera* camera = nullptr;
    SDL_Window* window = nullptr;
    int* display_w = nullptr;
    int* display_h = nullptr;

    // Selection state references (tools can modify these)
    uint64_t* selectedObjId = nullptr;
    std::vector<size_t>* selectedTriangleIndices = nullptr;
    std::set<uint64_t>* selectedLineIDs = nullptr;

    // Hover state references (tools can modify these)
    uint64_t* hoveredObjId = nullptr;
    std::vector<size_t>* hoveredFaceTriangleIndices = nullptr;
};

// Interface for all interactive tools
class ITool {
public:
    virtual ~ITool() = default;

    virtual ToolType GetType() const = 0;
    virtual const char* GetName() const = 0;

    // Lifecycle
    virtual void Activate(const ToolContext& context) {
        this->context = context;
        isActive = true;
    }
    virtual void Deactivate() {
        isActive = false;
    }

    // Event handling (called from InputHandler)
    virtual void OnLeftMouseDown(int mouseX, int mouseY, bool shift, bool ctrl) {}
    virtual void OnLeftMouseUp(int mouseX, int mouseY, bool shift, bool ctrl) {}
    virtual void OnRightMouseDown() {}
    virtual void OnMouseMove(int mouseX, int mouseY) {}
    virtual void OnKeyDown(SDL_Keycode key, bool shift, bool ctrl) {}
    
    // Per-frame update, gives the tool the latest snap info
    virtual void OnUpdate(const SnapResult& snap) {} 

    // Rendering (called from main loop)
    virtual void RenderUI() {}
    virtual void RenderPreview(Renderer& renderer, const SnapResult& snap) {}

    bool IsActive() const { return isActive; }

protected:
    ToolContext context;
    bool isActive = false;
};

} // namespace Urbaxio::Tools 
ENCODINGUTF8ENCODINGUTF8--- File: shell/include/tools/LineTool.h ---
ENCODINGUTF8#pragma once

#include "tools/ITool.h"
#include "snapping.h" // <-- FIX: Include header for SnapResult and SnapType

namespace Urbaxio::Tools {

class LineTool : public ITool {
public:
    ToolType GetType() const override { return ToolType::Line; }
    const char* GetName() const override { return "Line"; }

    void Activate(const ToolContext& context) override;
    void Deactivate() override;

    void OnLeftMouseDown(int mouseX, int mouseY, bool shift, bool ctrl) override;
    void OnRightMouseDown() override;
    void OnKeyDown(SDL_Keycode key, bool shift, bool ctrl) override;
    void OnUpdate(const SnapResult& snap) override;

    void RenderUI() override;
    void RenderPreview(Renderer& renderer, const SnapResult& snap) override;

private:
    // --- NEW: State Machine ---
    enum class ToolState {
        IDLE,                           // Tool is active, but no line has been started
        AWAITING_SECOND_POINT_FREE,     // First point is placed, cursor moves freely
        AWAITING_SECOND_POINT_AXIS_LOCKED // First point is placed, movement is locked to an axis
    };
    ToolState currentState = ToolState::IDLE;

    // --- State-related data ---
    glm::vec3 currentLineStartPoint{0.0f};
    glm::vec3 currentRubberBandEnd{0.0f};

    // --- Axis Locking State ---
    glm::vec3 lockedAxisDir{0.0f};
    SnapType lockedAxisType = SnapType::NONE;

    // Input buffer for length
    char lengthInputBuf[64] = "";
    
    // The last snap result received by OnUpdate
    SnapResult lastSnapResult;

    // --- Private helper methods ---
    void reset();
    void finalizeLine(const glm::vec3& endPoint);
    bool tryToLockAxis(const glm::vec3& currentTarget);
    glm::vec3 calculateAxisLockedPoint(const SnapResult& snapResult);
    bool isValidGeometricSnap(SnapType type);
};

} // namespace Urbaxio::Tools 
ENCODINGUTF8ENCODINGUTF8--- File: shell/include/tools/PushPullTool.h ---
ENCODINGUTF8#pragma once

#include "tools/ITool.h"

namespace Urbaxio::Tools {

class PushPullTool : public ITool {
public:
    ToolType GetType() const override { return ToolType::PushPull; }
    const char* GetName() const override { return "Push/Pull"; }

    void Activate(const ToolContext& context) override;
    void Deactivate() override;

    void OnLeftMouseDown(int mouseX, int mouseY, bool shift, bool ctrl) override;
    void OnRightMouseDown() override;
    void OnKeyDown(SDL_Keycode key, bool shift, bool ctrl) override;
    void OnUpdate(const SnapResult& snap) override;

    void RenderUI() override;
    void RenderPreview(Renderer& renderer, const SnapResult& snap) override;

    // State query method for snapping control
    bool IsPushPullActive() const { return isPushPullActive; }
private:
    bool isPushPullActive = false;
    
    // State for the active operation
    uint64_t pushPull_objId = 0;
    std::vector<size_t> pushPull_faceIndices;
    glm::vec3 pushPull_faceNormal{0.0f};
    glm::vec3 pushPull_startPoint{0.0f}; // Point on face plane where drag started
    float pushPullCurrentLength = 0.0f;
    int pushPull_startMouseX = 0;
    int pushPull_startMouseY = 0;
    
    // Input buffer for length
    char lengthInputBuf[64] = "";
    
    void reset();
    void finalizePushPull(bool ctrl);
    void updateHover(int mouseX, int mouseY);
};

} // namespace Urbaxio::Tools 
ENCODINGUTF8ENCODINGUTF8--- File: shell/include/tools/SelectTool.h ---
ENCODINGUTF8#pragma once

#include "tools/ITool.h"
#include <cstdint>
#include <cstddef> // for size_t

namespace Urbaxio::Tools {

class SelectTool : public ITool {
public:
    ToolType GetType() const override { return ToolType::Select; }
    const char* GetName() const override { return "Select"; }

    void Activate(const ToolContext& context) override;
    void Deactivate() override;

    void OnLeftMouseDown(int mouseX, int mouseY, bool shift, bool ctrl) override;

private:
    // Double-click detection state
    uint32_t lastClickTimestamp = 0;
    uint64_t lastClickedObjId = 0;
    size_t lastClickedTriangleIndex = 0;
};

} // namespace Urbaxio::Tools 
ENCODINGUTF8ENCODINGUTF8--- File: shell/include/tools/ToolManager.h ---
ENCODINGUTF8#pragma once

#include "tools/ITool.h"
#include <memory>
#include <map>

namespace Urbaxio::Tools {

class ToolManager {
public:
    ToolManager(const ToolContext& context);

    // Activates a tool of a given type.
    void SetTool(ToolType type);
    ITool* GetActiveTool() const;
    ToolType GetActiveToolType() const;

    // Check if snapping should be enabled for current tool
    bool ShouldEnableSnapping() const;

    // --- Event Forwarding (called by InputHandler) ---
    void OnLeftMouseDown(int mouseX, int mouseY, bool shift, bool ctrl);
    void OnLeftMouseUp(int mouseX, int mouseY, bool shift, bool ctrl);
    void OnRightMouseDown();
    void OnMouseMove(int mouseX, int mouseY);
    void OnKeyDown(SDL_Keycode key, bool shift, bool ctrl);

    // --- Update and Render (called by main loop) ---
    void OnUpdate(const SnapResult& snap);
    void RenderUI();
    void RenderPreview(Renderer& renderer, const SnapResult& snap);

private:
    std::map<ToolType, std::unique_ptr<ITool>> tools;
    ITool* activeTool = nullptr;
    ToolContext context;
};

} // namespace Urbaxio::Tools 
ENCODINGUTF8ENCODINGUTF8--- File: shell/src/tools/LineTool.cpp ---
ENCODINGUTF8#include "tools/LineTool.h"
#include "engine/scene.h"
#include "camera.h"
#include "renderer.h"
#include "snapping.h"
#include <imgui.h>
#include <SDL2/SDL_keyboard.h>
#include <SDL2/SDL_mouse.h> // <-- FIX: Added missing include for mouse functions
#include <glm/gtx/norm.hpp>
#include <glm/gtx/vector_angle.hpp>
#include <charconv>
#include <string>
#include <cstring>
#include <iostream>
#include "engine/commands/CreateLineCommand.h" // <-- NEW
#include <memory> // For std::make_unique

namespace { // Anonymous namespace for helpers

// Checks if the snap type indicates a point on an existing line that requires a split.
bool IsLineSplittingSnap(Urbaxio::SnapType type) {
    switch(type) {
        case Urbaxio::SnapType::MIDPOINT:
        case Urbaxio::SnapType::ON_EDGE:
            return true;
        default:
            return false;
    }
}

void AppendCharToBuffer(char* buf, size_t bufSize, char c) {
    size_t len = strlen(buf);
    if (len + 1 < bufSize) {
        buf[len] = c;
        buf[len + 1] = '\0';
    }
}

void RemoveLastChar(char* buf) {
    size_t len = strlen(buf);
    if (len > 0) {
        buf[len - 1] = '\0';
    }
}

glm::vec3 ClosestPointOnLine(const glm::vec3& lineOrigin, const glm::vec3& lineDir, const glm::vec3& point) {
    float t = glm::dot(point - lineOrigin, lineDir);
    return lineOrigin + lineDir * t;
}

const glm::vec3 AXIS_X_DIR(1.0f, 0.0f, 0.0f);
const glm::vec3 AXIS_Y_DIR(0.0f, 1.0f, 0.0f);
const glm::vec3 AXIS_Z_DIR(0.0f, 0.0f, 1.0f);
const float SCREEN_VECTOR_MIN_LENGTH_SQ = 4.0f;

// Checks for snaps that are valid for axis projection.
bool IsProjectablePointSnap(Urbaxio::SnapType type) {
    switch (type) {
        case Urbaxio::SnapType::ENDPOINT:
        case Urbaxio::SnapType::ORIGIN:
        case Urbaxio::SnapType::MIDPOINT:
        case Urbaxio::SnapType::CENTER:
        case Urbaxio::SnapType::INTERSECTION:
            return true;
        default:
            return false;
    }
}

} // end anonymous namespace

namespace Urbaxio::Tools {

void LineTool::Activate(const ToolContext& context) {
    ITool::Activate(context);
    reset();
}

void LineTool::Deactivate() {
    reset();
    ITool::Deactivate();
}

void LineTool::reset() {
    currentState = ToolState::IDLE;
    lockedAxisType = SnapType::NONE;
    lengthInputBuf[0] = '\0';
}

void LineTool::OnLeftMouseDown(int mouseX, int mouseY, bool shift, bool ctrl) {
    if (!context.scene) return;

    // Use the latest snap result from OnUpdate
    glm::vec3 clickPoint = currentRubberBandEnd;

    // Handle splitting existing lines on snap
    if (lastSnapResult.snapped && IsLineSplittingSnap(lastSnapResult.type)) {
        clickPoint = context.scene->SplitLineAtPoint(lastSnapResult.snappedEntityId, lastSnapResult.worldPoint);
    }
    
    if (currentState == ToolState::IDLE) {
        currentLineStartPoint = clickPoint;
        currentState = ToolState::AWAITING_SECOND_POINT_FREE;
        lengthInputBuf[0] = '\0';
    } else if (currentState == ToolState::AWAITING_SECOND_POINT_FREE || currentState == ToolState::AWAITING_SECOND_POINT_AXIS_LOCKED) {
        finalizeLine(clickPoint);
    }
}

void LineTool::OnRightMouseDown() {
    if (currentState == ToolState::AWAITING_SECOND_POINT_AXIS_LOCKED) {
        currentState = ToolState::AWAITING_SECOND_POINT_FREE;
    } else if (currentState == ToolState::AWAITING_SECOND_POINT_FREE) {
        currentState = ToolState::IDLE;
        lengthInputBuf[0] = '\0';
    } else if (currentState == ToolState::IDLE) {
        reset();
    }
}

void LineTool::OnKeyDown(SDL_Keycode key, bool shift, bool ctrl) {
    if (key == SDLK_ESCAPE) {
        OnRightMouseDown();
        return;
    }
    
    if (currentState == ToolState::AWAITING_SECOND_POINT_FREE || currentState == ToolState::AWAITING_SECOND_POINT_AXIS_LOCKED) {
        bool isEnter = (key == SDLK_RETURN || key == SDLK_KP_ENTER);
        bool isBackspace = (key == SDLK_BACKSPACE);

        if (isEnter) {
            float length_mm;
            auto [ptr, ec] = std::from_chars(lengthInputBuf, lengthInputBuf + strlen(lengthInputBuf), length_mm);
            if (ec == std::errc() && ptr == lengthInputBuf + strlen(lengthInputBuf)) {
                float length_m = length_mm / 1000.0f; // Convert mm to meters
                if (length_m > 1e-4f) {
                glm::vec3 direction;
                if (currentState == ToolState::AWAITING_SECOND_POINT_AXIS_LOCKED) {
                    float dotProd = glm::dot(currentRubberBandEnd - currentLineStartPoint, lockedAxisDir);
                    direction = (dotProd >= 0.0f) ? lockedAxisDir : -lockedAxisDir;
                } else {
                    direction = currentRubberBandEnd - currentLineStartPoint;
                    if (glm::length(direction) < 1e-6f) { reset(); return; }
                    direction = glm::normalize(direction);
                }
                glm::vec3 finalEndPoint = currentLineStartPoint + direction * length_m;
                finalizeLine(finalEndPoint);
            }
        } else {
            lengthInputBuf[0] = '\0'; // Clear bad input
        }
        } else if (isBackspace) {
            RemoveLastChar(lengthInputBuf);
        } else {
            char c = '\0';
            if ((key >= SDLK_0 && key <= SDLK_9)) c = (char)key;
            else if ((key >= SDLK_KP_0 && key <= SDLK_KP_9)) c = '0' + (key - SDLK_KP_0);
            else if (key == SDLK_PERIOD || key == SDLK_KP_PERIOD) { if (strchr(lengthInputBuf, '.') == nullptr) c = '.'; }
            if (c != '\0') AppendCharToBuffer(lengthInputBuf, 64, c);
        }
    }
}

void LineTool::OnUpdate(const SnapResult& snap) {
    lastSnapResult = snap; 
    const Uint8* keyboardState = SDL_GetKeyboardState(NULL);
    bool shiftDown = keyboardState[SDL_SCANCODE_LSHIFT] || keyboardState[SDL_SCANCODE_RSHIFT];

    switch (currentState) {
        case ToolState::IDLE:
            currentRubberBandEnd = snap.worldPoint;
            break;

        case ToolState::AWAITING_SECOND_POINT_FREE:
            if (shiftDown && tryToLockAxis(snap.worldPoint)) {
                currentState = ToolState::AWAITING_SECOND_POINT_AXIS_LOCKED;
                // Defer point calculation to the next frame in the correct state
                return;
            }
            currentRubberBandEnd = snap.worldPoint;
            break;

        case ToolState::AWAITING_SECOND_POINT_AXIS_LOCKED:
            if (!shiftDown) {
                currentState = ToolState::AWAITING_SECOND_POINT_FREE;
                currentRubberBandEnd = snap.worldPoint; // Update immediately
                return;
            }
            currentRubberBandEnd = calculateAxisLockedPoint(snap);
            break;
    }
}

void LineTool::finalizeLine(const glm::vec3& endPoint) {
    if (glm::distance2(currentLineStartPoint, endPoint) > 1e-6f) {
        auto command = std::make_unique<Engine::CreateLineCommand>(
            context.scene, 
            currentLineStartPoint, 
            endPoint
        );
        context.scene->getCommandManager()->ExecuteCommand(std::move(command));
    }
    // Reset for the next line
    currentState = ToolState::IDLE;
    lockedAxisType = SnapType::NONE;
    lengthInputBuf[0] = '\0';
}

void LineTool::RenderUI() {
    if (currentState != ToolState::IDLE) {
        ImGui::Separator();
        ImGui::Text("Length (mm): %s", lengthInputBuf);
        ImGui::Separator();
    }
}

void LineTool::RenderPreview(Renderer& renderer, const SnapResult& snap) {
    if (currentState != ToolState::IDLE) {
        renderer.UpdatePreviewLine(currentLineStartPoint, currentRubberBandEnd);
    } else {
        renderer.UpdatePreviewLine(glm::vec3(0.0f), glm::vec3(0.0f), false);
    }
}

// --- NEW/MODIFIED HELPER METHODS ---

bool LineTool::tryToLockAxis(const glm::vec3& currentTarget) {
    glm::mat4 view = context.camera->GetViewMatrix();
    glm::mat4 proj = context.camera->GetProjectionMatrix((float)*context.display_w / (float)*context.display_h);
    glm::vec2 startScreenPos, endScreenPos;

    bool sVis = SnappingSystem::WorldToScreen(currentLineStartPoint, view, proj, *context.display_w, *context.display_h, startScreenPos);
    bool eVis = SnappingSystem::WorldToScreen(currentTarget, view, proj, *context.display_w, *context.display_h, endScreenPos);

    if (sVis && eVis && glm::length2(endScreenPos - startScreenPos) > SCREEN_VECTOR_MIN_LENGTH_SQ) {
        glm::vec2 rbDir = glm::normalize(endScreenPos - startScreenPos);
        float maxDot = -1.0f;
        SnapType bestAxis = SnapType::NONE;
        glm::vec3 bestDir;
        
        const std::vector<std::pair<SnapType, glm::vec3>> axes = {
            {SnapType::AXIS_X, AXIS_X_DIR},
            {SnapType::AXIS_Y, AXIS_Y_DIR},
            {SnapType::AXIS_Z, AXIS_Z_DIR}
        };

        glm::vec2 originScreen;
        if(SnappingSystem::WorldToScreen(currentLineStartPoint, view, proj, *context.display_w, *context.display_h, originScreen)) {
            for(const auto& ax : axes) {
                glm::vec2 axisEndPointScreen;
                if(SnappingSystem::WorldToScreen(currentLineStartPoint + ax.second, view, proj, *context.display_w, *context.display_h, axisEndPointScreen)) {
                    if (glm::length2(axisEndPointScreen - originScreen) > 1e-6) {
                        glm::vec2 axDir = glm::normalize(axisEndPointScreen - originScreen);
                        float d = abs(glm::dot(rbDir, axDir));
                        if (d > maxDot) { maxDot = d; bestAxis = ax.first; bestDir = ax.second;}
                    }
                }
            }
        }
        
        if(bestAxis != SnapType::NONE) {
            lockedAxisType = bestAxis;
            lockedAxisDir = bestDir;
            return true;
        }
    }
    return false;
}

bool LineTool::isValidGeometricSnap(SnapType type) {
    // A valid geometric snap is ANY snap that isn't NONE or GRID
    switch (type) {
        case SnapType::ENDPOINT:
        case SnapType::MIDPOINT:
        case SnapType::ON_EDGE:
        case SnapType::ON_FACE:
        case SnapType::INTERSECTION:
        case SnapType::CENTER:
        case SnapType::ORIGIN:
        case SnapType::AXIS_X:
        case SnapType::AXIS_Y:
        case SnapType::AXIS_Z:
            return true;
        default:
            return false;
    }
}

glm::vec3 LineTool::calculateAxisLockedPoint(const SnapResult& snapResult) {
    // Step 0: High-priority geometric snap (inference point)
    if (snapResult.snapped && isValidGeometricSnap(snapResult.type)) {
        return ClosestPointOnLine(currentLineStartPoint, lockedAxisDir, snapResult.worldPoint);
    }
    
    // Step 1 & 2: Hybrid Strategy for empty space
    int mouseX, mouseY;
    SDL_GetMouseState(&mouseX, &mouseY);
    glm::vec3 rayOrigin, rayDir;
    Camera::ScreenToWorldRay(mouseX, mouseY, *context.display_w, *context.display_h, context.camera->GetViewMatrix(), context.camera->GetProjectionMatrix((float)*context.display_w / (float)*context.display_h), rayOrigin, rayDir);

    if (lockedAxisType == SnapType::AXIS_X || lockedAxisType == SnapType::AXIS_Y) {
        // "Horizontal" Strategy: Project onto the Z=0 construction plane
        glm::vec3 pointOnGround;
        if (SnappingSystem::RaycastToZPlane(mouseX, mouseY, *context.display_w, *context.display_h, *context.camera, pointOnGround)) {
            return ClosestPointOnLine(currentLineStartPoint, lockedAxisDir, pointOnGround);
        }
    } else if (lockedAxisType == SnapType::AXIS_Z) {
        // "Vertical" Strategy: Project onto the virtual vertical plane
        glm::vec3 planeOrigin = currentLineStartPoint;
        
        // --- FIX: The normal must be perpendicular to the camera's UP direction on the XY plane ---
        // This makes the plane sensitive to vertical mouse movement.
        glm::vec3 planeNormal = glm::cross(AXIS_Z_DIR, context.camera->Right);

        float denominator = glm::dot(rayDir, planeNormal);
        if (std::abs(denominator) > 1e-6) { // Avoid cases where the ray is parallel to the plane
            float t = glm::dot(planeOrigin - rayOrigin, planeNormal) / denominator;
            if (t > 0) {
                glm::vec3 intersectionPoint = rayOrigin + t * rayDir;
                // The final point must lie on the Z-axis, so we only take the Z coordinate from the intersection.
                return glm::vec3(currentLineStartPoint.x, currentLineStartPoint.y, intersectionPoint.z);
            }
        }
    }
    
    // Fallback if any calculation fails (e.g., parallel ray)
    return currentRubberBandEnd; 
}

} // namespace Urbaxio::Tools 
ENCODINGUTF8ENCODINGUTF8--- File: shell/src/tools/PushPullTool.cpp ---
ENCODINGUTF8#include "tools/PushPullTool.h"
#include "engine/scene.h"
#include "engine/scene_object.h"
#include "cad_kernel/MeshBuffers.h"
#include "camera.h"
#include "renderer.h"
#include "snapping.h"
#include <imgui.h>
#include <SDL2/SDL_mouse.h>
#include <glm/gtx/intersect.hpp>
#include <glm/gtx/norm.hpp>
#include <charconv>
#include <string>
#include <cstring>
#include <iostream>
#include <limits>
#include <set>
#include <map>
#include <list>
#include "engine/commands/PushPullCommand.h"
#include <memory> // For std::make_unique

namespace { // Anonymous namespace for helpers

// Re-using FindCoplanarAdjacentTriangles from SelectTool's anonymous namespace is tricky.
// Так что просто копируем сюда улучшенную версию.
std::vector<size_t> FindCoplanarAdjacentTriangles_ForPushPull(
    const Urbaxio::Engine::SceneObject& object,
    size_t startTriangleBaseIndex)
{
    const auto& name = object.get_name();
    if (name == "CenterMarker" || name == "UnitCapsuleMarker10m" || name == "UnitCapsuleMarker5m") {
        return { startTriangleBaseIndex };
    }
    const float NORMAL_DOT_TOLERANCE = 0.999f;
    const float PLANE_DIST_TOLERANCE = 1e-4f;
    const auto& mesh = object.get_mesh_buffers();
    if (!object.has_mesh() || startTriangleBaseIndex + 2 >= mesh.indices.size()) { return { startTriangleBaseIndex }; }
    std::map<std::pair<unsigned int, unsigned int>, std::vector<size_t>> edgeToTriangles;
    for (size_t i = 0; i + 2 < mesh.indices.size(); i += 3) {
        unsigned int v_indices[3] = { mesh.indices[i], mesh.indices[i + 1], mesh.indices[i + 2] };
        for (int j = 0; j < 3; ++j) {
            unsigned int v1_idx = v_indices[j];
            unsigned int v2_idx = v_indices[(j + 1) % 3];
            if (v1_idx > v2_idx) std::swap(v1_idx, v2_idx);
            edgeToTriangles[{v1_idx, v2_idx}].push_back(i);
        }
    }
    std::vector<size_t> resultFaceTriangles;
    std::list<size_t> queue;
    std::set<size_t> visitedTriangles;
    unsigned int i0 = mesh.indices[startTriangleBaseIndex];
    glm::vec3 v0(mesh.vertices[i0*3], mesh.vertices[i0*3+1], mesh.vertices[i0*3+2]);
    glm::vec3 referenceNormal(mesh.normals[i0*3], mesh.normals[i0*3+1], mesh.normals[i0*3+2]);
    float referencePlaneD = -glm::dot(referenceNormal, v0);
    queue.push_back(startTriangleBaseIndex);
    visitedTriangles.insert(startTriangleBaseIndex);
    while (!queue.empty()) {
        size_t currentTriangleIndex = queue.front();
        queue.pop_front();
        resultFaceTriangles.push_back(currentTriangleIndex);
        unsigned int current_v_indices[3] = { mesh.indices[currentTriangleIndex], mesh.indices[currentTriangleIndex + 1], mesh.indices[currentTriangleIndex + 2] };
        for (int j = 0; j < 3; ++j) {
            unsigned int v1_idx = current_v_indices[j];
            unsigned int v2_idx = current_v_indices[(j + 1) % 3];
            if (v1_idx > v2_idx) std::swap(v1_idx, v2_idx);
            const auto& potentialNeighbors = edgeToTriangles.at({v1_idx, v2_idx});
            for (size_t neighborIndex : potentialNeighbors) {
                if (neighborIndex == currentTriangleIndex) continue;
                if (visitedTriangles.find(neighborIndex) == visitedTriangles.end()) {
                    visitedTriangles.insert(neighborIndex);
                    unsigned int n_i0 = mesh.indices[neighborIndex];
                    glm::vec3 n_v0(mesh.vertices[n_i0*3], mesh.vertices[n_i0*3+1], mesh.vertices[n_i0*3+2]);
                    glm::vec3 neighborNormal(mesh.normals[n_i0*3], mesh.normals[n_i0*3+1], mesh.normals[n_i0*3+2]);
                    if (glm::abs(glm::dot(referenceNormal, neighborNormal)) > NORMAL_DOT_TOLERANCE) {
                        float dist = glm::abs(glm::dot(referenceNormal, n_v0) + referencePlaneD);
                        if (dist < PLANE_DIST_TOLERANCE) queue.push_back(neighborIndex);
                    }
                }
            }
        }
    }
    return resultFaceTriangles;
}

glm::vec3 ClosestPointOnLine_ForPushPull(const glm::vec3& lineOrigin, const glm::vec3& lineDir, const glm::vec3& point) {
    float t = glm::dot(point - lineOrigin, lineDir);
    return lineOrigin + lineDir * t;
}

bool IsValidPushPullSnap(Urbaxio::SnapType type) {
    switch (type) {
        case Urbaxio::SnapType::ENDPOINT:
        case Urbaxio::SnapType::MIDPOINT:
        case Urbaxio::SnapType::ORIGIN:
        case Urbaxio::SnapType::CENTER:
        case Urbaxio::SnapType::AXIS_X:
        case Urbaxio::SnapType::AXIS_Y:
        case Urbaxio::SnapType::AXIS_Z:
            return true;
        default:
            return false;
    }
}

} // end anonymous namespace

namespace Urbaxio::Tools {

void PushPullTool::Activate(const ToolContext& context) {
    ITool::Activate(context);
    reset();
}

void PushPullTool::Deactivate() {
    reset();
    ITool::Deactivate();
}

void PushPullTool::reset() {
    isPushPullActive = false;
    pushPull_objId = 0;
    pushPull_faceIndices.clear();
    pushPullCurrentLength = 0.0f;
    lengthInputBuf[0] = '\0';
    if(context.hoveredObjId) *context.hoveredObjId = 0;
    if(context.hoveredFaceTriangleIndices) context.hoveredFaceTriangleIndices->clear();
}

void PushPullTool::OnLeftMouseDown(int mouseX, int mouseY, bool shift, bool ctrl) {
    if (isPushPullActive) {
        finalizePushPull(ctrl);
    } else { // Start a new Push/Pull operation
        if (*context.hoveredObjId != 0 && !context.hoveredFaceTriangleIndices->empty()) {
            isPushPullActive = true;
            pushPull_objId = *context.hoveredObjId;
            pushPull_faceIndices = *context.hoveredFaceTriangleIndices;
            
            Urbaxio::Engine::SceneObject* obj = context.scene->get_object_by_id(pushPull_objId);
            if (!obj) { reset(); return; }

            // Calculate the average normal of the selected face
            const auto& mesh = obj->get_mesh_buffers();
            std::set<unsigned int> uniqueVertIndices;
            for (size_t baseIdx : pushPull_faceIndices) {
                uniqueVertIndices.insert(mesh.indices[baseIdx]);
                uniqueVertIndices.insert(mesh.indices[baseIdx + 1]);
                uniqueVertIndices.insert(mesh.indices[baseIdx + 2]);
            }
            glm::vec3 averagedNormal(0.0f);
            for (unsigned int vIdx : uniqueVertIndices) {
                averagedNormal.x += mesh.normals[vIdx * 3];
                averagedNormal.y += mesh.normals[vIdx * 3 + 1];
                averagedNormal.z += mesh.normals[vIdx * 3 + 2];
            }
            if (glm::length2(averagedNormal) > 1e-9f) {
                pushPull_faceNormal = glm::normalize(averagedNormal);
            } else { // Fallback for safety
                unsigned int firstIdx = mesh.indices[pushPull_faceIndices[0]];
                pushPull_faceNormal = glm::normalize(glm::vec3(mesh.normals[firstIdx*3], mesh.normals[firstIdx*3+1], mesh.normals[firstIdx*3+2]));
            }
            
            // Find the starting point on the extrusion plane
            glm::vec3 rayOrigin, rayDir;
            Camera::ScreenToWorldRay(mouseX, mouseY, *context.display_w, *context.display_h, context.camera->GetViewMatrix(), context.camera->GetProjectionMatrix((float)*context.display_w/(float)*context.display_h), rayOrigin, rayDir);
            float hitDist;
            glm::intersectRayPlane(rayOrigin, rayDir, glm::vec3(mesh.vertices[mesh.indices[pushPull_faceIndices[0]]*3], mesh.vertices[mesh.indices[pushPull_faceIndices[0]]*3+1], mesh.vertices[mesh.indices[pushPull_faceIndices[0]]*3+2]), pushPull_faceNormal, hitDist);
            pushPull_startPoint = rayOrigin + rayDir * hitDist;
            
            pushPullCurrentLength = 0.0f;
            SDL_GetMouseState(&pushPull_startMouseX, &pushPull_startMouseY);

            // Clear any previous selection
            *context.selectedObjId = 0;
            context.selectedTriangleIndices->clear();
            lengthInputBuf[0] = '\0';
        }
    }
}

void PushPullTool::OnRightMouseDown() {
    if (isPushPullActive) {
        reset();
    }
}

void PushPullTool::OnKeyDown(SDL_Keycode key, bool shift, bool ctrl) {
    if (key == SDLK_ESCAPE) {
        OnRightMouseDown();
        return;
    }
    
    if (isPushPullActive) {
        if (key == SDLK_RETURN || key == SDLK_KP_ENTER) {
            float length_mm;
            auto [ptr, ec] = std::from_chars(lengthInputBuf, lengthInputBuf + strlen(lengthInputBuf), length_mm);
            if (ec == std::errc() && ptr == lengthInputBuf + strlen(lengthInputBuf)) {
                // NEW: Apply the sign from the current mouse-drag direction
                float sign = (pushPullCurrentLength < 0.0f) ? -1.0f : 1.0f;
                pushPullCurrentLength = (length_mm / 1000.0f) * sign;
                finalizePushPull(ctrl);
            } else {
                lengthInputBuf[0] = '\0'; // Clear bad input
            }
        } else if (key == SDLK_BACKSPACE) {
            size_t len = strlen(lengthInputBuf); if (len > 0) lengthInputBuf[len - 1] = '\0';
        } else {
            char c = '\0';
            if ((key >= SDLK_0 && key <= SDLK_9)) c = (char)key;
            else if ((key >= SDLK_KP_0 && key <= SDLK_KP_9)) c = '0' + (key - SDLK_KP_0);
            else if (key == SDLK_PERIOD || key == SDLK_KP_PERIOD) { if (strchr(lengthInputBuf, '.') == nullptr) c = '.'; }
            if (c != '\0') { size_t len = strlen(lengthInputBuf); if (len + 1 < 64) { lengthInputBuf[len] = c; lengthInputBuf[len + 1] = '\0';} }
        }
    }
}

void PushPullTool::OnUpdate(const SnapResult& snap) {
    int mouseX, mouseY; SDL_GetMouseState(&mouseX, &mouseY);
    if (isPushPullActive) {
        // Update hovered face to be the one we are pulling
        *context.hoveredObjId = pushPull_objId;
        *context.hoveredFaceTriangleIndices = pushPull_faceIndices;

        if (snap.snapped && IsValidPushPullSnap(snap.type)) {
            // Project the snapped point onto the extrusion axis to get the length
            glm::vec3 projectedPoint = ClosestPointOnLine_ForPushPull(pushPull_startPoint, pushPull_faceNormal, snap.worldPoint);
            glm::vec3 offsetVector = projectedPoint - pushPull_startPoint;
            pushPullCurrentLength = glm::dot(offsetVector, pushPull_faceNormal);
        } else {
            // Fallback to screen-space mouse dragging if no valid snap
            glm::mat4 view = context.camera->GetViewMatrix();
            glm::mat4 proj = context.camera->GetProjectionMatrix((float)*context.display_w/(float)*context.display_h);
            glm::vec2 screenStart, screenEnd;
            bool p1_visible = SnappingSystem::WorldToScreen(pushPull_startPoint, view, proj, *context.display_w, *context.display_h, screenStart);
            bool p2_visible = SnappingSystem::WorldToScreen(pushPull_startPoint + pushPull_faceNormal, view, proj, *context.display_w, *context.display_h, screenEnd);
            
            if (p1_visible && p2_visible) {
                glm::vec2 screenAxisDir = screenEnd - screenStart;
                if (glm::length2(screenAxisDir) > 1e-8f) {
                    screenAxisDir = glm::normalize(screenAxisDir);
                    glm::vec2 mouseDelta(mouseX - pushPull_startMouseX, mouseY - pushPull_startMouseY);
                    float pixel_dist = glm::dot(mouseDelta, screenAxisDir);
                    // Sensitivity based on distance to object
                    float sensitivity = glm::distance(context.camera->Position, pushPull_startPoint) * 0.001f;
                    pushPullCurrentLength = pixel_dist * sensitivity;
                }
            }
        }
    } else {
        // Not active, so just update the hover state
        updateHover(mouseX, mouseY);
    }
}

void PushPullTool::finalizePushPull(bool ctrl) {
    if (context.scene && pushPull_objId != 0) {
        if (std::abs(pushPullCurrentLength) > 1e-4) {
            
            Urbaxio::Engine::SceneObject* obj = context.scene->get_object_by_id(pushPull_objId);
            if (!obj) { reset(); return; }
            
            const auto& mesh = obj->get_mesh_buffers();
            std::set<unsigned int> uniqueVertIndices;
            for (size_t baseIdx : pushPull_faceIndices) {
                uniqueVertIndices.insert(mesh.indices[baseIdx]);
                uniqueVertIndices.insert(mesh.indices[baseIdx + 1]);
                uniqueVertIndices.insert(mesh.indices[baseIdx + 2]);
            }
            
            std::vector<glm::vec3> faceVertices;
            for (unsigned int vIdx : uniqueVertIndices) {
                faceVertices.push_back({
                    mesh.vertices[vIdx * 3],
                    mesh.vertices[vIdx * 3 + 1],
                    mesh.vertices[vIdx * 3 + 2]
                });
            }

            auto command = std::make_unique<Urbaxio::Engine::PushPullCommand>(
                context.scene, 
                faceVertices,
                pushPull_faceNormal,
                pushPullCurrentLength,
                ctrl
            );
            context.scene->getCommandManager()->ExecuteCommand(std::move(command));
        }
    }
    reset();
}

void PushPullTool::updateHover(int mouseX, int mouseY) {
    *context.hoveredObjId = 0;
    context.hoveredFaceTriangleIndices->clear();
    
    glm::vec3 rayOrigin, rayDir;
    Camera::ScreenToWorldRay(mouseX, mouseY, *context.display_w, *context.display_h, context.camera->GetViewMatrix(), context.camera->GetProjectionMatrix((float)*context.display_w/(float)*context.display_h), rayOrigin, rayDir);
    
    uint64_t currentHoveredObjId = 0;
    size_t currentHoveredTriangleIdx = 0;
    float closestHitDist = std::numeric_limits<float>::max();

    for (Urbaxio::Engine::SceneObject* obj_ptr : context.scene->get_all_objects()) {
        const auto& name = obj_ptr->get_name();
        if (obj_ptr && obj_ptr->has_mesh() && name != "CenterMarker" && name != "UnitCapsuleMarker10m" && name != "UnitCapsuleMarker5m") {
            const auto& mesh = obj_ptr->get_mesh_buffers();
            for (size_t i = 0; i + 2 < mesh.indices.size(); i += 3) {
                glm::vec3 v0(mesh.vertices[mesh.indices[i]*3], mesh.vertices[mesh.indices[i]*3+1], mesh.vertices[mesh.indices[i]*3+2]);
                glm::vec3 v1(mesh.vertices[mesh.indices[i+1]*3], mesh.vertices[mesh.indices[i+1]*3+1], mesh.vertices[mesh.indices[i+1]*3+2]);
                glm::vec3 v2(mesh.vertices[mesh.indices[i+2]*3], mesh.vertices[mesh.indices[i+2]*3+1], mesh.vertices[mesh.indices[i+2]*3+2]);
                float t;
                if (SnappingSystem::RayTriangleIntersect(rayOrigin, rayDir, v0, v1, v2, t) && t > 0 && t < closestHitDist) {
                    closestHitDist = t;
                    currentHoveredObjId = obj_ptr->get_id();
                    currentHoveredTriangleIdx = i;
                }
            }
        }
    }

    if (currentHoveredObjId != 0) {
        Urbaxio::Engine::SceneObject* hitObject = context.scene->get_object_by_id(currentHoveredObjId);
        if (hitObject) {
            *context.hoveredFaceTriangleIndices = FindCoplanarAdjacentTriangles_ForPushPull(*hitObject, currentHoveredTriangleIdx);
            *context.hoveredObjId = currentHoveredObjId;
        }
    }
}

void PushPullTool::RenderUI() {
    if (isPushPullActive) {
        ImGui::Separator();
        ImGui::Text("Length (mm): %s", lengthInputBuf);
        ImGui::Separator();
    }
}

void PushPullTool::RenderPreview(Renderer& renderer, const SnapResult& snap) {
    if (isPushPullActive) {
        Urbaxio::Engine::SceneObject* obj = context.scene->get_object_by_id(pushPull_objId);
        if (obj) {
            renderer.UpdatePushPullPreview(*obj, pushPull_faceIndices, pushPull_faceNormal, pushPullCurrentLength);
        }
    } else {
        // Clear preview mesh when not active
        renderer.UpdatePushPullPreview(Urbaxio::Engine::SceneObject(0, ""), {}, {}, 0.0f);
    }
}

} // namespace Urbaxio::Tools 
ENCODINGUTF8ENCODINGUTF8--- File: shell/src/tools/SelectTool.cpp ---
ENCODINGUTF8#include "tools/SelectTool.h"
#include "engine/scene.h"
#include "engine/scene_object.h"
#include "cad_kernel/MeshBuffers.h"
#include "camera.h"
#include "snapping.h"
#include <SDL2/SDL.h>
#include <glm/glm.hpp>
#include <glm/gtx/norm.hpp> // <-- FIX: Include header for distance2 and length2
#include <iostream>
#include <vector>
#include <set>
#include <list>
#include <map>
#include <algorithm>
#include <limits>

namespace { // Anonymous namespace for helpers local to this file

const float LINE_PICK_THRESHOLD_RADIUS = 0.25f;

// Helper to find all coplanar and adjacent triangles, starting from a given one.
std::vector<size_t> FindCoplanarAdjacentTriangles(
    const Urbaxio::Engine::SceneObject& object,
    size_t startTriangleBaseIndex)
{
    // Do not attempt to group faces on special marker objects
    const auto& name = object.get_name();
    if (name == "CenterMarker" || name == "UnitCapsuleMarker10m" || name == "UnitCapsuleMarker5m") {
        return { startTriangleBaseIndex };
    }

    const float NORMAL_DOT_TOLERANCE = 0.999f; // Cosine of angle tolerance
    const float PLANE_DIST_TOLERANCE = 1e-4f;

    const auto& mesh = object.get_mesh_buffers();
    if (!object.has_mesh() || startTriangleBaseIndex + 2 >= mesh.indices.size()) {
        return { startTriangleBaseIndex };
    }

    // Build an edge-to-triangle map for adjacency lookups
    std::map<std::pair<unsigned int, unsigned int>, std::vector<size_t>> edgeToTriangles;
    for (size_t i = 0; i + 2 < mesh.indices.size(); i += 3) {
        unsigned int v_indices[3] = { mesh.indices[i], mesh.indices[i + 1], mesh.indices[i + 2] };
        for (int j = 0; j < 3; ++j) {
            unsigned int v1_idx = v_indices[j];
            unsigned int v2_idx = v_indices[(j + 1) % 3];
            if (v1_idx > v2_idx) std::swap(v1_idx, v2_idx);
            edgeToTriangles[{v1_idx, v2_idx}].push_back(i);
        }
    }

    std::vector<size_t> resultFaceTriangles;
    std::list<size_t> queue;
    std::set<size_t> visitedTriangles;

    // Define the reference plane from the starting triangle
    unsigned int i0 = mesh.indices[startTriangleBaseIndex];
    glm::vec3 v0(mesh.vertices[i0*3], mesh.vertices[i0*3+1], mesh.vertices[i0*3+2]);
    glm::vec3 referenceNormal(mesh.normals[i0*3], mesh.normals[i0*3+1], mesh.normals[i0*3+2]);
    float referencePlaneD = -glm::dot(referenceNormal, v0);

    // Start BFS
    queue.push_back(startTriangleBaseIndex);
    visitedTriangles.insert(startTriangleBaseIndex);

    while (!queue.empty()) {
        size_t currentTriangleIndex = queue.front();
        queue.pop_front();
        resultFaceTriangles.push_back(currentTriangleIndex);

        unsigned int current_v_indices[3] = { mesh.indices[currentTriangleIndex], mesh.indices[currentTriangleIndex + 1], mesh.indices[currentTriangleIndex + 2] };

        // Check neighbors through all 3 edges
        for (int j = 0; j < 3; ++j) {
            unsigned int v1_idx = current_v_indices[j];
            unsigned int v2_idx = current_v_indices[(j + 1) % 3];
            if (v1_idx > v2_idx) std::swap(v1_idx, v2_idx);

            const auto& potentialNeighbors = edgeToTriangles.at({v1_idx, v2_idx});
            for (size_t neighborIndex : potentialNeighbors) {
                if (neighborIndex == currentTriangleIndex) continue;

                if (visitedTriangles.find(neighborIndex) == visitedTriangles.end()) {
                    visitedTriangles.insert(neighborIndex);

                    unsigned int n_i0 = mesh.indices[neighborIndex];
                    glm::vec3 n_v0(mesh.vertices[n_i0*3], mesh.vertices[n_i0*3+1], mesh.vertices[n_i0*3+2]);
                    glm::vec3 neighborNormal(mesh.normals[n_i0*3], mesh.normals[n_i0*3+1], mesh.normals[n_i0*3+2]);
                    
                    // Check for coplanarity (normal and distance from plane)
                    if (glm::abs(glm::dot(referenceNormal, neighborNormal)) > NORMAL_DOT_TOLERANCE) {
                        float dist = glm::abs(glm::dot(referenceNormal, n_v0) + referencePlaneD);
                        if (dist < PLANE_DIST_TOLERANCE) {
                            queue.push_back(neighborIndex);
                        }
                    }
                }
            }
        }
    }
    return resultFaceTriangles;
}

// Helper to find the closest line segment to a ray
bool RayLineSegmentIntersection(
    const glm::vec3& rayOrigin, const glm::vec3& rayDir,
    const glm::vec3& p1, const glm::vec3& p2,
    float pickThresholdRadius,
    float& outDistanceAlongRay)
{
    const float LINE_RAY_EPSILON = 1e-6f;
    glm::vec3 segDir = p2 - p1;
    float segLenSq = glm::length2(segDir);

    if (segLenSq < LINE_RAY_EPSILON * LINE_RAY_EPSILON) { // It's a point
        outDistanceAlongRay = glm::dot(p1 - rayOrigin, rayDir);
        if (outDistanceAlongRay < 0) return false;
        glm::vec3 pointOnRay = rayOrigin + rayDir * outDistanceAlongRay;
        return glm::distance2(pointOnRay, p1) < pickThresholdRadius * pickThresholdRadius;
    }
    
    glm::vec3 segDirNormalized = glm::normalize(segDir);
    glm::vec3 w0 = rayOrigin - p1;
    
    float a = 1.0f;
    float b = glm::dot(rayDir, segDirNormalized);
    float c = 1.0f;
    float d = glm::dot(rayDir, w0);
    float e = glm::dot(segDirNormalized, w0);
    
    float denom = a * c - b * b;
    float t_seg_param;
    
    if (std::abs(denom) < LINE_RAY_EPSILON) { // Parallel lines
        return false;
    }
    
    t_seg_param = (a * e - b * d) / denom;
    
    // Clamp to segment
    float segActualLength = glm::sqrt(segLenSq);
    t_seg_param = glm::clamp(t_seg_param, 0.0f, segActualLength);
    
    glm::vec3 closestPointOnSegment = p1 + segDirNormalized * t_seg_param;
    float actual_t_ray = glm::dot(closestPointOnSegment - rayOrigin, rayDir);
    
    if (actual_t_ray < 0) return false;
    
    glm::vec3 closestPointOnRay = rayOrigin + actual_t_ray * rayDir;
    
    if (glm::distance2(closestPointOnRay, closestPointOnSegment) < pickThresholdRadius * pickThresholdRadius) {
        outDistanceAlongRay = actual_t_ray;
        return true;
    }
    return false;
}

} // end anonymous namespace

namespace Urbaxio::Tools {

void SelectTool::Activate(const ToolContext& context) {
    ITool::Activate(context);
    lastClickTimestamp = 0;
    lastClickedObjId = 0;
    lastClickedTriangleIndex = 0;
}

void SelectTool::Deactivate() {
    ITool::Deactivate();
}

void SelectTool::OnLeftMouseDown(int mouseX, int mouseY, bool shift, bool ctrl) {
    if (!context.scene || !context.camera || !context.display_w || !context.display_h) return;

    glm::vec3 rayOrigin, rayDir;
    Camera::ScreenToWorldRay(
        mouseX, mouseY, *context.display_w, *context.display_h,
        context.camera->GetViewMatrix(),
        context.camera->GetProjectionMatrix((float)*context.display_w / (float)*context.display_h),
        rayOrigin, rayDir
    );

    uint64_t hitObjectId = 0;
    size_t hitTriangleBaseIndex = 0;
    float closestHitDistance = std::numeric_limits<float>::max();

    struct LineHit { uint64_t lineId; float distanceAlongRay; };
    std::vector<LineHit> lineHits;

    // 1. Check for line intersections first
    const auto& all_lines = context.scene->GetAllLines();
    for (const auto& [id, line] : all_lines) {
        float distAlongRay;
        if (RayLineSegmentIntersection(rayOrigin, rayDir, line.start, line.end, LINE_PICK_THRESHOLD_RADIUS, distAlongRay)) {
            lineHits.push_back({id, distAlongRay});
        }
    }

    // If a line was hit, select it and we're done.
    if (!lineHits.empty()) {
        std::sort(lineHits.begin(), lineHits.end(), [](const LineHit& a, const LineHit& b) { return a.distanceAlongRay < b.distanceAlongRay; });
        uint64_t closestLineId = lineHits[0].lineId;
        
        if (!shift) {
            context.selectedLineIDs->clear();
        }
        
        if (context.selectedLineIDs->count(closestLineId)) {
            context.selectedLineIDs->erase(closestLineId);
        } else {
            context.selectedLineIDs->insert(closestLineId);
        }
        
        // Clear object selection when selecting lines
        *context.selectedObjId = 0;
        context.selectedTriangleIndices->clear();
        return;
    }

    // 2. If no line was hit, check for object face intersections
    if (!shift) {
        context.selectedLineIDs->clear();
    }

    for (Urbaxio::Engine::SceneObject* obj_ptr : context.scene->get_all_objects()) {
        const auto& name = obj_ptr->get_name();
        if (obj_ptr && obj_ptr->has_mesh() &&
            name != "CenterMarker" && name != "UnitCapsuleMarker10m" && name != "UnitCapsuleMarker5m") {
            const auto& mesh = obj_ptr->get_mesh_buffers();
            for (size_t i = 0; i + 2 < mesh.indices.size(); i += 3) {
                glm::vec3 v0(mesh.vertices[mesh.indices[i] * 3], mesh.vertices[mesh.indices[i] * 3 + 1], mesh.vertices[mesh.indices[i] * 3 + 2]);
                glm::vec3 v1(mesh.vertices[mesh.indices[i + 1] * 3], mesh.vertices[mesh.indices[i + 1] * 3 + 1], mesh.vertices[mesh.indices[i + 1] * 3 + 2]);
                glm::vec3 v2(mesh.vertices[mesh.indices[i + 2] * 3], mesh.vertices[mesh.indices[i + 2] * 3 + 1], mesh.vertices[mesh.indices[i + 2] * 3 + 2]);
                float t;
                if (SnappingSystem::RayTriangleIntersect(rayOrigin, rayDir, v0, v1, v2, t) && t > 0 && t < closestHitDistance) {
                    closestHitDistance = t;
                    hitObjectId = obj_ptr->get_id();
                    hitTriangleBaseIndex = i;
                }
            }
        }
    }

    // 3. Process the face hit
    if (hitObjectId != 0) {
        uint32_t currentTime = SDL_GetTicks();
        const uint32_t DOUBLE_CLICK_TIME = 300;

        // Double-click to select a single triangle
        if (currentTime - lastClickTimestamp < DOUBLE_CLICK_TIME && hitObjectId == lastClickedObjId && hitTriangleBaseIndex == lastClickedTriangleIndex) {
            *context.selectedTriangleIndices = { hitTriangleBaseIndex };
            *context.selectedObjId = hitObjectId;
            lastClickTimestamp = 0; // Reset double-click timer
        } else { // Single-click to select a whole face
            Urbaxio::Engine::SceneObject* hitObject = context.scene->get_object_by_id(hitObjectId);
            if (hitObject) {
                *context.selectedTriangleIndices = FindCoplanarAdjacentTriangles(*hitObject, hitTriangleBaseIndex);
                *context.selectedObjId = hitObjectId;
            }
            lastClickTimestamp = currentTime;
            lastClickedObjId = hitObjectId;
            lastClickedTriangleIndex = hitTriangleBaseIndex;
        }
    } else {
        // Clicked on empty space, deselect everything
        if (!shift) {
            *context.selectedObjId = 0;
            context.selectedTriangleIndices->clear();
        }
        lastClickTimestamp = 0;
    }
}

} // namespace Urbaxio::Tools 
ENCODINGUTF8ENCODINGUTF8--- File: shell/src/tools/ToolManager.cpp ---
ENCODINGUTF8#include "tools/ToolManager.h"
#include "tools/SelectTool.h"
#include "tools/LineTool.h"
#include "tools/PushPullTool.h"

namespace Urbaxio::Tools {

ToolManager::ToolManager(const ToolContext& context) : context(context) {
    tools[ToolType::Select] = std::make_unique<SelectTool>();
    tools[ToolType::Line] = std::make_unique<LineTool>();
    tools[ToolType::PushPull] = std::make_unique<PushPullTool>();

    // Start with the Select tool active
    SetTool(ToolType::Select);
}

void ToolManager::SetTool(ToolType type) {
    if (activeTool && activeTool->GetType() == type) {
        return; // Tool is already active
    }

    if (activeTool) {
        activeTool->Deactivate();
    }

    auto it = tools.find(type);
    if (it != tools.end()) {
        activeTool = it->second.get();
        activeTool->Activate(context);
    } else {
        activeTool = nullptr;
    }
}

ITool* ToolManager::GetActiveTool() const {
    return activeTool;
}

ToolType ToolManager::GetActiveToolType() const {
    return activeTool ? activeTool->GetType() : ToolType::Select;
}

bool ToolManager::ShouldEnableSnapping() const {
    if (!activeTool) return true; // Default to enabled
    
    ToolType type = activeTool->GetType();
    
    // Disable snapping for SelectTool
    if (type == ToolType::Select) {
        return false;
    }
    
    // For PushPullTool, disable snapping only when hovering (before operation starts)
    if (type == ToolType::PushPull) {
        // We need to cast to the derived type to access its specific state.
        // This is safe because we know the type from the enum.
        PushPullTool* pushPullTool = static_cast<PushPullTool*>(activeTool);
        return pushPullTool->IsPushPullActive(); // Only enable when operation is active
    }
    
    // For other tools (LineTool), keep snapping enabled.
    return true;
}

void ToolManager::OnLeftMouseDown(int mouseX, int mouseY, bool shift, bool ctrl) {
    if (activeTool) activeTool->OnLeftMouseDown(mouseX, mouseY, shift, ctrl);
}

void ToolManager::OnLeftMouseUp(int mouseX, int mouseY, bool shift, bool ctrl) {
    if (activeTool) activeTool->OnLeftMouseUp(mouseX, mouseY, shift, ctrl);
}

void ToolManager::OnRightMouseDown() {
    if (activeTool) activeTool->OnRightMouseDown();
}

void ToolManager::OnMouseMove(int mouseX, int mouseY) {
    if (activeTool) activeTool->OnMouseMove(mouseX, mouseY);
}

void ToolManager::OnKeyDown(SDL_Keycode key, bool shift, bool ctrl) {
    if (activeTool) activeTool->OnKeyDown(key, shift, ctrl);
}

void ToolManager::OnUpdate(const SnapResult& snap) {
    if (activeTool) activeTool->OnUpdate(snap);
}

void ToolManager::RenderUI() {
    if (activeTool) activeTool->RenderUI();
}

void ToolManager::RenderPreview(Renderer& renderer, const SnapResult& snap) {
    if (activeTool) activeTool->RenderPreview(renderer, snap);
}

} // namespace Urbaxio::Tools 
ENCODINGUTF8ENCODINGUTF8--- File: cmake/GenerateSnapshot.cmake ---
ENCODINGUTF8# CMake script to generate a single file with all project code

set(PROJECT_SOURCE_DIR ${ARGV0})
set(SNAPSHOT_FILE "${PROJECT_SOURCE_DIR}/project_snapshot.txt")

message(STATUS "Generating project snapshot to: ${SNAPSHOT_FILE}")

# --- AI Instructions ---
set(AI_INSTRUCTIONS "--- AI INSTRUCTIONS ---

IMPORTANT:
1. ALWAYS write complete files. Do NOT use '...' or '// ... (rest of the code)' or similar abbreviations. Check ALL files you were asked to modify.
2. Use ONLY English comments in the code (// English comment). Do NOT use Russian comments.
3. Adhere to the existing coding style and structure.
4. After every successful change that compiles and works, create a Git commit by providing the user with the necessary commands.
5. At the end of your response, ALWAYS include the standard command sequence for the user (see USER COMMANDS section below for format).

--- END AI INSTRUCTIONS ---")

# --- User Commands ---
set(USER_COMMANDS "--- USER COMMANDS (Standard Workflow) ---

# 1. Clean Build (if CMakeLists.txt or dependencies changed, or if problems occur)
#    Run these in Developer CommandPrompt for VS
# cd /d C:/Users/illia/OneDrive/Документы/programming/Urbaxio
# rmdir /s /q build
# mkdir build
# cd build
# cmake .. -G \"Visual Studio 17 2022\" -A x64 -DCMAKE_TOOLCHAIN_FILE=C:/vcpkg/scripts/buildsystems/vcpkg.cmake
# cmake --build . --config Debug -- /p:VcpkgEnableManifest=true

# 2. Incremental Build (if only .cpp/.h files changed)
#    Run these in Developer Command Prompt for VS (inside the existing 'build' directory)
# cd /d C:/Users/illia/OneDrive/Документы/programming/Urbaxio/build
# cmake --build . --config Debug -- /p:VcpkgEnableManifest=true

# 3. Run Application (after successful build)
#    Run in Developer Command Prompt for VS
# cd /d C:/Users/illia/OneDrive/Документы/programming/Urbaxio/build/shell/Debug
# .\\Urbaxio.exe
#    (Or find Urbaxio.exe in build\\bin\\Debug or build\\shell\\Debug and double-click)

# 4. Generate Code Snapshot (run when needed for AI)
#    Run in Developer Command Prompt for VS (inside the 'build' directory)
# cd /d C:/Users/illia/OneDrive/Документы/programming/Urbaxio/build
# cmake --build . --target generate_snapshot

# 5. Git Commit & Push (after successful changes)
#    Run in Developer Command Prompt for VS (from project root)
# cd /d C:/Users/illia/OneDrive/Документы/programming/Urbaxio
# git add .
# git commit -m \"A descriptive commit message\"
# git push origin main

--- END USER COMMANDS ---")

# Assemble the full header
set(SNAPSHOT_HEADER "${AI_INSTRUCTIONS}\n\n${USER_COMMANDS}\n\n--- Project Code Snapshot ---\n\n")

# Clear the file and write the header (in UTF8)
file(WRITE ${SNAPSHOT_FILE} "${SNAPSHOT_HEADER}" ENCODING UTF8)

# --- Source Directories to Scan ---
set(SOURCE_DIRS
    "${PROJECT_SOURCE_DIR}"                          # Project root
    "${PROJECT_SOURCE_DIR}/cad_kernel/include/cad_kernel" # CAD Kernel headers
    "${PROJECT_SOURCE_DIR}/cad_kernel/src"           # CAD Kernel sources
    "${PROJECT_SOURCE_DIR}/engine/include/engine"     # Engine headers
    "${PROJECT_SOURCE_DIR}/engine/src"               # Engine sources
    "${PROJECT_SOURCE_DIR}/shell"                    # Shell root (for CMakeLists.txt)
    "${PROJECT_SOURCE_DIR}/shell/include"            # Shell headers
    "${PROJECT_SOURCE_DIR}/shell/src"                # Shell sources
    "${PROJECT_SOURCE_DIR}/shell/include/tools"      # Tools headers (moved to shell)
    "${PROJECT_SOURCE_DIR}/shell/src/tools"          # Tools sources (moved to shell)
    "${PROJECT_SOURCE_DIR}/cmake"                    # CMake helper scripts
    "${PROJECT_SOURCE_DIR}/engine/include/engine/commands" # <-- NEW
    "${PROJECT_SOURCE_DIR}/engine/src/commands"           # <-- NEW
)

# --- File Extensions/Names to Include ---
set(SOURCE_EXTENSIONS
    "*.h" "*.cpp" "*.cmake" "CMakeLists.txt" "*.json" ".gitignore"
)

# --- Function to Add a File to the Snapshot ---
function(add_file_to_snapshot filepath)
    if(EXISTS ${filepath})
        get_filename_component(filename ${filepath} NAME)
        file(RELATIVE_PATH rel_path ${PROJECT_SOURCE_DIR} ${filepath})
        # Ensure consistent path separators (forward slashes)
        string(REPLACE "\\" "/" rel_path ${rel_path})
        file(APPEND ${SNAPSHOT_FILE} "ENCODINGUTF8--- File: ${rel_path} ---\n" ENCODING UTF8) # Add prefix
        file(READ ${filepath} file_content ENCODING UTF8)
        # Replace CRLF with LF for consistency (optional but good)
        # string(REGEX REPLACE "\r\n" "\n" file_content "${file_content}")
        file(APPEND ${SNAPSHOT_FILE} "${file_content}\n" ENCODING UTF8) # Add newline after content
        message(STATUS "  Added: ${rel_path}")
    else()
        message(WARNING "  Snapshot: File not found - ${filepath}")
    endif()
endfunction()

# --- Main Loop to Find and Add Files ---
foreach(dir ${SOURCE_DIRS})
    message(STATUS "Processing directory: ${dir}")
    # Find files matching the patterns in the current directory only (no recursion needed with explicit dirs)
    file(GLOB current_files LIST_DIRECTORIES false RELATIVE "${dir}" "${dir}/*") # Use RELATIVE to get paths relative to dir
    foreach(filename_rel ${current_files})
         set(filepath_abs "${dir}/${filename_rel}") # Construct absolute path
         set(include_file FALSE)
         get_filename_component(filename_only ${filepath_abs} NAME)
         get_filename_component(fileext ${filepath_abs} EXT)
         string(TOLOWER "${fileext}" fileext_lower)

         # Check against specific filenames and extensions
         foreach(ext_pattern ${SOURCE_EXTENSIONS})
             if (ext_pattern STREQUAL filename_only) # Match specific filenames like CMakeLists.txt
                  set(include_file TRUE)
                  break()
             elseif (IS_DIRECTORY ${filepath_abs}) # Skip directories
                 continue()
             elseif (ext_pattern MATCHES "^\\*\\.") # Match extensions like *.h
                 string(REPLACE "*." "." ext_match ${ext_pattern})
                 if (fileext_lower STREQUAL ext_match)
                     set(include_file TRUE)
                     break()
                 endif()
             endif()
         endforeach()

         # Add the file if it matched and is not in the build directory
         if(include_file)
             string(FIND "${filepath_abs}" "/build/" build_pos)
             string(FIND "${filepath_abs}" "\\build\\" build_pos_win)
             if(build_pos EQUAL -1 AND build_pos_win EQUAL -1)
                 add_file_to_snapshot(${filepath_abs})
             else()
                  message(STATUS "  Skipped (in build dir): ${filepath_abs}")
             endif()
         # else()
             # message(STATUS "  Skipped (no match): ${filepath_abs}") # Uncomment for verbose logging
         endif()
     endforeach()
endforeach()

message(STATUS "Project snapshot generation finished.") 
ENCODINGUTF8ENCODINGUTF8--- File: engine/include/engine/commands/CommandManager.h ---
ENCODINGUTF8#pragma once

#include "engine/commands/ICommand.h"
#include <vector>
#include <memory>

namespace Urbaxio::Engine {

class CommandManager {
public:
    CommandManager();

    // Executes a command and adds it to the undo stack
    void ExecuteCommand(std::unique_ptr<ICommand> command);

    // Undoes the last command
    void Undo();

    // Redoes the last undone command
    void Redo();

    // Checks if there are commands to undo/redo
    bool HasUndo() const;
    bool HasRedo() const;
    
    // Clears the history, e.g., for a new scene
    void ClearHistory();

private:
    std::vector<std::unique_ptr<ICommand>> undoStack_;
    std::vector<std::unique_ptr<ICommand>> redoStack_;
};

} // namespace Urbaxio::Engine 
ENCODINGUTF8ENCODINGUTF8--- File: engine/include/engine/commands/CreateLineCommand.h ---
ENCODINGUTF8#pragma once

#include "engine/commands/ICommand.h"
#include <glm/glm.hpp>
#include <vector>
#include <cstdint>
#include <memory> // For std::unique_ptr

namespace Urbaxio::Engine {
    class Scene;
    struct SceneState; // Forward declaration for our Memento is sufficient here
}

namespace Urbaxio::Engine {

// Command to add a user-defined line.
// This is a complex command as it can modify the entire scene topology.
// It uses the Memento pattern on the whole scene.
class CreateLineCommand : public ICommand {
public:
    CreateLineCommand(Scene* scene, const glm::vec3& start, const glm::vec3& end);
    // The destructor MUST be declared here but defined in the .cpp file
    // to handle the std::unique_ptr to an incomplete type (PIMPL idiom).
    ~CreateLineCommand();

    void Execute() override;
    void Undo() override;
    const char* GetName() const override;

private:
    Scene* scene_;
    glm::vec3 start_;
    glm::vec3 end_;
    
    // Memento: pointers to scene state before and after.
    std::unique_ptr<SceneState> stateBefore_;
    std::unique_ptr<SceneState> stateAfter_;
    bool isExecuted_ = false;
};

} // namespace Urbaxio::Engine 
ENCODINGUTF8ENCODINGUTF8--- File: engine/include/engine/commands/ICommand.h ---
ENCODINGUTF8#pragma once

#include <memory>

namespace Urbaxio::Engine {

// Interface for all commands that modify the scene state.
// This is the core of the Command design pattern.
class ICommand {
public:
    virtual ~ICommand() = default;

    // Executes the command's action.
    virtual void Execute() = 0;

    // Reverts the command's action.
    virtual void Undo() = 0;

    // Returns the name of the command for UI or debugging purposes.
    virtual const char* GetName() const = 0;
};

} // namespace Urbaxio::Engine 
ENCODINGUTF8ENCODINGUTF8--- File: engine/include/engine/commands/PushPullCommand.h ---
ENCODINGUTF8#pragma once

#include "engine/commands/ICommand.h"
#include <glm/glm.hpp>
#include <vector>
#include <cstdint>

// Forward declarations
class TopoDS_Shape;

namespace Urbaxio::Engine {
    class Scene;
}

namespace Urbaxio::Engine {

// A command to perform a push/pull (extrusion) operation on a face.
class PushPullCommand : public ICommand {
public:
    PushPullCommand(
        Scene* scene, 
        const std::vector<glm::vec3>& faceVertices,
        const glm::vec3& faceNormal,
        float distance,
        bool disableMerge);

    void Execute() override;
    void Undo() override;
    const char* GetName() const override;

private:
    static std::vector<char> SerializeShape(const TopoDS_Shape& shape);
    void RestoreObjectShape(uint64_t objectId, const std::vector<char>& shapeData);

    Scene* scene_;
    std::vector<glm::vec3> faceVertices_;
    glm::vec3 faceNormal_;
    float distance_;
    bool disableMerge_;
    std::vector<char> shapeBefore_;
    std::vector<char> shapeAfter_;
    uint64_t targetObjectId_ = 0;
    bool isExecuted_ = false;
};

} // namespace Urbaxio::Engine 
ENCODINGUTF8ENCODINGUTF8--- File: engine/src/commands/CommandManager.cpp ---
ENCODINGUTF8#include "engine/commands/CommandManager.h"
#include <iostream>

namespace Urbaxio::Engine {

CommandManager::CommandManager() {}

void CommandManager::ExecuteCommand(std::unique_ptr<ICommand> command) {
    if (!command) {
        return;
    }
    const char* commandName = command->GetName();
    std::cout << "CommandManager: Executing command '" << (commandName ? commandName : "Unknown") << "'" << std::endl;
    
    // Execute the command. The command itself is responsible for changing the model.
    command->Execute();
    
    // Move the executed command to the undo stack.
    undoStack_.push_back(std::move(command));

    // A new action invalidates the old redo history.
    if (!redoStack_.empty()) {
        std::cout << "CommandManager: Clearing redo stack (" << redoStack_.size() << " commands)." << std::endl;
        redoStack_.clear();
    }
}

void CommandManager::Undo() {
    if (undoStack_.empty()) {
        std::cout << "CommandManager: Nothing to undo." << std::endl;
        return;
    }

    // Move the command from the undo stack to the redo stack.
    std::unique_ptr<ICommand> commandToUndo = std::move(undoStack_.back());
    undoStack_.pop_back();

    const char* commandName = commandToUndo->GetName();
    std::cout << "CommandManager: Undoing command '" << (commandName ? commandName : "Unknown") << "'" << std::endl;

    // Perform the undo operation.
    commandToUndo->Undo();

    redoStack_.push_back(std::move(commandToUndo));
}

void CommandManager::Redo() {
    if (redoStack_.empty()) {
        std::cout << "CommandManager: Nothing to redo." << std::endl;
        return;
    }

    // Move the command from the redo stack back to the undo stack.
    std::unique_ptr<ICommand> commandToRedo = std::move(redoStack_.back());
    redoStack_.pop_back();

    const char* commandName = commandToRedo->GetName();
    std::cout << "CommandManager: Redoing command '" << (commandName ? commandName : "Unknown") << "'" << std::endl;

    // Re-execute the command.
    commandToRedo->Execute();

    undoStack_.push_back(std::move(commandToRedo));
}

bool CommandManager::HasUndo() const {
    return !undoStack_.empty();
}

bool CommandManager::HasRedo() const {
    return !redoStack_.empty();
}

void CommandManager::ClearHistory() {
    undoStack_.clear();
    redoStack_.clear();
    std::cout << "CommandManager: History cleared." << std::endl;
}

} // namespace Urbaxio::Engine 
ENCODINGUTF8ENCODINGUTF8--- File: engine/src/commands/CreateLineCommand.cpp ---
ENCODINGUTF8#include "engine/commands/CreateLineCommand.h"
#include "engine/scene.h" // This include brings in the full definition of SceneState

namespace Urbaxio::Engine {

CreateLineCommand::CreateLineCommand(Scene* scene, const glm::vec3& start, const glm::vec3& end)
    : scene_(scene), start_(start), end_(end) {
}

// Define the destructor here in the .cpp file, where SceneState is a complete type.
CreateLineCommand::~CreateLineCommand() = default;

const char* CreateLineCommand::GetName() const {
    return "Create Line";
}

void CreateLineCommand::Execute() {
    if (isExecuted_ && stateAfter_) {
        scene_->RestoreState(*stateAfter_);
        return;
    }

    stateBefore_ = scene_->CaptureState();
    scene_->AddUserLine(start_, end_);
    stateAfter_ = scene_->CaptureState();
    
    isExecuted_ = true;
}

void CreateLineCommand::Undo() {
    if (stateBefore_) {
        scene_->RestoreState(*stateBefore_);
    }
}

} // namespace Urbaxio::Engine 
ENCODINGUTF8ENCODINGUTF8--- File: engine/src/commands/PushPullCommand.cpp ---
ENCODINGUTF8#include "engine/commands/PushPullCommand.h"
#include "engine/scene.h"
#include "engine/scene_object.h"
#include <cad_kernel/cad_kernel.h>
#include <cad_kernel/MeshBuffers.h>

#include <TopoDS_Shape.hxx>
#include <BinTools.hxx>
#include <sstream>
#include <iostream>

namespace Urbaxio::Engine {

PushPullCommand::PushPullCommand(
    Scene* scene, 
    const std::vector<glm::vec3>& faceVertices,
    const glm::vec3& faceNormal,
    float distance,
    bool disableMerge)
    : scene_(scene), 
      faceVertices_(faceVertices),
      faceNormal_(faceNormal),
      distance_(distance),
      disableMerge_(disableMerge)
{
}

const char* PushPullCommand::GetName() const {
    return "Push/Pull";
}

void PushPullCommand::Execute() {
    if (isExecuted_) { // This is a REDO operation
        if (!shapeAfter_.empty() && targetObjectId_ != 0) {
            RestoreObjectShape(targetObjectId_, shapeAfter_);
        }
        return;
    }

    // This is the FIRST execution of the command
    SceneObject* object = scene_->FindObjectByFace(faceVertices_);
    if (!object) {
        std::cerr << "PushPullCommand Error: Could not find an object containing the specified face to execute on." << std::endl;
        return;
    }
    
    targetObjectId_ = object->get_id(); // Store the ID we found for Undo/Redo
    shapeBefore_ = SerializeShape(*object->get_shape());
    if (shapeBefore_.empty()) {
        std::cerr << "PushPullCommand Error: Failed to serialize 'before' state." << std::endl;
        return;
    }
    
    bool success = scene_->ExtrudeFace(targetObjectId_, faceVertices_, faceNormal_, distance_, disableMerge_);
    
    if (success) {
        shapeAfter_ = SerializeShape(*object->get_shape());
    } else {
        std::cerr << "PushPullCommand: ExtrudeFace operation failed. Aborting." << std::endl;
        RestoreObjectShape(targetObjectId_, shapeBefore_);
    }

    isExecuted_ = true;
}

void PushPullCommand::Undo() {
    if (shapeBefore_.empty() || targetObjectId_ == 0) {
        std::cerr << "PushPullCommand Error: Cannot undo, 'before' state was not properly captured." << std::endl;
        return;
    }
    RestoreObjectShape(targetObjectId_, shapeBefore_);
}

void PushPullCommand::RestoreObjectShape(uint64_t objectId, const std::vector<char>& shapeData) {
    SceneObject* object = scene_->get_object_by_id(objectId);
    if (!object) {
        std::cerr << "PushPullCommand Warning: Could not find object " << objectId << " to restore shape." << std::endl;
        return;
    }
    
    TopoDS_Shape restoredShape;
    std::stringstream ss(std::string(shapeData.begin(), shapeData.end()));
    try {
        BinTools::Read(restoredShape, ss);
    } catch (...) {
        std::cerr << "PushPullCommand Error: Failed to deserialize shape data." << std::endl;
        return;
    }
    
    if (restoredShape.IsNull()) {
        std::cerr << "PushPullCommand Error: Deserialized shape is null." << std::endl;
        return;
    }

    object->set_shape(Urbaxio::CadKernel::OCCT_ShapeUniquePtr(new TopoDS_Shape(restoredShape)));
    scene_->UpdateObjectBoundary(object);
    object->set_mesh_buffers(Urbaxio::CadKernel::TriangulateShape(*object->get_shape()));
    object->vao = 0;
}

std::vector<char> PushPullCommand::SerializeShape(const TopoDS_Shape& shape) {
    std::stringstream ss;
    try {
        BinTools::Write(shape, ss);
        std::string const& s = ss.str();
        return std::vector<char>(s.begin(), s.end());
    } catch (...) {
        std::cerr << "PushPullCommand Error: Exception during shape serialization." << std::endl;
        return {};
    }
}

} // namespace Urbaxio::Engine 
ENCODINGUTF8