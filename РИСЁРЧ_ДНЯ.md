Архитектура 
Высокопроизводительного 
Волюметрического Скульптинга: 
Анализ и Пути Оптимизации 
Часть I: Исполнительное Резюме и Диагностика 
Текущей Архитектуры 
1.1. Диагноз: "Использование Разреженной Структуры как 
Плотного Массива" 
Анализ предоставленной кодовой базы проекта 1 выявляет фундаментальное 
архитектурное несоответствие, которое является корнем проблем с 
производительностью. Проект корректно идентифицирует OpenVDB как основную 
технологию для волюметрических данных, что подтверждается файлом vcpkg.json.1 
OpenVDB — это библиотека C++, отмеченная наградами и разработанная для 
эффективного хранения и манипулирования разреженными (sparse) волюметрическими 
данными. Ее иерархическая древовидная структура данных позволяет хранить только 
воксели, находящиеся вблизи поверхности (в так называемой "узкой полосе"), что 
обеспечивает колоссальную экономию памяти и открывает возможности для 
высокооптимизированных алгоритмов. 
Однако текущая реализация, как показал анализ на втором этапе, использует 
openvdb::FloatGrid исключительно как "черный ящик" для хранения данных. Все 
критически важные для производительности операции — скульптинг и последующий 
ремешинг — выполняются путем дорогостоящего преобразования разреженной 
структуры OpenVDB в плотный массив (std::vector<float>) и обратно. 
Идентифицированы два основных узких места: 
1. Скульптинг (SculptTool::applyBrush): Операция кисти (добавление или удаление 
материала) реализована через итерацию по всему плотному массиву вокселей. Это 
приводит к вычислительной сложности $O(N^3)$ (или $O(N*M*L)$), где N, M, L — это 
размеры всей сетки. Эффективная разреженная операция должна иметь сложность, 
пропорциональную $O(k^3)$, где $k$ — размер кисти. Этот подход делает 
интерактивный скульптинг невозможным при увеличении разрешения. 
2. Мешинг (LoadingManager::RemeshJob): Процесс ремешинга использует функцию 
igl::marching_cubes из библиотеки libigl.1 Данная реализация Marching Cubes по 
своей природе требует на вход плотное скалярное поле. Это вынуждает систему 
выполнять ресурсоемкую конвертацию toDenseArray() (из разреженного грида в 
плотный массив) перед каждым обновлением меша, что полностью нивелирует все 
преимущества использования OpenVDB. 
1.2. Стратегия Оптимизации: Три Пути к Производительности 
Для устранения этих фундаментальных узких мест предлагается трехэтапная стратегия, 
позволяющая постепенно наращивать производительность системы: 
● Путь A (Прагматичный): Нативный Разреженный Пайплайн на CPU. Переход на 
использование алгоритмов, которые уже присутствуют в OpenVDB и TBB (обе 
библиотеки подключены в проекте 1) для выполнения операций скульптинга и 
мешинга непосредственно на разреженных данных. 
● Путь B (Высокопроизводительный): GPU-Ускоренный Пайплайн. Миграция всего 
интерактивного пайплайна (данные, скульптинг, мешинг) в память GPU. Этот подход 
использует современные расширения OpenVDB, такие как NanoVDB, для достижения 
производительности в реальном времени. 
● Путь C (Передовой): Кастомные GPU-Кернелы. Достижение максимальной 
производительности и гибкости путем написания собственных вычислительных ядер 
(kernels) с использованием OpenVDB AX или напрямую CUDA/OpenCL. 
1.3. Таблица 1: Сравнительный Анализ Предлагаемых Архитектур 
В таблице ниже представлено высокоуровневое сравнение текущей и предлагаемых 
архитектур. 
 
Архитекту
 ра 
Структура 
Данных 
(Скульпти
 нг) 
Алгоритм 
Скульптин
 га 
Алгоритм 
Мешинга 
Основное 
Узкое 
Место 
Ожидаема
 я 
Произв-ть 
Текущая 
(Проблема
 ) 
std::vector<
 float> 
(Плотная) 
Итерация 
по 
CPU-масси
 ву 1 
igl::marchin
 g_cubes 
(CPU) 1 
CPU 
(Конвертац
 ия 
Sparse-Den
 se) 
Очень 
Низкая (Не 
real-time) 
Путь A 
(Sparse 
CPU) 
openvdb::Fl
 oatGrid 
(Разрежен
 ная) 
openvdb::to
 ols::csgUni
 on 
(CPU/TBB) 
openvdb::to
 ols::volume
 ToMesh 
(CPU/TBB) 
CPU 
(TBB-boun
 d мешинг) 
Средняя 
(Интеракти
 вная) 
Путь B 
(Sparse 
GPU) 
nanovdb::Fl
 oatGrid 
(GPU) 
GPU CSG / 
NanoVDB 
Rebuild 
(GPU) 
GPU 
Marching 
Cubes / 
MeshLib 
(GPU) 
Пропускна
 я 
способнос
 ть PCIe 
Высокая 
(Real-time) 
Путь C 
(Custom 
GPU) 
nanovdb::Fl
 oatGrid 
(GPU) 
OpenVDB 
AX / 
Custom 
CUDA 
Kernel 
(GPU) 
Custom 
GPU 
Mesher 
GPU 
(Вычислите
 льная 
мощность) 
Невероятн
 о Высокая 
 
Часть II: Путь A – Оптимизация на CPU: Переход на 
Нативный Разреженный Пайплайн (OpenVDB + TBB) 
 
Этот раздел посвящен наиболее прагматичному и быстрому способу достижения 
значительного прироста производительности путем использования библиотек, которые 
уже интегрированы в проект.1 
2.1. Реархитектура Скульптинга: От Плотных Массивов к 
CSG-Операциям 
Текущий подход к скульптингу через итерацию плотного массива является главным 
узким местом. Операция скульптинга по своей сути является операцией Конструктивной 
Сплошной Геометрии (CSG): Новая_Сцена = Старая_Сцена + Кисть (Union - Объединение) 
или Новая_Сцена = Старая_Сцена - Кисть (Difference - Вычитание). OpenVDB 
предоставляет высокооптимизированный, многопоточный инструментарий именно для 
этих задач. 
Реализация applyBrush (Псевдокод C++): 
Новая реализация должна полностью отказаться от преобразований 
toDenseArray/fromDenseArray. Вместо этого она должна выполнять следующие шаги: 
1. Создание "Кисти" (Brush Grid): Вместо цикла, для каждого мазка кистью создается 
второй, небольшой openvdb::FloatGrid, представляющий саму кисть. Для 
стандартной сферической кисти идеально подходит 
openvdb::tools::createLevelSetSphere. Эта сетка является Полем Знаковых Расстояний 
(Signed Distance Field, SDF). 
2. Трансформация "Кисти": Сетка кисти не перемещается путем итерации вокселей. 
Вместо этого, ее внутренняя трансформация (openvdb::math::Transform) обновляется 
до текущей мировой позиции кисти. Это операция $O(1)$. 
3. Выполнение CSG: Скульптурная операция выполняется одним вызовом функции: 
openvdb::tools::csgUnion (для добавления) или openvdb::tools::csgDifference (для 
вычитания). 
C++ 
// Псевдокод для SculptTool::applyBrush 
// Необходимые подключения: 
#include <openvdb/tools/Composite.h> 
#include <openvdb/tools/LevelSetSphere.h> 
#include <openvdb/math/Transform.h> 
void SculptTool::applyBrush(..., const glm::vec3& brushWorldPosition) 
{ 
    // 1. Получаем грид сцены (предполагаем, что он уже есть) 
    openvdb::FloatGrid::Ptr sceneGrid = volGeom->getGrid()->grid_; 
 
    // 2. Создаем SDF-сферу для кисти 
    // Рассчитываем радиус кисти в воксельных единицах 
    float brushRadiusInVoxels = brushWorldRadius / volGeom->getGrid()->voxelSize; 
     
    // Создаем грид кисти (SDF с центром в 0,0,0) 
    openvdb::FloatGrid::Ptr brushGrid = 
        openvdb::tools::createLevelSetSphere<openvdb::FloatGrid>( 
            brushRadiusInVoxels,           // радиус в вокселях 
            openvdb::Vec3f(0.0f),          // центр (локальный) 
            1.0f,                          // voxel size (1.0 для грида кисти) 
            brushRadiusInVoxels + 3.0f     // ширина узкой полосы (narrow-band) 
        ); 
 
    // 3. Создаем трансформацию для перемещения кисти в мировую позицию 
    // Трансформация грида кисти должна соответствовать гриду сцены 
    openvdb::math::Transform::Ptr sceneTransform = sceneGrid->transform().copy(); 
     
    // Переводим мировую позицию кисти в пространство индексации сцены 
    openvdb::Vec3d brushIndexPos = sceneTransform->worldToIndex( 
        openvdb::Vec3d(brushWorldPosition.x, brushWorldPosition.y, brushWorldPosition.z) 
    ); 
     
    // Устанавливаем трансформацию кисти так, чтобы ее (0,0,0) совпало с brushIndexPos 
    openvdb::math::Transform::Ptr brushTransform = 
        openvdb::math::Transform::createLinearTransform(1.0); // Voxel size 1.0 
    brushTransform->postTranslate(brushIndexPos); 
    brushGrid->setTransform(brushTransform); 
 
    // 4. Выполняем CSG-операцию (Union = Добавление) 
    // Эта функция автоматически использует TBB для распараллеливания 
    if (brushMode == ADD) { 
        openvdb::tools::csgUnion(*sceneGrid, *brushGrid); // 
    } else if (brushMode == SUBTRACT) { 
        // Для вычитания B из A, мы инвертируем B и делаем Union, 
        // или используем csgDifference. 
        openvdb::tools::csgDifference(*sceneGrid, *brushGrid); // 
    } 
     
    // 5. Запрашиваем ремешинг 
// Важно: система Undo/Redo теперь должна оперировать 
// либо Memento состояния дерева OpenVDB, либо обратными CSG-операциями, 
// а не плотными массивами dataBefore/dataAfter. 
loadingManager->RequestRemesh(scene, objectId); 
} 
Архитектурный переход от for цикла к openvdb::tools::csgUnion несет в себе скрытое 
преимущество. Проект уже использует Intel TBB (Threading Building Blocks), как видно из 
vcpkg.json.1 Инструменты openvdb::tools по умолчанию скомпилированы с поддержкой 
TBB и автоматически распараллеливают свои вычисления. Таким образом, замена цикла 
на вызов csgUnion немедленно и "бесплатно" обеспечивает высокооптимизированную, 
многопоточную реализацию, которая будет масштабироваться на все ядра CPU. 
2.2. Реархитектура Мешинга: От igl::marching_cubes к 
openvdb::tools::volumeToMesh 
Текущий RemeshJob, как было установлено, использует igl::marching_cubes, который 
требует плотную сетку. Это заставляет систему выполнять дорогостоящую операцию 
toDenseArray() при каждом обновлении. 
Решение состоит в том, чтобы использовать собственный, разреженный (sparse-native) и 
адаптивный (adaptive) алгоритм полигонизации, встроенный в OpenVDB: 
openvdb::tools::volumeToMesh. Эта функция работает непосредственно с древовидной 
структурой openvdb::FloatGrid, обходя только активные воксели в узкой полосе (narrow 
band) и полностью игнорируя гигабайты пустого пространства. 
Реализация RemeshJob (Псевдокод C++): 
C++ 
// Псевдокод для LoadingManager::worker_thread_main (секция RemeshJob) 
// Необходимые подключения: 
#include <openvdb/tools/VolumeToMesh.h> 
#include <openvdb/Types.h> // Для Vec3s, Vec3I, Vec4I 
//... 
else if constexpr (std::is_same_v<T, RemeshJob>) { 
    isBlockingOperation_ = false; // Ремешинг в фоне 
    //... 
    openvdb::FloatGrid::Ptr grid = job.gridCopy->grid_; 
 
    // УДАЛИТЬ СТАРЫЙ КОД: 
    // std::vector<float> denseData = grid->toDenseArray(); 
    // Eigen::VectorXd S(totalVoxels);... 
    // igl::marching_cubes(S, GV,...); 
 
    // НОВЫЙ КОД: 
    std::vector<openvdb::Vec3s> points;     // Тип OpenVDB для вершин (float) 
    std::vector<openvdb::Vec3I> triangles;  // Тип OpenVDB для треугольников (int) 
    std::vector<openvdb::Vec4I> quads;      // Тип OpenVDB для квадов (int) 
 
    // 1. Вызываем нативный мешер OpenVDB. 
    // Он работает НАПРЯМУЮ с разреженным гридом. 
    // Он автоматически использует TBB для распараллеливания. 
    const double isoValue = 0.0; // Значение изоповерхности (SDF = 0) 
     
    // Адаптивность: 0.0 = uniform meshing (аналог Marching Cubes). 
    // > 0 = adaptive meshing (Dual Contouring), генерирует более крупную сетку 
    // на плоских участках. Начните с 0.0 для предсказуемого результата. 
    const double adaptivity = 0.0;  
 
    openvdb::tools::volumeToMesh( 
        *grid, points, triangles, quads, isoValue, adaptivity 
    ); // 
 
    // 2. Конвертируем выходные данные в ваш формат MeshBuffers 
    CadKernel::MeshBuffers outMesh; 
    outMesh.vertices.reserve(points.size() * 3); 
    for (const openvdb::Vec3s& p : points) { 
        outMesh.vertices.push_back(p.x()); 
        outMesh.vertices.push_back(p.y()); 
        outMesh.vertices.push_back(p.z()); 
    } 
 
    // OpenVDB выводит треугольники и квады. Ваш MeshBuffers 
    // ожидает только треугольники, поэтому мы триангулируем квады. 
    outMesh.indices.reserve(triangles.size() * 3 + quads.size() * 6); 
    for (const openvdb::Vec3I& t : triangles) { 
        outMesh.indices.push_back(t.x()); 
        outMesh.indices.push_back(t.y()); 
        outMesh.indices.push_back(t.z()); 
    } 
    for (const openvdb::Vec4I& q : quads) { 
        // t1: (x, y, z) 
        outMesh.indices.push_back(q.x()); 
        outMesh.indices.push_back(q.y()); 
        outMesh.indices.push_back(q.z()); 
        // t2: (x, z, w) 
        outMesh.indices.push_back(q.x()); 
        outMesh.indices.push_back(q.z()); 
        outMesh.indices.push_back(q.w()); 
    } 
 
    // 3. Расчет нормалей 
    //... (Ваш существующий код с igl::per_vertex_normals должен работать, 
    //     так как он принимает на вход V и F, которые мы только что сгенерировали)... 
    //... (конвертация в Eigen::MatrixXd, вызов igl::per_vertex_normals,...)... 
 
    // 4. Возвращаем результат 
    RemeshResult result{job.objectId, std::move(outMesh)}; 
    { 
        std::lock_guard<std::mutex> lock(resultMutex_); 
        resultQueue_.push(std::move(result)); 
    } 
} 
//... 
 
Этот переход несет в себе не только выгоду в производительности. igl::marching_cubes — 
это классический алгоритм Marching Cubes (MC). MC известен тем, что создает 
"зубчатые" артефакты и неспособен воспроизводить острые грани и углы. В то же время, 
openvdb::tools::volumeToMesh использует алгоритм, основанный на Dual Contouring. 
Алгоритмы Dual Contouring (DC) и их варианты, такие как Surface Nets, знамениты своей 
способностью сохранять острые грани, что критически важно для скульптинга. Они 
также имеют тенденцию генерировать меш с меньшим количеством полигонов для той 
же визуальной детализации. Таким образом, переход на volumeToMesh не только 
устранит узкое место toDenseArray(), но и значительно повысит качество итогового 
меша. 
 
Часть III: Путь B – GPU-Ускорение: Переход на 
NanoVDB и Динамическую Топологию 
Путь A оптимизирует работу на CPU, но для "невероятной производительности" 
необходимо устранить CPU как узкое место. Это требует переноса всего интерактивного 
пайплайна (данные, скульптинг и мешинг) на GPU. 
3.1. Понимание Новой Экосистемы OpenVDB для GPU 
Экосистема OpenVDB для GPU претерпела ключевые изменения: 
1. OpenVDB (Классический): Его древовидная структура на основе указателей 
(pointer-based) неэффективна для GPU. 
2. NanoVDB (Старый, < v10.0): Изначально это была read-only (только для чтения) 
версия OpenVDB, разработанная NVIDIA. Данные линеаризованы (pointer-less) для 
сверхбыстрого обхода на GPU (например, для рендеринга). Модификация 
(скульптинг) была невозможна. 
3. Dynamic NanoVDB (Новый, v10.0 / v11.0+): Это полностью меняет правила игры. 
Начиная с версий 10.0 и 11.0, в NanoVDB были добавлены инструменты для создания 
и модификации сеток непосредственно на GPU. 
Учитывая, что проект использует vcpkg 1, он, скорее всего, уже имеет доступ к OpenVDB 
11.0 или новее, а следовательно, и к инструментам Dynamic NanoVDB. 
3.2. Предлагаемая Архитектура "GPU-Native" Скульптинга 
Вместо копирования данных "CPU -> GPU" на каждом кадре, вся интерактивная сессия 
скульптинга должна проходить в VRAM. Архитектура GPU-пайплайна обычно является 
"иммутабельной" (immutable), где каждая операция создает новый грид на GPU, вместо 
модификации существующего "на месте" (in-place). 
Новый Пайплайн applyBrush: 
1. [CPU->GPU, Однократно] При выборе объекта для скульптинга, его 
openvdb::FloatGrid с CPU конвертируется в nanovdb::FloatGrid с помощью 
nanovdb::createNanoGrid и загружается в VRAM (например, в буфер CUDA или 
OpenGL SSBO). 
2. **** Для каждого движения кисти (каждого кадра): 
a. Создание Кисти на GPU: Запускается CUDA-кернел или используется 
nanovdb::tools::grid_builder для генерации SDF-сферы кисти прямо в VRAM. 
b. Операция Скульптинга на GPU: Запускается кастомный GPU-кернел (см. Часть IV), 
который для каждого вокселя читает значение из NanoVDB_Сцены и 
NanoVDB_Кисти, выполняет CSG-операцию (например, min(scene_val, brush_val)) и 
записывает результат в новый выходной NanoVDB_Сцены_Кадр_N+1 в VRAM. 
Инструменты NanoVDB 11.0+ для слияния (merging) и перестройки (rebuilding) 
гридов на GPU разработаны для этого. 
c. Ремешинг на GPU: Новый грид NanoVDB_Сцены_Кадр_N+1 немедленно передается 
в GPU-алгоритм мешинга (см. 3.3). 
d. Рендеринг: Полученный меш (вершины/индексы в VBO/EBO) рендерится 
немедленно. 
3. [GPU->CPU, По Окончании] Когда пользователь завершает операцию (например, 
отпускает кнопку мыши), итоговый NanoVDB_Сцены_Финал копируется обратно на 
CPU для обновления "эталонной" openvdb::FloatGrid и сохранения в Memento для 
Undo/Redo. 
Этот пайплайн гарантирует, что все операции, критичные для задержки (скульптинг и 
мешинг), выполняются полностью в VRAM, будучи ограниченными только 
вычислительной мощностью GPU. 
3.3. GPU-Ускоренный Мешинг (Замена 
openvdb::tools::volumeToMesh) 
Поскольку данные теперь находятся в VRAM в формате NanoVDB, вызов 
openvdb::tools::volumeToMesh (который работает на CPU) потребует дорогостоящего 
копирования GPU->CPU, что сведет на нет все преимущества. Необходим мешер, 
работающий на GPU. 
1. Вариант 1: GPU Marching Cubes (Плотный GPU). Это наиболее прямой путь. Вы 
реализуете алгоритм Marching Cubes в виде CUDA-кернела или OpenCL-кернела. 
NVIDIA предоставляет SDK с примерами для этого. Этот подход потребует 
"разворачивания" (decompression) разреженного NanoVDB в плотную 3D-текстуру 
внутри VRAM. Хотя это и требует много VRAM, все операции остаются на GPU, что 
обеспечивает высокую производительность. 
2. Вариант 2: MeshLib (Готовое Решение). Библиотека MeshLib позиционируется как 
C++ библиотека с GPU-ускорением (CUDA). Важно отметить, что она напрямую 
поддерживает .vdb в качестве формата воксельных данных и имеет функции 
meshToDistanceVdbVolume и, предположительно, обратную (voxel-to-mesh).2 
Интеграция MeshLib может предоставить готовый, GPU-ускоренный мешер, который 
принимает на вход openvdb::FloatGrid или его буфер данных, экономя значительное 
время на разработку собственных CUDA-кернелов. 
3. Вариант 3: GPU Dual Contouring / Surface Nets (Разреженный GPU). Это самый 
сложный, но и самый качественный подход. Он включает реализацию алгоритма 
Dual Contouring или Surface Nets в виде GPU-кернела. Эти алгоритмы могут быть 
адаптированы для работы с разреженными данными (например, через обход только 
активных вокселей), что лучше соответствует NanoVDB и производит меши более 
высокого качества с сохранением острых граней. 
Часть IV: Путь C – "За Гранью": Кастомные Кернелы 
и Новые Парадигмы 
Этот раздел отвечает на вопрос "какие еще есть методы" и предлагает инструменты для 
достижения максимального контроля и производительности, выходящие за рамки 
стандартных вызовов библиотек. 
4.1. OpenVDB AX: Ваш Собственный JIT-Компилятор для 
GPU-Кернелов 
OpenVDB AX (Attribute eXpression) — это библиотека, входящая в состав OpenVDB, 
которая предоставляет JIT-компилируемый (Just-In-Time) язык выражений. 
Вдохновленный VEX из Houdini, AX позволяет писать короткие "программы" (кернелы), 
которые выполняются с производительностью, близкой к нативному C++, на данных 
OpenVDB. 
Вместо того, чтобы писать сотни строк сложного кода CUDA для реализации кисти, вы 
можете написать простое выражение. openvdb::ax::Compiler компилирует это выражение 
в оптимизированный код (CUDA или TBB) во время выполнения, а VolumeExecutable 
запускает его параллельно по всем активным вокселям. 
Пример (Псевдокод C++): 
C++ 
// #include <openvdb/ax/Compiler.h> 
// #include <openvdb/ax/VolumeExecutable.h> 
// 1. Создаем компилятор 
openvdb::ax::Compiler compiler; 
// 2. Пишем кернел на языке AX. 
// Этот кернел применяет сферическую кисть (add) 
// f@grid = значение вокселя в гриде "grid" 
// v@P = мировая позиция текущего вокселя 
// f$brush_pos / f$brush_radius = внешние параметры 
const char* ax_kernel = R"( 
// Рассчитываем SDF кисти "на лету" 
f
 loat dist_to_brush_center = length(v@P - f$brush_pos); 
f
 loat brush_sdf = dist_to_brush_center - f$brush_radius; 
// Применяем операцию (add = union = min) 
f@grid = min(f@grid, brush_sdf); 
)"; 
// 3. Компилируем кернел 
auto exe = compiler.compile<openvdb::ax::VolumeExecutable>(ax_kernel); 
// 4. Устанавливаем внешние параметры (uniforms) 
exe->setData("brush_pos", openvdb::Vec3f(brush_x, brush_y, brush_z)); 
exe->setData("brush_radius", 10.0f); 
// 5. Запускаем кернел 
// Он автоматически распараллелит это по всем активным вокселям 
// грида "grid", используя TBB (на CPU) или CUDA (на GPU). 
exe->execute(*sceneGrid); 
OpenVDB AX — это идеальный инструмент для создания сложной, 
высокопроизводительной логики кистей (сглаживание, шум, захват, не-сферические 
кисти), поскольку он абстрагирует всю сложность параллелизма TBB/CUDA. 
4.2. NVIDIA GVDB: Предшественник (Для Информации) 
NVIDIA GVDB была ранней (2017-2018) библиотекой на основе CUDA для работы с 
VDB-подобными структурами на GPU. Важно отметить, что GVDB поддерживала 
динамическую топологию и вычислительные операции (compute operations) на GPU с 
самого начала. Примеры, такие как gFluidSurface (симуляция жидкости) и gSprayDeposit 
(осаждение краски), являются прямыми аналогами GPU-скульптинга. 
GVDB в настоящее время в значительной степени вытеснена NanoVDB. Однако ее 
примеры 3 остаются ценным ресурсом для понимания того, как писать кастомные 
CUDA-кернелы для модификации разреженных воксельных структур. 
4.3. fVDB и NeuralVDB: Будущее (ИИ-Ускорение) 
Самые передовые методы включают ускорение с помощью ИИ: 
● NeuralVDB: Использует ИИ (нейронные сети) для сжатия с потерями VDB-сеток. Это 
позволяет уменьшить объем занимаемой памяти до 100 раз, открывая возможность 
интерактивной работы с наборами данных петабайтного масштаба. 
● fVDB: Это фреймворк для Deep Learning, построенный поверх NanoVDB. Он 
предоставляет дифференцируемые операторы (включая мешинг), что позволяет 
использовать ИИ для генерации и редактирования геометрии. Он полностью 
поддерживает динамическую модификацию сеток на GPU. 
Хотя эти технологии могут быть избыточны для текущей задачи, они являются прямым 
ответом на вопрос "какие еще методы есть" и указывают на то, что вся индустрия 
движется к полностью GPU-ориентированным пайплайнам на базе NanoVDB. 
Часть V: Сравнительный Анализ Структур Данных 
(Почему OpenVDB – Правильный Выбор) 
5.1. OpenVDB против Sparse Voxel Octree (SVO) 
Существует распространенное заблуждение, что OpenVDB — это октадерево (octree). 
Это не так. 
● Архитектура SVO: SVO — это глубокая иерархия, где каждый узел имеет 8 детей 
(3-битный префикс). Глубина дерева напрямую зависит от разрешения. 
● Архитектура OpenVDB: OpenVDB — это мелкое (shallow) и широкое (wide) 
B+дерево. Оно обычно имеет всего 3-4 уровня вложенности, независимо от 
разрешения сцены. Например, стандартная конфигурация 5-4-3 означает, что листья 
хранят сетки 8^3 вокселей, узлы 1-го уровня указывают на 16^3 листьев, а узлы 2-го 
уровня — на 32^3 узлов 1-го уровня. 
Глубокий обход SVO плохо кэшируется на CPU и может вызывать расхождение потоков 
(divergence) на GPU. Динамическое изменение топологии (скульптинг) в SVO является 
крайне сложной и медленной операцией, так как требует блокировок и перестройки 
целых ветвей дерева. 
Напротив, структура OpenVDB была специально разработана для динамической 
топологии. Ее мелкая, широкая структура оптимизирована для современных кэшей CPU 
и обеспечивает доступ к вокселям почти за константное время $O(1)$. Таким образом, 
выбор OpenVDB для скульптинга является абсолютно верным архитектурным решением. 
SVO лучше подходят для статических сцен (рендеринг, трассировка лучей), как в игре 
Dreams или для GPU-стриминга. 
5.2. Плотные Сетки (Dense Grids) против Разреженных (Sparse) 
Текущая проблема производительности проекта 1 заключается в том, что он 
обрабатывает разреженные данные как плотные. Потребление памяти и вычислительная 
сложность для плотных сеток растут кубически ($O(N^3)$). Сетка с разрешением 1024^3 
(стандарт для качественного воксель-арта) потребует 1024*1024*1024 * 4 байта = 4 ГБ 
VRAM или RAM только для хранения данных. Выполнение итерации по такому массиву на 
CPU для каждого мазка кистью невозможно в реальном времени. 
Разреженные сетки, такие как OpenVDB SDF, хранят только воксели возле поверхности в 
"узкой полосе" (narrow-band). Та же сцена 1024^3 может занимать всего 50-100 МБ. 
Переход на разреженные операции (Пути A, B или C) является единственным способом 
достичь высокой производительности при высоких разрешениях. 
Часть VI: Рекомендуемые Библиотеки и Итоговый 
План Действий 
6.1. Сводка по Библиотекам 
● OpenVDB (ASWF): Остается ядром. Необходимо убедиться, что vcpkg 
устанавливает версию 11.0 или новее, чтобы получить доступ к инструментам 
динамической модификации NanoVDB на GPU. 
● Intel TBB: Остается. OpenVDB автоматически использует эту библиотеку для всего 
параллелизма на CPU. 
● Libigl: Рекомендуется Заменить (частично). 
○ igl::marching_cubes: Критически важно заменить. Этот вызов является главным 
узким местом ремешинга. Его следует заменить на openvdb::tools::volumeToMesh 
(для Пути A). 
○ igl::signed_distance: Можно оставить для первоначальной вокселизации B-Rep, 
но нативная альтернатива OpenVDB — openvdb::tools::meshToLevelSet. 
● MeshLib (MeshInspector): Рекомендуется к Рассмотрению (для Пути B). 
○ Это сторонняя C++ библиотека, которая, судя по документации, решает задачу 
"под ключ". 
○ Она имеет GPU-ускорение (CUDA). 
○ Она поддерживает чтение воксельных форматов, включая .vdb. 
○ Она предоставляет C++ API для Voxel-to-Mesh.2 
○ Стратегия: MeshLib можно использовать как готовый GPU-ускоренный "черный 
ящик" для замены igl::marching_cubes в Пути B, что избавляет от необходимости 
писать собственный GPU-мешер. 
● CUDA / OpenCL: (Для Пути B/C). 
○ Потребуется для написания собственных GPU-кернелов (скульптинга или 
мешинга). CUDA (S_33, S_101) является стандартом де-факто и имеет лучшую 
поддержку в NanoVDB, в то время как OpenCL (S_31, S_81, S_121) предлагает 
большую кросс-платформенность. 
6.2. Рекомендуемый План Действий (Дорожная Карта) 
1. Фаза 1: Оптимизация CPU (Низкий Риск, Высокая Отдача) 
○ Задача: Переписать SculptTool::applyBrush. 
○ Действие: Заменить цикл toDenseArray/fromDenseArray 1 на вызовы 
openvdb::tools::createLevelSetSphere и openvdb::tools::csgUnion/csgDifference. 
○ Задача: Переписать LoadingManager::RemeshJob. 
○ Действие: Заменить toDenseArray + igl::marching_cubes 1 на один вызов 
openvdb::tools::volumeToMesh. 
○ Ожидаемый Результат: Скачкообразный рост производительности (вероятно, 
в 10-50 раз) до интерактивных значений на CPU. Повышение качества меша за 
счет перехода на Dual Contouring. 
2. Фаза 2: Миграция на GPU (Производительность Real-time) 
○ Задача: Обновить OpenVDB до версии 11.0+. 
○ Задача: Реализовать архитектуру "GPU-Native" (см. 3.2). 
○ Действие: Реализовать конвертацию openvdb::FloatGrid -> nanovdb::FloatGrid и 
загрузку в VRAM. 
○ Действие: Переписать applyBrush для вызова GPU-версий CSG-операций. 
○ Задача: Заменить openvdb::tools::volumeToMesh (CPU) на GPU-мешер. 
○ Действие: Интегрировать MeshLib для GPU-мешинга из VDB или написать свой 
GPU Marching Cubes. 
○ Ожидаемый Результат: Производительность в реальном времени (>60 FPS) при 
высоких разрешениях. 
3. Фаза 3: Продвинутая Оптимизация (Максимальная Гибкость) 
○ Задача: Реализовать сложные кисти (сглаживание, захват, шум). 
○ Действие: Изучить и внедрить OpenVDB AX. Написать кастомные 
JIT-компилируемые кернелы для каждой кисти. 
○ Ожидаемый Результат: "Невероятная производительность" и гибкость, 
запрошенные в исходном запросе. 
Источники 
1. project_snapshot.txt 
2. MeshLib - 3D Mesh Processing Library C++, Python, C#, C, дата последнего 
обращения: ноября 8, 2025, https://meshlib.io/ 
3. NVIDIA/gvdb-voxels: Sparse volume compute and rendering on NVIDIA GPUs - 
GitHub, дата последнего обращения: ноября 8, 2025, 
https://github.com/NVIDIA/gvdb-voxels 
4. INTRODUCING GVDB SPARSE VOLUMES - Cloudfront.net, дата последнего 
обращения: ноября 8, 2025, 
https://d29g4g2dyqv443.cloudfront.net/sites/default/files/akamai/designworks/do
 cs/GVDB_Launch_Presentation_20160727.pdf 