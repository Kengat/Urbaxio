
Интеграция Волюметрического и Неявного Моделирования в САПР на Основе B-Rep: Архитектурный и Технический Анализ


Часть I: Фундаментальные Концепции — Сдвиг Парадигмы от Поверхностей к Объемам


1.1. Введение: За Пределами Границ

Современные системы автоматизированного проектирования (САПР), включая текущую архитектуру проекта "Urbaxio", традиционно основываются на Граничном Представлении (Boundary Representation, B-Rep). Эта парадигма определяет трехмерный объект явно, описывая его через совокупность ограничивающих его поверхностей, ребер и вершин.1 B-Rep является стандартом для точного машиностроительного и архитектурного проектирования благодаря своей математической строгости и способности к точным булевым операциям. Однако эта строгость сопряжена с топологической жесткостью: операции, изменяющие топологию, такие как добавление отверстия или слияние двух форм, представляют собой сложные вычислительные задачи. Запрос на добавление инструментов "вольного рисования и редактирования" указывает на фундаментальное ограничение B-Rep в задачах, требующих артистической свободы и интуитивного формообразования, где сложные органические формы создаются с легкостью, подобно лепке из глины.5
Решение этой задачи лежит не в добавлении нового пользовательского инструмента, а в интеграции принципиально иной парадигмы геометрического моделирования: неявного и волюметрического представления. В отличие от B-Rep, которое описывает "кожу" объекта, эти подходы определяют форму через пространство, которое она занимает. Данный отчет представляет собой исчерпывающий анализ этих технологий, деконструкцию их реализации в эталонных приложениях, таких как Dreams (PS4) и Adobe Substance 3D Modeler, и предлагает конкретную архитектурную и имплементационную стратегию для их интеграции в существующую B-Rep-ориентированную среду проекта "Urbaxio".

1.2. Воксель: Объемный Строительный Блок

В основе волюметрического моделирования лежит воксель (voxel), или "объемный пиксель". Это элементарная кубическая единица в трехмерной сетке, которая несет в себе информацию о своей точке в пространстве.8 В простейшем случае эта информация представляет собой бинарное состояние (пусто/заполнено), но для более сложных приложений воксель может хранить цвет, плотность, материал или, что наиболее важно для современного скульптинга, значение расстояния до ближайшей поверхности.
Преимущества: Главное преимущество воксельного представления — это абсолютная топологическая свобода. Поскольку геометрия определяется заполнением ячеек сетки, такие операции, как добавление, вычитание и слияние объемов, сводятся к простым манипуляциям с данными в гриде, аналогично редактированию пикселей в растровом изображении.10 Это напрямую решает проблему сложности моделирования в традиционных САПР, позволяя художнику интуитивно "наращивать" и "срезать" материал без оглядки на топологическую корректность полигональной сетки.
Вызовы и Решения: Основной недостаток вокселей — экспоненциальный рост требований к памяти и производительности. Для плотной (dense) сетки размером $N \times N \times N$ объем требуемой памяти пропорционален $O(N^3)$.8 При высоком разрешении, необходимом для детализированных скульптур, это быстро становится неприемлемым.
Решением этой проблемы является использование разреженных (sparse) структур данных. Наиболее распространенной и эффективной структурой для этой цели является октодерево (Octree). Октодерево рекурсивно делит пространство на восемь дочерних кубов (октантов). Если октант полностью пуст или полностью заполнен, он становится листовым узлом. Если же он содержит часть поверхности, он рекурсивно делится дальше. Таким образом, детализация и, следовательно, расход памяти концентрируются только в областях, близких к поверхности модели, в то время как большие пустые или сплошные объемы представлены одним узлом высокого уровня.14 Для любого производственного приложения использование разреженной структуры данных, такой как октодерево, является не опциональной оптимизацией, а фундаментальным архитектурным требованием.

1.3. Математика Формы: Знаковые Поля Расстояний (SDF)

Знаковое Поле Расстояний (Signed Distance Field, SDF) — это неявное представление поверхности. Оно представляет собой скалярную функцию $f(p)$, которая для любой точки $p$ в пространстве возвращает кратчайшее расстояние до поверхности объекта. Знак этого расстояния указывает, находится ли точка внутри (отрицательное значение) или снаружи (положительное значение) объекта.4 Сама поверхность, таким образом, неявно определяется как множество всех точек, для которых $f(p) = 0$. Это множество называется изоповерхностью.
Аналитические Примитивы и Конструктивная Сплошная Геометрия (CSG): Простые геометрические формы имеют простые аналитические SDF. Например, для сферы с центром в начале координат и радиусом $R$, функция имеет вид $f(p) = \text{length}(p) - R$.23 Это свойство лежит в основе неразрушающего моделирования с помощью примитивов, как в Adobe Substance 3D Modeler.
Истинная мощь SDF раскрывается в операциях Конструктивной Сплошной Геометрии (Constructive Solid Geometry, CSG), которые выполняются с помощью простых математических функций, чаще всего min() и max():
Объединение (Union): $f_{A \cup B}(p) = \min(f_A(p), f_B(p))$
Пересечение (Intersection): $f_{A \cap B}(p) = \max(f_A(p), f_B(p))$
Вычитание (Subtraction): $f_{A \setminus B}(p) = \max(f_A(p), -f_B(p))$
Эти операции выполняются для любой точки в пространстве и не требуют сложных вычислений пересечений полигонов, что делает их чрезвычайно надежными. Более сложные функции позволяют создавать плавные переходы (blending) между формами, что и создает тот самый "пушистый" или "оплавленный" вид, который пользователь отметил в Dreams.24
Два Подхода к Использованию SDF:
Анализ показывает, что на практике существуют два фундаментально разных способа работы с SDF, и это различие является ключевым для выбора архитектуры.
Вычисляемые (Evaluative/Functional) SDF: Геометрия хранится не в виде сетки, а в виде списка примитивов и операций над ними (дерева CSG). Чтобы узнать расстояние в любой точке, система рекурсивно вычисляет все дерево функций. Этот подход используется в Dreams 27 и в режиме "Primitives" в Substance Modeler.24 Его главные преимущества — неразрушаемость (параметры любого примитива или операции можно изменить в любой момент) и независимость от разрешения.
Дискретизированные (Discretized/Sampled) SDF: Значения SDF вычисляются один раз для сетки точек и сохраняются в воксельном гриде. Каждая ячейка грида (воксель) хранит предварительно рассчитанное значение расстояния.8 Этот подход используется в режиме "Clay" в Substance Modeler. Скульптурные кисти напрямую изменяют значения расстояний в этом гриде.
Этот двойственный характер SDF является основой для мощных рабочих процессов. Можно создать базовую форму с помощью неразрушаемых функциональных SDF-примитивов, а затем "растеризовать" или "запечь" ее в дискретизированный SDF-грид для последующей детализированной лепки. Обратный процесс (из дискретного грида в функциональное дерево) значительно сложнее и на практике не используется.8 Это наблюдение формирует ключевой архитектурный паттерн, который будет предложен для "Urbaxio".

1.4. Сравнительная Таблица Геометрических Представлений

Для систематизации информации и обоснования дальнейших архитектурных решений, приведена сравнительная таблица различных подходов к представлению геометрии.
Представление
Описание
Топологическая Свобода
Использование Памяти
Булевы Операции
Пригодность для Скульптинга
Метод Рендеринга
B-Rep
Описание через границы: поверхности, ребра, вершины.
Низкая. Изменение топологии — сложная операция.
Низкое. Описывается только поверхность.
Точные, но вычислительно дорогие и хрупкие.
Непригодно.
Триангуляция поверхности и рендеринг полигонов.
Полигональная сетка
Явное представление поверхности набором полигонов.
Средняя. Требует сложных алгоритмов (remeshing) для изменения топологии.
Среднее. Зависит от плотности сетки.
Ненадежные и сложные в реализации.
Возможно (Surface Sculpting), но с топологическими ограничениями.
Прямой рендеринг полигонов.
Плотный воксельный грид
3D-сетка, где каждая ячейка хранит данные (вкл/выкл, SDF).
Высокая. Топология определяется состоянием ячеек.
Очень высокое ($O(N^3)$). Непрактично для больших разрешений.
Тривиальные и абсолютно надежные.
Идеально. Прямая манипуляция данными в гриде.
Извлечение изоповерхности (Marching Cubes) в полигональную сетку.
Разреженный воксельный грид (Октодерево)
Иерархическая 3D-сетка, хранящая данные только вблизи поверхности.
Высокая.
Низкое/Среднее. Зависит от сложности поверхности, а не от объема.
Тривиальные и надежные.
Идеально.
Извлечение изоповерхности (Marching Cubes) в полигональную сетку.
Функциональный SDF
Представление в виде дерева математических функций и операций.
Абсолютная. Топология определяется математикой.
Очень низкое. Хранится только дерево операций.
Тривиальные, надежные и неразрушающие.
Ограниченно. Редактирование через параметры примитивов.
Прямая визуализация (Ray Marching) или растеризация в воксельный грид для последующей обработки.


Часть II: Техническая Деконструкция Эталонного Программного Обеспечения

Переходя от теории к практике, необходимо проанализировать конкретные реализации в приложениях, которые вдохновили данный запрос. Понимание их внутреннего устройства, сильных сторон и компромиссов позволит сделать обоснованный выбор архитектуры для "Urbaxio".

2.1. Пример 1: Dreams (PS4) — Вычисляемый рендерер на "сплэтах"

Dreams представляет собой уникальный пример системы, построенной на принципах, которые радикально отличаются от стандартных конвейеров рендеринга.
Базовое Представление: В основе геометрии в Dreams лежит не воксельный грид, а неразрушаемая история CSG-операций над аналитическими SDF-примитивами. Каждая скульптура — это, по сути, программа или список инструкций, описывающих, как скомбинировать простые формы (сферы, кубы и т.д.) для получения итогового объекта.27 Именно поэтому созданный пользователями контент (UGC) имеет чрезвычайно малый размер, что является одной из ключевых целей разработчиков.7
Ощущение от Скульптинга: Характерный "пушистый", "мягкий" и "оплавленный" вид объектов в Dreams является прямым следствием использования математических операций плавного объединения (smooth union) SDF. Это не визуальный эффект или постобработка, а неотъемлемое свойство математической модели, лежащей в основе геометрии. Интуитивность процесса усиливается за счет использования контроллеров движения PlayStation Move, которые выступают в роли естественных инструментов скульптора.6
Конвейер Рендеринга: Dreams использует крайне нетрадиционный, программно-реализованный конвейер рендеринга, который выполняется преимущественно на вычислительных шейдерах (GPGPU), обходя стандартные аппаратные блоки растеризации полигонов.30 Процесс можно разбить на следующие этапы:
Вычисление SDF: Для каждого пикселя на экране выполняется трассировка луча (ray marching), в ходе которой многократно вычисляется все дерево SDF-функций для нахождения точки пересечения с изоповерхностью.
Генерация Облака Точек: На основе этих пересечений движок генерирует плотное облако точек, лежащих на видимой поверхности геометрии.
Рендеринг "Сплэтов" (Splats): Вместо того чтобы соединять эти точки в треугольники, движок рендерит каждую точку как небольшой, обращенный к камере квадрат (квад). Эти сплэты текстурируются, окрашиваются и смешиваются друг с другом для создания финального "живописного" изображения.30
Архитектурный Вывод: Dreams — это закрытая экосистема, созданная для максимальной артистической выразительности и быстрого обмена творчеством, а не для интеграции со стандартными 3D-пайплайнами.31 Его создатели сознательно отказались от совместимости с такими программами, как Maya, и не ставили целью создание стандартных полигональных мешей на выходе.7 Для проекта "Urbaxio", который уже использует стандартный рендерер на базе OpenGL, пытаться воспроизвести подход Dreams было бы архитектурным тупиком. Это потребовало бы полной переработки всего конвейера рендеринга и отказа от совместимости с существующей B-Rep частью системы. Таким образом, несмотря на впечатляющий визуальный результат, метод Dreams не является практичным решением для поставленной задачи.

2.2. Пример 2: Adobe Substance 3D Modeler — Воксельный SDF-подход

Substance Modeler предлагает более прагматичный и гибридный подход, который служит мостом между миром волюметрического скульптинга и традиционными полигональными рабочими процессами.
Базовое Представление: В основе Modeler лежит гибридная система. Она использует два основных режима, которые соответствуют двум типам SDF-представлений 8:
Режим "Primitives": Этот режим является неразрушающим и использует функциональные (аналитические) SDF. Пользователь оперирует набором примитивов (кубы, сферы, цилиндры) и применяет к ним CSG-операции и модификаторы (скругление, сужение). Все параметры остаются редактируемыми в любой момент.24
Режим "Clay": Этот режим является разрушающим и использует дискретизированные (семплированные) SDF, хранящиеся в воксельном гриде. Когда пользователь переходит в этот режим или применяет скульптурные кисти, функциональное представление "растеризуется" в воксельную сетку, где каждая ячейка хранит значение расстояния. Инструменты, такие как "Clay", "Erase", "Warp", напрямую модифицируют эти значения в гриде, подобно редактированию пикселей в Photoshop.8
Конвейер Рендеринга: В отличие от Dreams, Substance Modeler придерживается традиционного конвейера рендеринга, совместимого со стандартными графическими API:
Воксельный Грид → Полигональная Сетка: Для визуализации воксельного грида (как в режиме "Clay", так и для предпросмотра "Primitives") приложение в реальном времени применяет алгоритм "Шагающие Кубики" (Marching Cubes). Этот алгоритм анализирует значения SDF в ячейках грида и генерирует полигональную сетку, которая аппроксимирует изоповерхность ($f(p) = 0$).21
Рендеринг Сетки: Полученная полигональная сетка рендерится в окне просмотра стандартными средствами, используя аппаратное ускорение для растеризации треугольников.8
Ключевой Вывод: Подход Substance Modeler является идеальной моделью для "Urbaxio". Он обеспечивает как неразрушающее моделирование на основе примитивов, так и свободный скульптинг, при этом на выходе генерируя стандартную полигональную сетку. Это означает, что результат можно легко интегрировать в существующий OpenGL-рендерер, а также экспортировать в стандартные форматы, такие как OBJ, что критически важно для совместимости с другими системами.

2.3. Сравнительная Таблица Волюметрических Конвейеров Рендеринга

Данная таблица напрямую сопоставляет два рассмотренных подхода, делая очевидным выбор для интеграции в существующий проект.
Аспект
Dreams (Вычисляемый рендеринг на "сплэтах")
Adobe Substance 3D Modeler (Полигонизация воксельного грида)
Базовая структура данных
Дерево CSG-операций над аналитическими SDF-примитивами.
Гибридная: дерево CSG-операций (Primitives) и воксельный грид со значениями SDF (Clay).
Метод скульптинга
Неразрушающее изменение параметров примитивов и операций.
Неразрушающее (Primitives) и разрушающее (Clay) редактирование значений в воксельном гриде.
Выходные данные для рендеринга
Облако точек ("сплэты").
Полигональная сетка (треугольники).
Визуальный стиль
"Живописный", мягкий, импрессионистский, с характерными артефактами смешивания.
Четкий, с возможностью как резких граней, так и плавных переходов. Внешний вид определяется стандартным шейдингом полигонов.
Характеристики производительности
Сильно зависит от сложности SDF-функции и количества сплэтов. Оптимизирован под архитектуру PS4.
Зависит от разрешения воксельного грида и производительности алгоритма Marching Cubes.
Интеграция с существующим полигональным рендерером
Очень сложная. Требует полной замены конвейера рендеринга на кастомный, основанный на вычислительных шейдерах.
Простая. На выходе генерируется стандартная полигональная сетка, которая может быть отрисована любым существующим OpenGL/DirectX рендерером.


Часть III: Архитектурная Стратегия для Движка "Urbaxio"

Основываясь на анализе фундаментальных концепций и существующих реализаций, можно сформулировать конкретную и надежную архитектурную стратегию для интеграции волюметрического моделирования в движок "Urbaxio".

3.1. Интеграция Новой Парадигмы Геометрии: Полиморфный Подход

Анализ существующей кодовой базы показывает, что классы SceneObject и Scene спроектированы вокруг связки "B-Rep + Меш". SceneObject содержит Urbaxio::CadKernel::OCCT_ShapeUniquePtr shape_ для точной геометрии и Urbaxio::CadKernel::MeshBuffers mesh_buffers_ для ее триангулированного представления, готового к рендерингу.1 Эта структура тесно связана и оптимизирована для одного типа геометрии.
Прямое добавление указателя на воксельный грид или использование std::variant в SceneObject привело бы к усложнению класса, нарушению принципа единственной ответственности и появлению множества проверок типов по всему коду. Более надежным и масштабируемым решением является использование полиморфизма.
Предлагаемая Архитектура:
Создать абстрактный базовый класс IGeometry: Этот интерфейс будет определять общий контракт для всех типов геометрических представлений. Ключевым методом будет getRenderMesh(), который возвращает MeshBuffers для рендеринга.
Модифицировать SceneObject: Заменить прямые указатели на геометрию одним умным указателем std::unique_ptr<IGeometry>.
Создать конкретные классы геометрии:
BRepGeometry: Существующий класс-обертка для OCCT_ShapeUniquePtr. Его реализация getRenderMesh() будет вызывать функцию TriangulateShape.
VolumetricGeometry: Новый класс для хранения волюметрических данных. Его реализация getRenderMesh() будет запускать алгоритм Marching Cubes для генерации меша из воксельного грида.
Обоснование:
Расширяемость (Принцип Открытости/Закрытости): Эта архитектура позволяет в будущем добавлять новые типы геометрии (например, процедурные сетки, системы частиц), не изменяя класс SceneObject.
Разделение Ответственности: SceneObject отвечает за общие свойства (трансформация, имя, ID), в то время как конкретные классы *Geometry инкапсулируют логику хранения и обработки своего типа данных.
Единообразие: Класс Scene может управлять гетерогенным списком объектов (std::vector<std::unique_ptr<SceneObject>>), вызывая их методы полиморфно, что значительно упрощает логику верхнего уровня, например, в цикле рендеринга.

3.2. Рекомендуемое Представление: Воксельный Грид на Основе SDF

Исходя из анализа в Части II, настоятельно рекомендуется использовать подход, аналогичный Adobe Substance 3D Modeler: воксельный грид, хранящий значения знакового поля расстояний (SDF).
Обоснование:
Совместимость с Рендерером: Этот подход генерирует на выходе стандартную треугольную сетку в формате MeshBuffers, которая идеально вписывается в существующий конвейер рендеринга на OpenGL.1 Не требуется никакой переделки рендерера.
Прямая Манипуляция: Воксельный грид представляет собой дискретную структуру данных, которую легко и интуитивно понятно модифицировать с помощью скульптурных кистей, изменяя значения в ячейках.
Проверенная Концепция: Технология хорошо изучена, имеет множество реализаций в коммерческом ПО и открытом исходном коде, что упрощает поиск информации и готовых решений.8

3.3. Стратегия Хранения Вокселей: От Плотного к Разреженному

Реализацию воксельного хранилища следует проводить поэтапно.
Фаза 1 (Прототип): Плотный 3D-Массив. Начать следует с простейшей реализации: std::vector<float> или динамически выделенного трехмерного массива, представляющего грид фиксированного размера (например, $256^3$). Это позволит быстро реализовать и отладить базовые алгоритмы (скульптинг, Marching Cubes), не усложняя код управлением сложными структурами данных. Отображение 3D-координат $(x, y, z)$ в 1D-индекс массива выполняется по формуле: $index = z \times \text{width} \times \text{height} + y \times \text{width} + x$.34
Фаза 2 (Продакшн): Разреженное Октодерево. Для любого серьезного применения плотный грид непригоден из-за огромного расхода памяти. Необходимо перейти на разреженную структуру данных, такую как октодерево.18
Структура: Листовые узлы октодерева, находящиеся вблизи поверхности, будут содержать небольшие плотные гриды вокселей с высоким разрешением. Узлы, находящиеся глубоко внутри или далеко снаружи объекта, будут просто помечены как "сплошные" или "пустые" без хранения детальных данных.15
Преимущества: Такое представление кардинально сокращает потребление памяти и ускоряет многие операции (например, трассировку луча для кисти), так как позволяет пропускать целые пустые или сплошные области пространства за одну проверку.

Часть IV: Практическое Руководство по Реализации

Этот раздел предоставляет конкретные шаги, фрагменты кода и псевдокод для реализации предложенной архитектуры.

4.1. Шаг 1: Класс VolumetricGeometry и Структура Данных

Сначала необходимо определить новые классы для представления волюметрической геометрии в рамках предложенной полиморфной архитектуры.
IGeometry.h (Концептуальный интерфейс)

C++


#pragma once
#include <cad_kernel/MeshBuffers.h>

namespace Urbaxio::Engine {
    class IGeometry {
    public:
        virtual ~IGeometry() = default;
        
        // Основной метод для получения меша для рендеринга.
        // detailLevel может управлять разрешением генерации.
        virtual Urbaxio::CadKernel::MeshBuffers getRenderMesh(double detailLevel = 1.0) const = 0;
    };
}


VoxelGrid.h (Структура данных для вокселей)

C++


#pragma once
#include <vector>
#include <glm/glm.hpp>

namespace Urbaxio::Engine {
    struct VoxelGrid {
        glm::uvec3 dimensions;
        glm::vec3 origin;
        float voxelSize;
        std::vector<float> sdfData;

        VoxelGrid(const glm::uvec3& dims, const glm::vec3& org, float size)
            : dimensions(dims), origin(org), voxelSize(size), sdfData(dims.x * dims.y * dims.z, size * 2.0f) {}

        float& at(unsigned int x, unsigned int y, unsigned int z) {
            return sdfData[z * dimensions.x * dimensions.y + y * dimensions.x + x];
        }

        const float& at(unsigned int x, unsigned int y, unsigned int z) const {
            return sdfData[z * dimensions.x * dimensions.y + y * dimensions.x + x];
        }
    };
}


VolumetricGeometry.h (Конкретная реализация для SceneObject)

C++


#pragma once
#include "IGeometry.h"
#include "VoxelGrid.h"
#include <memory>

namespace Urbaxio::Engine {
    class VolumetricGeometry : public IGeometry {
    public:
        VolumetricGeometry(std::unique_ptr<VoxelGrid> grid);

        Urbaxio::CadKernel::MeshBuffers getRenderMesh(double detailLevel = 1.0) const override;
        
        // Методы для прямого доступа и модификации воксельных данных
        VoxelGrid* getGrid() { return grid.get(); }
        const VoxelGrid* getGrid() const { return grid.get(); }

    private:
        std::unique_ptr<VoxelGrid> grid;
        mutable Urbaxio::CadKernel::MeshBuffers meshCache;
        mutable bool isCacheDirty = true;
    };
}


Метод getRenderMesh в VolumetricGeometry.cpp будет проверять флаг isCacheDirty. Если он установлен, метод вызовет реализацию алгоритма Marching Cubes, сохранит результат в meshCache и сбросит флаг. В противном случае он вернет кешированный меш.

4.2. Шаг 2: Алгоритм Виртуальной Скульптурной Кисти

Скульптурная кисть в VR будет оперировать напрямую со значениями в VoxelGrid.
Входные данные:
brush_center: Мировая позиция центра кисти (полученная от VR-контроллера).
brush_radius: Радиус кисти.
brush_strength: Сила воздействия (от 0.0 до 1.0).
operation: Тип операции (добавление/вычитание).
Псевдокод алгоритма:

C++


void apply_sculpt_brush(VoxelGrid& grid, glm::vec3 brush_center, float brush_radius, float brush_strength, BrushOperation operation) {
    // 1. Преобразовать мировые координаты кисти в локальные координаты грида
    glm::vec3 local_brush_center = (brush_center - grid.origin) / grid.voxelSize;

    // 2. Определить ограничивающий параллелепипед (bounding box) затронутых вокселей
    int radius_in_voxels = static_cast<int>(ceil(brush_radius / grid.voxelSize));
    glm::ivec3 min_bound = glm::max(glm::ivec3(0), glm::ivec3(floor(local_brush_center)) - radius_in_voxels);
    glm::ivec3 max_bound = glm::min(grid.dimensions - 1, glm::ivec3(ceil(local_brush_center)) + radius_in_voxels);

    // 3. Итерировать по всем вокселям внутри bounding box
    for (int z = min_bound.z; z <= max_bound.z; ++z) {
    for (int y = min_bound.y; y <= max_bound.y; ++y) {
    for (int x = min_bound.x; x <= max_bound.x; ++x) {
        glm::vec3 voxel_center(x, y, z);
        float dist_to_brush_center = glm::distance(voxel_center, local_brush_center);

        // 4. Проверить, попадает ли воксель в радиус действия кисти
        if (dist_to_brush_center < radius_in_voxels) {
            // 5. Определить SDF самой кисти (сфера)
            float sdf_brush = (dist_to_brush_center * grid.voxelSize) - brush_radius;

            // 6. Вычислить фактор затухания (falloff)
            float falloff = 1.0f - (dist_to_brush_center / radius_in_voxels);
            falloff = smoothstep(0.0, 1.0, falloff); // Плавный переход

            // 7. Получить текущее значение SDF вокселя
            float& sdf_voxel = grid.at(x, y, z);
            float original_sdf = sdf_voxel;
            float target_sdf;

            // 8. Применить операцию (простое булево сложение/вычитание)
            if (operation == BrushOperation::ADD) {
                target_sdf = glm::min(original_sdf, sdf_brush);
            } else { // SUBTRACT
                target_sdf = glm::max(original_sdf, -sdf_brush);
            }
            
            // 9. Интерполировать к новому значению с учетом силы и затухания
            sdf_voxel = glm::mix(original_sdf, target_sdf, brush_strength * falloff);
        }
    }
    }
    }
    // После применения кисти необходимо пометить кеш меша как "грязный"
    // volumetric_geometry_object->markCacheDirty();
}


Этот алгоритм является дискретной манипуляцией SDF-гридом, вдохновленной инструментами "Clay" в Substance Modeler 24 и общими принципами цифрового скульптинга.35

4.3. Шаг 3: От Вокселей к Треугольникам — Реализация Marching Cubes

Алгоритм "Шагающие Кубики" является стандартным методом для преобразования воксельных данных в полигональную сетку.37
Обзор алгоритма:
Итерация по кубам: Алгоритм проходит по гриду, рассматривая каждую группу из 8 смежных вокселей ($2 \times 2 \times 2$) как "куб".
Вычисление индекса куба: Для каждой из 8 вершин куба проверяется значение SDF. Если значение меньше порогового (обычно 0.0), вершина считается "внутри" объекта. Результаты этих 8 проверок формируют 8-битный индекс от 0 до 255.
Поиск пересекаемых ребер: Используя cube_index, происходит обращение к предварительно вычисленной таблице edgeTable. Эта таблица возвращает 12-битную маску, указывающую, какие из 12 ребер куба пересекает изоповерхность.
Интерполяция вершин: Для каждого пересеченного ребра вычисляется точная точка пересечения путем линейной интерполяции между двумя его вершинами. Коэффициент интерполяции зависит от значений SDF в этих вершинах.
Создание треугольников: Используя тот же cube_index, происходит обращение ко второй таблице, triTable. Эта таблица содержит информацию о том, как соединить ранее вычисленные вершины на ребрах, чтобы сформировать от 1 до 5 треугольников, аппроксимирующих поверхность внутри куба.
Формирование MeshBuffers: Сгенерированные вершины и индексы добавляются в структуру MeshBuffers. Нормали для вершин могут быть вычислены либо усреднением нормалей треугольников, либо на основе градиента SDF в точке вершины.
Ресурсы: Таблицы edgeTable и triTable являются стандартными и широко доступны в интернете. Например, их можно найти в оригинальной статье Лоренсена и Клайна или в реализации Пола Бурка.38 Нет необходимости выводить их самостоятельно.

4.4. Шаг 4: Соединение Миров B-Rep и Вокселей

Ключевой функцией для бесшовной интеграции является возможность преобразования между представлениями.
B-Rep в Воксели (Вокселизация):
Эта операция необходима, чтобы пользователь мог начать скульптинг на импортированной или созданной в САПР модели.
Инструмент OCCT: OpenCASCADE предоставляет класс Voxel_Convert, который может выполнять вокселизацию. Его алгоритм основан на пересечении сканирующих лучей с триангуляцией исходной формы.40 Это может служить хорошей отправной точкой для получения бинарного (внутри/снаружи) воксельного грида.
Генерация SDF: Для получения более качественного результата, необходимого для Marching Cubes и плавного скульптинга, требуется сгенерировать полноценный SDF-грид. Это можно сделать следующим образом:
Для центра каждой воксельной ячейки $p$ вычислить кратчайшее расстояние до TopoDS_Shape. OCCT предоставляет для этого инструменты, такие как BRepExtrema_DistShapeShape.
Определить знак расстояния. Для этого можно использовать классификатор BRepClass3d_SolidClassifier, чтобы проверить, находится ли точка $p$ внутри или снаружи твердого тела.41
Воксели в B-Rep (Восстановление Поверхности):
Этот процесс, также известный как "surface fitting" или "reverse engineering", является чрезвычайно сложной областью вычислительной геометрии. Он включает в себя аппроксимацию набора точек или полигональной сетки гладкими NURBS-поверхностями. Для текущих задач пользователя эта функциональность, скорее всего, избыточна. Основным рабочим процессом будет преобразование вокселей в полигональную сетку для рендеринга и экспорта, что полностью покрывается алгоритмом Marching Cubes.

Заключение и Стратегические Рекомендации

Запрос на добавление свободного скульптинга в САПР-приложение "Urbaxio" требует фундаментального расширения его геометрического ядра путем интеграции волюметрической парадигмы моделирования. Анализ технологий, лежащих в основе эталонных приложений Dreams и Adobe Substance 3D Modeler, показал, что наиболее прагматичным и совместимым с существующей архитектурой является подход, основанный на воксельном гриде, хранящем значения знакового поля расстояний (SDF), с последующей полигонизацией через алгоритм Marching Cubes.
Ключевые Рекомендации:
Архитектура: Внедрить полиморфную систему геометрии на уровне SceneObject с использованием абстрактного базового класса IGeometry. Это обеспечит чистоту кода, разделит ответственности и создаст задел для будущих расширений.
Представление Данных: Использовать воксельный грид со значениями SDF в качестве основной структуры данных для нового типа объектов VolumetricGeometry.
Реализация: Сфокусироваться на трех ключевых алгоритмах:
Скульптурная кисть: для манипуляции значениями в воксельном гриде.
Marching Cubes: для преобразования воксельного грида в полигональную сетку (MeshBuffers) для рендеринга.
Вокселизация B-Rep: для преобразования существующих САПР-моделей в воксельный формат для последующего скульптинга.
Поэтапный План Разработки:
Интеграция такой сложной системы должна быть поэтапной:
Фаза 1 (Базовая Технология): Реализовать классы VolumetricGeometry и VoxelGrid (на основе плотного массива), алгоритм Marching Cubes и базовую сферическую кисть. Цель — добиться рендеринга и интерактивного изменения одного волюметрического объекта.
Фаза 2 (Интеграция): Реализовать конвейер преобразования B-Rep в SDF-грид. Это позволит пользователям импортировать или создавать САПР-модели и затем переходить к их скульптурной доработке.
Фаза 3 (Оптимизация): Заменить плотный массив в VoxelGrid на разреженную структуру данных (октодерево). Это критически важный шаг для обеспечения приемлемой производительности и работы с большими и детализированными скульптурами.
Оценка Сложности:
Несомненно, это сложная и масштабная задача, требующая глубоких знаний в области вычислительной геометрии, структур данных и алгоритмов. Она затрагивает самые основы геометрического движка. Однако, при следовании предложенному поэтапному плану, использовании существующих библиотек (как OCCT для вокселизации) и известных алгоритмов (Marching Cubes), проект является абсолютно реализуемым и, без сомнения, выведет функциональность "Urbaxio" на качественно новый уровень.
Источники
project_snapshot.txt
Technical Overview - Open CASCADE Technology Documentation, дата последнего обращения: ноября 2, 2025, https://dev.opencascade.org/doc/occt-6.8.0/overview/html/technical_overview.html
BRep Format - Open CASCADE Technology Documentation, дата последнего обращения: ноября 2, 2025, https://dev.opencascade.org/doc/occt-6.7.0/overview/html/occt_brep_format.html
Thoughts on Signed Distance Functions for CAD - James Stanley, дата последнего обращения: ноября 2, 2025, https://incoherency.co.uk/blog/stories/sdf-thoughts.html
Adobe Substance 3D Modeler - how would you compare the two? : r/Plasticity3D - Reddit, дата последнего обращения: ноября 2, 2025, https://www.reddit.com/r/Plasticity3D/comments/1gwr364/adobe_substance_3d_modeler_how_would_you_compare/
Only in Dreams: Addressing the tricky question of what Media Molecule's latest is about, дата последнего обращения: ноября 2, 2025, https://www.eurogamer.net/only-in-dreams-turning-players-into-developers
Do you all consider Media Molecule's Dreams a real game engine? The 'game' has single handedly gotten me into game development, and I think it's incredibly robust for an early access product. - Reddit, дата последнего обращения: ноября 2, 2025, https://www.reddit.com/r/gamedev/comments/ce0oqw/do_you_all_consider_media_molecules_dreams_a_real/
How does Modeler work? | Substance 3D Modeler, дата последнего обращения: ноября 2, 2025, https://helpx.adobe.com/substance-3d-modeler/technical-support/how-does-modeler-work.html
The Main Benefits and Disadvantages of Voxel Modeling - Blog, дата последнего обращения: ноября 2, 2025, https://blog.spatial.com/the-main-benefits-and-disadvantages-of-voxel-modeling
Pure Voxel Sculpting - 3D-Coat, дата последнего обращения: ноября 2, 2025, https://3dcoat.com/documentation/manual/workspaces-rooms/sculpt/voxel-mode/pure-voxel-sculpting/
Advantages of Voxels - Notion, дата последнего обращения: ноября 2, 2025, https://chopsticklabs.notion.site/Advantages-of-Voxels-a9a86c45b9064c729206f0f5ec952a2f
Voxels, Volumetric Sculpting - ZBrushCentral, дата последнего обращения: ноября 2, 2025, https://www.zbrushcentral.com/t/voxels-volumetric-sculpting/278656
Simple C++ Voxel Engine | James Randall, дата последнего обращения: ноября 2, 2025, https://www.jamesdrandall.com/projects/simple_cpp_voxel_engine/
Neural Geometric Level of Detail: Real-time Rendering with Implicit 3D Shapes - Research at NVIDIA, дата последнего обращения: ноября 2, 2025, https://research.nvidia.com/labs/toronto-ai/nglod/
Neural Signed Distance Functions for 3D Shape Representation - Duowen Chen, дата последнего обращения: ноября 2, 2025, https://cdwj.github.io/files/NNDL_Project_Final_Report.pdf
Signed Distance Fields Octree Mapping - KTH, дата последнего обращения: ноября 2, 2025, https://www.kth.se/files/view/dduberg/5f461aee973823706dbdd180/signed_distance_fields_octree_.pdf
∇-SDF: Learning Euclidean Signed Distance Functions Online with Gradient-Augmented Octree Interpolation and Neural Residual - arXiv, дата последнего обращения: ноября 2, 2025, https://arxiv.org/html/2510.18999v1
How to handle 3D voxels efficiently? - c++ - Stack Overflow, дата последнего обращения: ноября 2, 2025, https://stackoverflow.com/questions/9828964/how-to-handle-3d-voxels-efficiently
A Voxel Renderer for Learning C/C++ : r/VoxelGameDev - Reddit, дата последнего обращения: ноября 2, 2025, https://www.reddit.com/r/VoxelGameDev/comments/lasqnu/a_voxel_renderer_for_learning_cc/
Signed Distance Field Rendering Journey pt.1 - kosmonaut's blog, дата последнего обращения: ноября 2, 2025, https://kosmonautblog.wordpress.com/2017/05/01/signed-distance-field-rendering-journey-pt-1/
There's also SDF (Signed Distance Fields) modeling, such as present in multiple ... | Hacker News, дата последнего обращения: ноября 2, 2025, https://news.ycombinator.com/item?id=40491129
Designing with Distance Fields - Mitsubishi Electric Research Laboratories, дата последнего обращения: ноября 2, 2025, https://www.merl.com/publications/docs/TR2006-054.pdf
Ray Marching | Michael Walczyk, дата последнего обращения: ноября 2, 2025, https://michaelwalczyk.com/blog-ray-marching.html
Create with Primitives | Substance 3D Modeler - Adobe Help Center, дата последнего обращения: ноября 2, 2025, https://helpx.adobe.com/substance-3d-modeler/create-with-primitives.html
Painting with Math: A Gentle Study of Raymarching - The Blog of Maxime Heckel, дата последнего обращения: ноября 2, 2025, https://blog.maximeheckel.com/posts/painting-with-math-a-gentle-study-of-raymarching/
[Feature] SDF Modeling Room - 3D-Coat, дата последнего обращения: ноября 2, 2025, https://3dcoat.com/forum/index.php?/topic/28306-feature-sdf-modeling-room/
Learning from failure: - Advances in Real-Time Rendering in Games, дата последнего обращения: ноября 2, 2025, https://advances.realtimerendering.com/s2015/AlexEvans_SIGGRAPH-2015-sml.pdf
Mesh to SDF (Signed Distance Field) Library for Python & C++ - MeshLib SDK, дата последнего обращения: ноября 2, 2025, https://meshlib.io/feature/mesh-to-sdf/
A video game that lets you make video games - Hacker News, дата последнего обращения: ноября 2, 2025, https://news.ycombinator.com/item?id=22394652
The PS4 game "Dreams" from 2015 is pretty much entirely signed distance fields a... | Hacker News, дата последнего обращения: ноября 2, 2025, https://news.ycombinator.com/item?id=27351951
What about Dreams engine? It doesn't use triangles for rendering, how it fits in... | Hacker News, дата последнего обращения: ноября 2, 2025, https://news.ycombinator.com/item?id=25569825
Shape parameters | Substance 3D Modeler - Adobe Help Center, дата последнего обращения: ноября 2, 2025, https://helpx.adobe.com/substance-3d-modeler/create-with-primitives/primitive-parameters/shape-parameters.html
anybody who tried using adobe substance 3d modeler? : r/3Dmodeling - Reddit, дата последнего обращения: ноября 2, 2025, https://www.reddit.com/r/3Dmodeling/comments/1h221lr/anybody_who_tried_using_adobe_substance_3d_modeler/
An Investigation in Implementing a C++ Voxel Game Engine with Destructible Terrain - IdeaExchange@UAkron, дата последнего обращения: ноября 2, 2025, https://ideaexchange.uakron.edu/cgi/viewcontent.cgi?referer=&httpsredir=1&article=1231&context=honors_research_projects
How to implement sculpting in opengl? : r/GraphicsProgramming - Reddit, дата последнего обращения: ноября 2, 2025, https://www.reddit.com/r/GraphicsProgramming/comments/rwu567/how_to_implement_sculpting_in_opengl/
Sculpt 2.0 geometry node - SideFX, дата последнего обращения: ноября 2, 2025, https://www.sidefx.com/docs/houdini/nodes/sop/sculpt.html
Marching cubes - Wikipedia, дата последнего обращения: ноября 2, 2025, https://en.wikipedia.org/wiki/Marching_cubes
Polygonising a scalar field (Marching Cubes) - Paul Bourke, дата последнего обращения: ноября 2, 2025, https://paulbourke.net/geometry/polygonise/
Marching Cubes with OpenGL - DKGR Data Systems, дата последнего обращения: ноября 2, 2025, https://www.dkgrdatasystems.com/news/marching-cubes
Voxel Package - Open CASCADE Technology Documentation, дата последнего обращения: ноября 2, 2025, https://dev.opencascade.org/doc/occt-6.9.1/overview/html/occt_user_guides__voxels_wp.html
Voxelize - Forum Open Cascade Technology, дата последнего обращения: ноября 2, 2025, https://dev.opencascade.org/content/voxelize
