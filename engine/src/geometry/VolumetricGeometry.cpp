#include "engine/geometry/VolumetricGeometry.h"
#include "engine/geometry/VoxelGrid.h"
#include "cad_kernel/MeshBuffers.h"

#include <igl/marching_cubes.h>
#include <igl/per_vertex_normals.h>
#include <Eigen/Core>

#include <iostream>

namespace Urbaxio::Engine {

VolumetricGeometry::VolumetricGeometry(std::unique_ptr<VoxelGrid> grid)
    : grid_(std::move(grid)) {}

VolumetricGeometry::~VolumetricGeometry() = default;

VoxelGrid* VolumetricGeometry::getGrid() {
    return grid_.get();
}

const VoxelGrid* VolumetricGeometry::getGrid() const {
    return grid_.get();
}

CadKernel::MeshBuffers VolumetricGeometry::getRenderMesh(double detailLevel) const {
    CadKernel::MeshBuffers outMesh;
    if (!grid_) {
        return outMesh;
    }

    const auto& dims = grid_->dimensions;
    const size_t totalVoxels = dims.x * dims.y * dims.z;
    if (totalVoxels == 0) {
        return outMesh;
    }

    // 1. Prepare data for libigl
    Eigen::VectorXd S(totalVoxels);
    Eigen::MatrixXd GV(totalVoxels, 3);

    for (unsigned int z = 0; z < dims.z; ++z) {
        for (unsigned int y = 0; y < dims.y; ++y) {
            for (unsigned int x = 0; x < dims.x; ++x) {
                size_t index = z * dims.x * dims.y + y * dims.x + x;
                S(index) = grid_->at(x, y, z);
                
                GV.row(index) << 
                    grid_->origin.x + x * grid_->voxelSize,
                    grid_->origin.y + y * grid_->voxelSize,
                    grid_->origin.z + z * grid_->voxelSize;
            }
        }
    }

    // 2. Run Marching Cubes
    Eigen::MatrixXd V_igl; // Output vertices
    Eigen::MatrixXi F_igl; // Output faces (indices)
    
    try {
        igl::marching_cubes(S, GV, (int)dims.x, (int)dims.y, (int)dims.z, 0.0, V_igl, F_igl);
    } catch (const std::exception& e) {
        std::cerr << "libigl marching_cubes exception: " << e.what() << std::endl;
        return outMesh;
    }

    if (V_igl.rows() == 0 || F_igl.rows() == 0) {
        return outMesh; // No surface generated
    }

    // 3. Convert Eigen matrices to our MeshBuffers struct
    outMesh.vertices.resize(V_igl.rows() * 3);
    for (int i = 0; i < V_igl.rows(); ++i) {
        outMesh.vertices[i * 3 + 0] = (float)V_igl(i, 0);
        outMesh.vertices[i * 3 + 1] = (float)V_igl(i, 1);
        outMesh.vertices[i * 3 + 2] = (float)V_igl(i, 2);
    }

    outMesh.indices.resize(F_igl.rows() * 3);
    for (int i = 0; i < F_igl.rows(); ++i) {
        outMesh.indices[i * 3 + 0] = (unsigned int)F_igl(i, 0);
        outMesh.indices[i * 3 + 1] = (unsigned int)F_igl(i, 1);
        outMesh.indices[i * 3 + 2] = (unsigned int)F_igl(i, 2);
    }

    // 4. Calculate per-vertex normals
    Eigen::MatrixXd N_igl;
    igl::per_vertex_normals(V_igl, F_igl, N_igl);
    
    outMesh.normals.resize(N_igl.rows() * 3);
    for (int i = 0; i < N_igl.rows(); ++i) {
        outMesh.normals[i * 3 + 0] = (float)N_igl(i, 0);
        outMesh.normals[i * 3 + 1] = (float)N_igl(i, 1);
        outMesh.normals[i * 3 + 2] = (float)N_igl(i, 2);
    }
    
    // UVs are not generated by this process.
    outMesh.uvs.assign(V_igl.rows() * 2, 0.0f);

    return outMesh;
}

} // namespace Urbaxio::Engine

